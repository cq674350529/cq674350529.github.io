<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/favicon_64.ico"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon_16.ico"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon_16.ico"><link rel="mask-icon" href="/uploads/favicon_64.ico" color="#222"><meta name="google-site-verification" content="0d4t_hprsM6xsQKeGeYaBnGc8q8SZms2YKwT0JV7R1A"><meta name="msvalidate.01" content="FC470CF968AE82F56A6EF54706074EF7"><meta name="baidu-site-verification" content="yFjlb3QBTm"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"cq674350529.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.14.1","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="前言在Pwn2Own Tokyo 2020比赛上，有2个团队攻破了群晖DS418Play型号的NAS设备，其中DEVCORE团队利用一个堆溢出漏洞在设备上实现了代码执行。根据ZDI的公告，漏洞存在于Netatalk组件中，在解析DSI结构体时由于缺乏对某个长度字段的适当校验，在后续进行拷贝时会出现堆溢出。目前群晖已发布了补丁，该漏洞的触发相对比较简单，参考@Angelboy的分享，在本地环境中完成"><meta property="og:type" content="article"><meta property="og:title" content="Pwn2Own2020 Synology NAS Netatalk Heap Overflow Analysis"><meta property="og:url" content="https://cq674350529.github.io/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/index.html"><meta property="og:site_name" content="cq674350529&#39;s blog"><meta property="og:description" content="前言在Pwn2Own Tokyo 2020比赛上，有2个团队攻破了群晖DS418Play型号的NAS设备，其中DEVCORE团队利用一个堆溢出漏洞在设备上实现了代码执行。根据ZDI的公告，漏洞存在于Netatalk组件中，在解析DSI结构体时由于缺乏对某个长度字段的适当校验，在后续进行拷贝时会出现堆溢出。目前群晖已发布了补丁，该漏洞的触发相对比较简单，参考@Angelboy的分享，在本地环境中完成"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cq674350529.github.io/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/images/cq674350529_afp_over_dsi.png"><meta property="og:image" content="https://cq674350529.github.io/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/images/cq674350529_stack_guard_bruteforce.png"><meta property="og:image" content="https://cq674350529.github.io/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/images/cq674350529_vuln_exploit_summary.png"><meta property="article:published_time" content="2024-09-03T14:00:00.000Z"><meta property="article:modified_time" content="2024-09-03T14:21:38.385Z"><meta property="article:author" content="cq674350529"><meta property="article:tag" content="Synology"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cq674350529.github.io/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/images/cq674350529_afp_over_dsi.png"><link rel="canonical" href="https://cq674350529.github.io/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://cq674350529.github.io/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/","path":"2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/","title":"Pwn2Own2020 Synology NAS Netatalk Heap Overflow Analysis"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Pwn2Own2020 Synology NAS Netatalk Heap Overflow Analysis | cq674350529's blog</title><link rel="dns-prefetch" href="waline-blog-alpha.vercel.app"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="cq674350529's blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">cq674350529's blog</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-lcdpwn"><a href="/lcdpwn/" rel="section"><i class="fa fa-fire fa-fw"></i>LCDPwn</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="nav-number">2.</span> <span class="nav-text">环境准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AFP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.</span> <span class="nav-text">AFP协议介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">漏洞定位和分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#exit-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">5.1.</span> <span class="nav-text">exit()流程分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%86%85%E5%AE%B9%E5%8F%AF%E6%8E%A7%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">5.2.</span> <span class="nav-text">寻找内容可控的地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pointer-demangle"><span class="nav-number">5.3.</span> <span class="nav-text">pointer demangle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stack-guard-pointer-guard%E6%B3%84%E9%9C%B2"><span class="nav-number">5.4.</span> <span class="nav-text">stack_guard&#x2F;pointer_guard泄露</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">7.</span> <span class="nav-text">补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="nav-number">8.</span> <span class="nav-text">相关链接</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="cq674350529" src="/uploads/avatar_64.jpg"><p class="site-author-name" itemprop="name">cq674350529</p><div class="site-description" itemprop="description">Talk is cheap. Show me the code.</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NxNjc0MzUwNTI5" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cq674350529"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOmNxNjc0MzUwNTI5QDE2My5jb20=" title="E-Mail → mailto:cq674350529@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9jcTY3NDM1MDUyOQ==" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;cq674350529"><i class="fab fa-twitter fa-fw"></i>Twitter</span> </span><span class="links-of-author-item"><a href="https://cq674350529.github.io/atom.xml" title="RSS → https:&#x2F;&#x2F;cq674350529.github.io&#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a></span></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cDovL3d3dy5kZXZ0dHlzMC5jb20vYmxvZy8=" title="http:&#x2F;&#x2F;www.devttys0.com&#x2F;blog&#x2F;">/dev/ttyS0</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9hemVyaWEtbGFicy5jb20vd3JpdGluZy1hcm0tYXNzZW1ibHktcGFydC0xLw==" title="https:&#x2F;&#x2F;azeria-labs.com&#x2F;writing-arm-assembly-part-1&#x2F;">Azeria Labs</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9vbGQubGl2ZW92ZXJmbG93LmNvbS9pbmRleC5odG1s" title="https:&#x2F;&#x2F;old.liveoverflow.com&#x2F;index.html">LiveOverflow</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9zY3JpcHRpbmd4c3MuZ2l0Ym9vay5pby9maXJtd2FyZS1zZWN1cml0eS10ZXN0aW5nLW1ldGhvZG9sb2d5Lw==" title="https:&#x2F;&#x2F;scriptingxss.gitbook.io&#x2F;firmware-security-testing-methodology&#x2F;">OWASP FSTM</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly93enQuYWMuY24v" title="https:&#x2F;&#x2F;wzt.ac.cn&#x2F;">CataLpa</span></li></ul></div></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cq674350529.github.io/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar_64.jpg"><meta itemprop="name" content="cq674350529"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="cq674350529's blog"><meta itemprop="description" content="Talk is cheap. Show me the code."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Pwn2Own2020 Synology NAS Netatalk Heap Overflow Analysis | cq674350529's blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Pwn2Own2020 Synology NAS Netatalk Heap Overflow Analysis</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-09-03 22:00:00 / 修改时间：22:21:38" itemprop="dateCreated datePublished" datetime="2024-09-03T22:00:00+08:00">2024-09-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/IoT/" itemprop="url" rel="index"><span itemprop="name">IoT</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/IoT/%E6%BC%8F%E6%B4%9E/" itemprop="url" rel="index"><span itemprop="name">漏洞</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">评论：</span> <a title="waline" href="/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在<code>Pwn2Own Tokyo 2020</code>比赛上，有<code>2</code>个团队攻破了群晖<code>DS418Play</code>型号的<code>NAS</code>设备，其中<code>DEVCORE</code>团队利用一个堆溢出漏洞在设备上实现了代码执行。根据<code>ZDI</code>的<span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Fkdmlzb3JpZXMvWkRJLTIxLTQ5Mi8=">公告<i class="fa fa-external-link-alt"></i></span>，漏洞存在于<code>Netatalk</code>组件中，在解析<code>DSI</code>结构体时由于缺乏对某个长度字段的适当校验，在后续进行拷贝时会出现堆溢出。目前群晖已发布了补丁，该漏洞的触发相对比较简单，参考<code>@Angelboy</code>的<span class="exturl" data-url="aHR0cHM6Ly9oaXRjb24ub3JnLzIwMjEvYWdlbmRhLzAzZjA2Njc1LTI2MWQtNGM5Ny1iNTI0LTMzZWY5Y2M2Y2NiMi8lRTQlQkQlQTAlRTclOUElODQlMjBOQVMlMjAlRTQlQjglOEQlRTYlOTglQUYlRTQlQkQlQTAlRTclOUElODQlMjBOQVMlMjAhLnBkZg==">分享<i class="fa fa-external-link-alt"></i></span>，在本地环境中完成了对漏洞的利用。</p><a id="more"></a><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>群晖环境的搭建可参考之前的文章<a href="https://cq674350529.github.io/2021/08/30/A-Journey-into-Synology-NAS-%E7%B3%BB%E5%88%97%E4%B8%80-%E7%BE%A4%E6%99%96NAS%E4%BB%8B%E7%BB%8D/">《A Journey into Synology NAS 系列一: 群晖NAS介绍》</a>,这里不再赘述。根据群晖的<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3lub2xvZ3kuY29tL3poLWhrL3NlY3VyaXR5L2Fkdmlzb3J5L1N5bm9sb2d5X1NBXzIwXzI2">安全公告<i class="fa fa-external-link-alt"></i></span>，<code>DSM</code> <code>6.2.3-25426-3</code>以下的版本均受该漏洞影响，由于手边有一个<code>DSM 6.1.7</code>的虚拟机，故这里基于<code>DSM</code> <code>6.1.7-15284</code>版本进行分析。</p><p>另外，<code>HITCON CTF 2021</code>比赛中出了一道类似的题目<code>metatalk</code>，如果只是想复现和学习该漏洞的话，也可以基于该题目提供的<code>docker</code>环境来进行分析，相关文件及<code>writeup</code>可参考<span class="exturl" data-url="aHR0cHM6Ly9raWxlYWsuZ2l0aHViLmlvL2N0Zi8yMDIxL2hpdGNvbjIxLW1ldGF0YWxrLw==">《hitcon CTF 2021 - metatalk》<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="AFP协议介绍"><a href="#AFP协议介绍" class="headerlink" title="AFP协议介绍"></a>AFP协议介绍</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://netatalk.sourceforge.net/"><code>Netatalk</code></a>是一个免费开源的<code>Apple Filing Protocol(AFP)</code>服务程序，属于<code>Apple File Service(AFS)</code>的一部分，用来为早期的<code>macOS</code>提供文件服务，类似于<code>Windows</code>上的<code>Samba</code>。该组件在很多<code>NAS</code>设备上都存在，群晖设备上的<code>Netatalk</code>组件来源于该开源组件，并在其基础上进行了定制化修改，不过大体功能和代码与原始组件类似。</p><p><code>AFP</code>协议建立在<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Data_Stream_Interface"><code>Data Stream Interface(DSI)</code></a>之上，<code>DSI</code>是一个会话层，用于在<code>TCP</code>层上承载<code>AFP</code>协议的流量。<code>DSI</code>数据包的格式如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* What a DSI packet looks like:</span></span><br><span class="line"><span class="comment">   0                               32</span></span><br><span class="line"><span class="comment">   |-------------------------------|</span></span><br><span class="line"><span class="comment">   |flags  |command| requestID     |</span></span><br><span class="line"><span class="comment">   |-------------------------------|</span></span><br><span class="line"><span class="comment">   |error code/enclosed data offset|</span></span><br><span class="line"><span class="comment">   |-------------------------------|</span></span><br><span class="line"><span class="comment">   |total data length              |</span></span><br><span class="line"><span class="comment">   |-------------------------------|</span></span><br><span class="line"><span class="comment">   |reserved field                 |</span></span><br><span class="line"><span class="comment">   |-------------------------------|</span></span><br><span class="line"><span class="comment">   CONVENTION: anything with a dsi_ prefix is kept in network byte order.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dsi_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> dsi_flags;       <span class="comment">/* packet type: request or reply */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> dsi_command;     <span class="comment">/* command */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> dsi_requestID;  <span class="comment">/* request ID */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> dsi_code;   <span class="comment">/* error code */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> dsi_doff;   <span class="comment">/* data offset */</span></span><br><span class="line">    &#125; dsi_data;</span><br><span class="line">    <span class="keyword">uint32_t</span> dsi_len;        <span class="comment">/* total data length */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dsi_reserved;   <span class="comment">/* reserved field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>dsi_command</code>字段可能的取值及含义如下。</p><table><thead><tr><th>Name</th><th>Code</th><th>Direction</th><th>Description</th></tr></thead><tbody><tr><td>DSICloseSession</td><td>1</td><td>Both</td><td>Closes an established session</td></tr><tr><td>DSICommand</td><td>2</td><td>From client</td><td>Attached payload contains an AFP command</td></tr><tr><td>DSIGetStatus</td><td>3</td><td>From client</td><td>Get information about the server</td></tr><tr><td>DSIOpenSession</td><td>4</td><td>From client</td><td>Establish a new session</td></tr><tr><td>DSITickle</td><td>5</td><td>Both</td><td>Ensure the connection is active</td></tr><tr><td>DSIWrite</td><td>6</td><td>From client</td><td>Write data to the server</td></tr><tr><td>DSIAttention</td><td>8</td><td>From server</td><td>Get the attention of the client</td></tr></tbody></table><p><code>AFP</code>协议数据包的第一个字段为<code>command</code>，成功解析数据包后会根据该字段来查找对应的处理函数，部分<code>command</code>与处理函数的对应关系如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AFP functions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFP_BYTELOCK       1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFP_CLOSEVOL       2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFP_CLOSEDIR       3</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFP_LOGIN         18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFP_LOGINCONT     19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFP_LOGOUT        20</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFP_MOVE          23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFP_OPENVOL       24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFP_OPENDIR       25</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>为了便于理解协议的交互流程，从<code>macOS</code>上访问该服务并进行抓包分析，大概的交互流程如下。首先，通过发送<code>DSIGetStatus</code>请求获取<code>afp server</code>的相关信息，比如支持的<code>AFP</code>协议版本、<code>UAMS</code>列表等，之后通过发送<code>DSIOpenSession</code>请求建立会话；会话建立之后，通过发送<code>DSICommand</code>请求执行<code>AFP</code>相关的操作，包括<code>FPLogin</code>、<code>FPGetUserInfo</code>、<code>FPOpenVol</code>等；最后通过发送<code>DSICloseSession</code>请求来结束会话。</p><img src="images/cq674350529_afp_over_dsi.png" style="zoom:80%"><p>在了解了协议的通信格式和交互流程后，下面对漏洞进行定位和分析。</p><h3 id="漏洞定位和分析"><a href="#漏洞定位和分析" class="headerlink" title="漏洞定位和分析"></a>漏洞定位和分析</h3><p>根据<code>ZDI</code><span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Fkdmlzb3JpZXMvWkRJLTIxLTQ5Mi8=">公告<i class="fa fa-external-link-alt"></i></span>中的描述信息可知，该堆溢出漏洞与<code>dsi_doff</code>字段有关。在<code>Netatalk</code>的源码中搜索与<code>dsi_doff</code>字段相关的代码，定位到<code>dsi_stream_receive()</code>中，如下。可以看到，如果<code>dsi header</code>部分的<code>dsi_doff</code>字段不为<code>0</code>，在<code>(1)</code>处会将其赋值给<code>dsi-&gt;cmdlen</code>，之后在<code>(2)</code>处会调用<code>dsi_stream_read()</code>读取<code>afp</code>数据包的内容(对应<code>dsi</code>部分的载荷)，并将其保存到<code>dsi-&gt;commands</code>缓冲区中。由于读取内容的长度由<code>dsi-&gt;cmdlen</code>指定，而其值外部可控，因此猜测这里就是漏洞点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dsi_stream_receive</span><span class="params">(DSI *dsi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/* read in the header */</span></span><br><span class="line">  <span class="keyword">if</span> (dsi_buffered_stream_read(dsi, (<span class="keyword">uint8_t</span> *)block, <span class="keyword">sizeof</span>(block)) != <span class="keyword">sizeof</span>(block)) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_requestID, block + <span class="number">2</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_requestID));</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_data.dsi_doff, block + <span class="number">4</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_data.dsi_doff));</span><br><span class="line">  dsi-&gt;header.dsi_data.dsi_doff = htonl(dsi-&gt;header.dsi_data.dsi_doff);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_len, block + <span class="number">8</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_len));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_reserved, block + <span class="number">12</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_reserved));</span><br><span class="line">  dsi-&gt;clientID = ntohs(dsi-&gt;header.dsi_requestID);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* make sure we don&#x27;t over-write our buffers. */</span></span><br><span class="line">  dsi-&gt;cmdlen = MIN(ntohl(dsi-&gt;header.dsi_len), dsi-&gt;server_quantum);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receiving DSIWrite data is done in AFP function, not here */</span></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;header.dsi_data.dsi_doff) &#123;</span><br><span class="line">      LOG(log_maxdebug, logtype_dsi, <span class="string">&quot;dsi_stream_receive: write request&quot;</span>);</span><br><span class="line">      dsi-&gt;cmdlen = dsi-&gt;header.dsi_data.dsi_doff;    <span class="comment">// (1) controllable</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi_stream_read(dsi, dsi-&gt;commands, dsi-&gt;cmdlen) != dsi-&gt;cmdlen)  <span class="comment">// (2) heap overflow</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>往前查找<code>dsi-&gt;commands</code>初始化的地方，如下。在<code>dsi_init_buffer()</code>中，调用<code>malloc(dsi-&gt;server_quantum))</code>申请堆空间。默认情况下，<code>dsi-&gt;server_quantum</code>字段的值来自于<code>DSI_SERVQUANT_DEF</code>，其值为<code>0x100000</code>，即<code>dsi-&gt;commands</code>缓冲区的大小为固定的<code>1M</code>。因此可以确定<code>(2)</code>处为漏洞触发点。</p><blockquote><p>也可以通过补丁比对的方式来定位漏洞点，对应的程序为<code>afpd</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dsi_init_buffer</span><span class="params">(DSI *dsi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((dsi-&gt;commands = <span class="built_in">malloc</span>(dsi-&gt;server_quantum)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function">DSI *<span class="title">dsi_init</span><span class="params">(AFPObj *obj, <span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">const</span> <span class="keyword">char</span> *address, <span class="keyword">const</span> <span class="keyword">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DSI   *dsi;</span><br><span class="line">    <span class="keyword">if</span> ((dsi = (DSI *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DSI))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    dsi-&gt;attn_quantum = DSI_DEFQUANT;</span><br><span class="line">    dsi-&gt;server_quantum = obj-&gt;options.server_quantum;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSI_SERVQUANT_DEF   0x100000L   <span class="comment">/* default server quantum (1 MB) */</span></span></span><br></pre></td></tr></table></figure><p>通过查找<code>dsi_stream_receive()</code>的交叉引用，以及对<code>afp</code>相关代码的处理流程进行分析，该漏洞的触发方式如下，且无需认证：</p><ol><li>发送<code>DSIOpenSession</code>请求建立一个新的会话；</li><li>会话建立成功之后，发送<code>DSICommand</code>请求并指定<code>dsi_doff</code> 为<code>0x1a0000</code>，即可触发漏洞。</li></ol><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>根据上面的分析可知，发生溢出的堆块大小为<code>0x100000L</code>，程序<code>afpd</code>使用的<code>glibc</code>版本为<code>2.20</code>，故该堆空间是通过<code>mmap()</code>进行分配，常规的一些小堆的利用方式在这里不适用。</p><blockquote><p>漏洞利用思路主要参考了<code>@Angelboy</code>的<span class="exturl" data-url="aHR0cHM6Ly9oaXRjb24ub3JnLzIwMjEvYWdlbmRhLzAzZjA2Njc1LTI2MWQtNGM5Ny1iNTI0LTMzZWY5Y2M2Y2NiMi8lRTQlQkQlQTAlRTclOUElODQlMjBOQVMlMjAlRTQlQjglOEQlRTYlOTglQUYlRTQlQkQlQTAlRTclOUElODQlMjBOQVMlMjAhLnBkZg==">分享<i class="fa fa-external-link-alt"></i></span>和<code>@Kileak</code>的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://kileak.github.io/ctf/2021/hitcon21-metatalk/"><code>metatalk writeup</code></a>。</p></blockquote><p><code>afpd</code>开启的保护机制，以及运行时的部分地址空间布局如下。可以看到，<code>dsi-&gt;commands</code>的地址为<code>0x7ffff7edf000</code>，在其下方有一段大小为<code>0x1b000</code>的空间，其对应<code>Thread Local Storage(TLS)</code>，里面保存了<code>tls</code>相关的结构体、<code>TLS destructors</code>、线程局部变量和线程的<code>main arena</code>指针等信息。</p><blockquote><p><code>glibc TLS</code>的相关信息可参考<span class="exturl" data-url="aHR0cHM6Ly9kZXJlLnByZXNzLzIwMjAvMTAvMTgvZ2xpYmMtdGxzLw==">这里<i class="fa fa-external-link-alt"></i></span>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec --file afpd</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> memory layout</span></span><br><span class="line">(gdb) info proc mappings</span><br><span class="line">Mapped address spaces:</span><br><span class="line">          Start Addr           End Addr       Size     Offset objfile</span><br><span class="line">            0x400000           0x459000    0x59000        0x0 /usr/bin/afpd</span><br><span class="line">            0x658000           0x659000     0x1000    0x58000 /usr/bin/afpd</span><br><span class="line">            0x659000           0x65e000     0x5000    0x59000 /usr/bin/afpd</span><br><span class="line">            0x65e000           0x6c7000    0x69000        0x0 [heap]</span><br><span class="line">      0x7fffeb9be000     0x7fffec5bf000   0xc01000        0x0</span><br><span class="line">      # ...</span><br><span class="line">      0x7ffff368d000     0x7ffff3828000   0x19b000        0x0 /usr/lib/libc-2.20-2014.11.so</span><br><span class="line">      0x7ffff3828000     0x7ffff3a28000   0x200000   0x19b000 /usr/lib/libc-2.20-2014.11.so</span><br><span class="line">      0x7ffff3a28000     0x7ffff3a2c000     0x4000   0x19b000 /usr/lib/libc-2.20-2014.11.so</span><br><span class="line">      0x7ffff3a2c000     0x7ffff3a2e000     0x2000   0x19f000 /usr/lib/libc-2.20-2014.11.so</span><br><span class="line">      # ...</span><br><span class="line">      0x7ffff7b49000     0x7ffff7bc8000    0x7f000        0x0 /usr/lib/libatalk.so.17.0.0</span><br><span class="line">      0x7ffff7bc8000     0x7ffff7dc8000   0x200000    0x7f000 /usr/lib/libatalk.so.17.0.0</span><br><span class="line">      0x7ffff7dc8000     0x7ffff7dc9000     0x1000    0x7f000 /usr/lib/libatalk.so.17.0.0</span><br><span class="line">      0x7ffff7dc9000     0x7ffff7dcc000     0x3000    0x80000 /usr/lib/libatalk.so.17.0.0</span><br><span class="line">      0x7ffff7dcc000     0x7ffff7ddc000    0x10000        0x0</span><br><span class="line">      0x7ffff7ddc000     0x7ffff7dfd000    0x21000        0x0 /usr/lib/ld-2.20-2014.11.so</span><br><span class="line">      0x7ffff7edf000     0x7ffff7fe0000   0x101000        0x0   # &lt;=== heap via mmap(), dsi-&gt;commands</span><br><span class="line">      0x7ffff7fe0000     0x7ffff7ffb000    0x1b000        0x0   # Thread Local Storage(TLS)</span><br><span class="line">      0x7ffff7ffb000     0x7ffff7ffc000     0x1000        0x0 [vdso]</span><br><span class="line">      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x20000 /usr/lib/ld-2.20-2014.11.so</span><br><span class="line">      0x7ffff7ffd000     0x7ffff7fff000     0x2000    0x21000 /usr/lib/ld-2.20-2014.11.so</span><br><span class="line">      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]</span><br><span class="line">  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]</span><br></pre></td></tr></table></figure><p>在<code>TLS</code>中，可能被用于利用的目标有很多，比如线程的<code>main arena</code>指针、<code>point_guard</code>和<code>tls_dtor_list</code>等，这里采用伪造<code>tls_dtor_list</code>的方式来实现控制流劫持。</p><h4 id="exit-流程分析"><a href="#exit-流程分析" class="headerlink" title="exit()流程分析"></a>exit()流程分析</h4><p>首先看下<code>exit()</code>函数，如下，其会调用<code>__run_exit_handlers()</code>。在<code>__run_exit_handlers()</code>中，其会先调用<code>TLS destructors</code>，然后再调用所有通过<code>atexit/on_exit</code>注册的函数，这里重点关注前者。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdlib/exit.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call all functions registered with `atexit&#x27; and `on_exit&#x27;,</span></span><br><span class="line"><span class="comment">   in the reverse of the order in which they were registered</span></span><br><span class="line"><span class="comment">   perform stdio cleanup, and terminate program execution with STATUS.  */</span></span><br><span class="line"><span class="keyword">void</span> attribute_hidden __run_exit_handlers (<span class="keyword">int</span> status, struct exit_function_list **listp,</span><br><span class="line">         <span class="keyword">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在<code>__call_tls_dtors()</code>中，其会遍历<code>tls_dtor_list</code>列表，针对每个<code>dtor_list</code>，在<code>(5)</code>处调用<code>func(cur-&gt;obj)</code>。如果能伪造<code>tls_dtor_list</code>，则可以指定其<code>func</code>字段和<code>obj</code>字段，从而实现控制流劫持，且第<code>1</code>个参数可控。另外，在<code>(4)</code>处涉及到<code>pointer demangle</code>，后面会进行说明。根据<code>tls_dtor_list</code>的定义可知，其是一个带有关键字<code>__thread</code>的静态变量，而<code>__thread</code>的作用是告诉编译器将其放入<code>Thread Local Storage(TLS)</code>中，对应前面提到的<code>dsi-&gt;commands</code>下方的内存空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdlib/cxa_thread_atexit_impl.c</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*dtor_func)</span> <span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="keyword">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">tls_dtor_list</span>;</span></span><br><span class="line"><span class="keyword">static</span> __thread <span class="keyword">void</span> *dso_symbol_cache;</span><br><span class="line"><span class="keyword">static</span> __thread <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">lm_cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __call_tls_dtors (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;  <span class="comment">// (3)</span></span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);  <span class="comment">// (4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);  <span class="comment">// (5)</span></span><br><span class="line">      <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>那在实际中是如何访问<code>tls_dtor_list</code>变量的呢？查看对应<code>libc-2.20-2014.11.so</code>中<code>__call_tls_dtors</code>的代码，如下。大体流程与上面的源码类似，而<code>tls_dtor_list</code>的获取是通过调用<code>__tls_get_addr()</code>实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 _call_tls_dtors()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  result = __tls_get_addr(&amp;stru_7FFFF3A2BD90);</span><br><span class="line">  <span class="keyword">for</span> ( i = *(_QWORD **)(result + <span class="number">64</span>); i; i = *(_QWORD **)(result + <span class="number">64</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = __tls_get_addr(&amp;stru_7FFFF3A2BD90);</span><br><span class="line">    v3 = i[<span class="number">1</span>];</span><br><span class="line">    v4 = (<span class="keyword">void</span> (__fastcall *)(__int64))(__readfsqword(<span class="number">0x30</span>u) ^ __ROR8__(*i, <span class="number">17</span>));</span><br><span class="line">    *(_QWORD *)(v2 + <span class="number">64</span>) = i[<span class="number">3</span>];</span><br><span class="line">    v4(v3);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>__tls_get_addr()</code>的实现，其会通过<code>THREAD_DTV()</code>来获取当前线程的<code>dtv</code>，最后返回<code>(char *) p + GET_ADDR_OFFSET</code>。其中，<code>THREAD_DTV</code>为定义的宏变量，对应<code>THREAD_GETMEM (__pd, header.dtv)</code>，即获取当前线程<code>dtv</code>的地址。从<code>THREAD_GETMEM</code>的定义可知，其返回的值为<code>[fs:xxx]</code>，即获取<code>fs</code>段寄存器偏移<code>xxx</code>处的值，而<code>xxx</code>对应<code>header.dtv</code>在结构体<code>pthread</code>中的偏移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elf/dl-tls.c</span></span><br><span class="line"><span class="comment">/* The generic dynamic and local dynamic model cannot be used in</span></span><br><span class="line"><span class="comment">   statically linked applications.  */</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__tls_get_addr (GET_ADDR_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv = THREAD_DTV ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (dtv[<span class="number">0</span>].counter != GL(dl_tls_generation)))</span><br><span class="line">    <span class="keyword">return</span> update_get_addr (GET_ADDR_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p = dtv[GET_ADDR_MODULE].pointer.val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == TLS_DTV_UNALLOCATED))</span><br><span class="line">    <span class="keyword">return</span> tls_get_addr_tail (GET_ADDR_PARAM, dtv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">char</span> *) p + GET_ADDR_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sysdeps/x86_64/nptl/tls.h</span></span><br><span class="line"><span class="comment">/* Return the address of the dtv for the current thread.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_DTV() \</span></span><br><span class="line">  (&#123; struct pthread *__pd;                  \</span><br><span class="line">     THREAD_GETMEM (__pd, header.dtv); &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read member of the thread descriptor directly.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_GETMEM(descr, member) \</span></span><br><span class="line">  (&#123; __typeof (descr-&gt;member) __value;                \</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">sizeof</span> (__value) == <span class="number">1</span>)                 \</span><br><span class="line">       <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;movb %%fs:%P2,%b0&quot;</span>              \</span><br><span class="line">         : <span class="string">&quot;=q&quot;</span> (__value)               \</span><br><span class="line">         : <span class="string">&quot;0&quot;</span> (<span class="number">0</span>), <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, member)));     \</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span> (__value) == <span class="number">4</span>)                \</span><br><span class="line">       <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;movl %%fs:%P1,%0&quot;</span>               \</span><br><span class="line">         : <span class="string">&quot;=r&quot;</span> (__value)               \</span><br><span class="line">         : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, member)));        \</span><br><span class="line">     <span class="keyword">else</span>                     \</span><br><span class="line">       &#123;                      \</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">sizeof</span> (__value) != <span class="number">8</span>)               \</span><br><span class="line">     <span class="comment">/* There should not be any value with a size other than 1,       \</span></span><br><span class="line"><span class="comment">        4 or 8.  */</span>                 \</span><br><span class="line">     <span class="built_in">abort</span> ();                    \</span><br><span class="line">                        \</span><br><span class="line">   <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">&quot;movq %%fs:%P1,%q0&quot;</span>              \</span><br><span class="line">           : <span class="string">&quot;=r&quot;</span> (__value)               \</span><br><span class="line">           : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, member)));        \</span><br><span class="line">       &#125;                      \</span><br><span class="line">     __value; &#125;)</span><br></pre></td></tr></table></figure><p>结构体<code>pthread</code>的定义如下，其中<code>header</code>字段为<code>tcbhead_t</code>类型，对应的定义如下。可知，上面提到的偏移<code>xxx</code>实际上就是<code>dtv</code>字段在<code>tcbhead_t</code>结构体中的偏移，<code>THREAD_GETMEM</code>宏定义其实就是获取的<code>dtv</code>字段的值。</p><blockquote><p>在<code>Linux x86_64</code>中，<code>glibc</code>将<code>fs</code>段寄存器指向<code>tcbhead_t</code>结构体。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Thread descriptor data structure.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TLS_DTV_AT_TP</span></span><br><span class="line">    <span class="comment">/* This overlaps the TCB as used for TLS without threads (see tls.h).  */</span></span><br><span class="line">    <span class="keyword">tcbhead_t</span> header;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">int</span> multiple_threads;</span><br><span class="line">      <span class="keyword">int</span> gscope_flag;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __ASSUME_PRIVATE_FUTEX</span></span><br><span class="line">      <span class="keyword">int</span> private_futex;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; header;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sysdeps/x86_64/nptl/tls.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;    <span class="comment">/* Pointer to the TCB.  Not necessarily the thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;   <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">int</span> gscope_flag;</span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="keyword">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><p>在<code>gdb</code>中进行调试，如下。可以看到，<code>fs</code>寄存器的地址为<code>0x00007ffff7fe1780</code>，位于<code>dsi-&gt;commands</code>缓冲区的下方。因此，可以通过溢出覆盖<code>tcbhead_t</code>结构体，修改其中的<code>dtv</code>字段来伪造<code>tls_dtor_list</code>，从而进行控制流劫持。</p><blockquote><p>正常情况下，在<code>gdb</code>中无法查看<code>fs</code>段寄存器的值(显示为<code>0</code>)，采用<code>pwndbg</code>插件中的<code>fsbase</code>命令也无效，可以通过系统调用<code>arch_prctl(0x1003, writable_addr)</code>来获取其值。其中，<code>0x1003</code>对应<code>ARCH_GET_FS</code>，<code>0x1004</code>则对应<code>ARCH_GET_GS</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info proc mappings</span><br><span class="line">      # ...</span><br><span class="line">      0x7ffff7edf000     0x7ffff7fe0000   0x101000        0x0   # &lt;=== heap via mmap(), dsi-&gt;commands</span><br><span class="line">      0x7ffff7fe0000     0x7ffff7ffb000    0x1b000        0x0   # Thread Local Storage(TLS)</span><br><span class="line">      0x7ffff7ffb000     0x7ffff7ffc000     0x1000        0x0 [vdso]</span><br><span class="line">      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x20000 /usr/lib/ld-2.20-2014.11.so</span><br><span class="line">      0x7ffff7ffd000     0x7ffff7fff000     0x2000    0x21000 /usr/lib/ld-2.20-2014.11.so</span><br><span class="line">      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]</span><br><span class="line">  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]</span><br><span class="line">(gdb) x/4i $rip</span><br><span class="line">=&gt; 0x7ffff7b751bd &lt;dsi_stream_receive+461&gt;:     call   0x7ffff7b59d60 &lt;dsi_stream_read@plt&gt;</span><br><span class="line">   0x7ffff7b751c2 &lt;dsi_stream_receive+466&gt;:     cmp    rax,QWORD PTR [rbx+0x106f8]</span><br><span class="line">   0x7ffff7b751c9 &lt;dsi_stream_receive+473&gt;:     jne    0x7ffff7b75029 &lt;dsi_stream_receive+57&gt;</span><br><span class="line">   0x7ffff7b751cf &lt;dsi_stream_receive+479&gt;:     cmp    DWORD PTR [rbp+0x48],0x5</span><br><span class="line">(gdb) i r $rsi</span><br><span class="line">rsi            0x7ffff7edf010      140737352953872    # dsi-&gt;commands when call dsi_stream_read()</span><br><span class="line">(gdb) x/4gx $rsi-0x10</span><br><span class="line">0x7ffff7edf000: 0x0000000000000000      0x0000000000101002</span><br><span class="line">0x7ffff7edf010: 0x0402000010000400      0x0000000080000000</span><br><span class="line">(gdb) call (int)arch_prctl(0x1003, 0x67d000) # get fs value via arch_prctl syscall, 0x67d000 is an arbitrary writable address</span><br><span class="line">(gdb) x/gx 0x67d000</span><br><span class="line">0x67d000:       0x00007ffff7fe1780  # fs value</span><br><span class="line">(gdb) x/10gx 0x00007ffff7fe1780</span><br><span class="line">0x7ffff7fe1780: 0x00007ffff7fe1780      0x00007ffff7fe2090    # tcbhead_t</span><br><span class="line">0x7ffff7fe1790: 0x00007ffff7fe1780      0x0000000000000000</span><br><span class="line">0x7ffff7fe17a0: 0x0000000000000000      0xb0f28a0309ec8500    # stack_guard</span><br><span class="line">0x7ffff7fe17b0: 0x6223ecce6a95bec7      0x0000000000000000</span><br><span class="line">0x7ffff7fe17c0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure><p>至于如何触发<code>exit()</code>函数呢？查看<code>afp</code>相关代码的处理流程，当发送<code>DSICloseSession</code>请求时，其会调用<code>exit(0)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -------------------------------------------</span></span><br><span class="line"><span class="comment"> afp over dsi. this never returns. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afp_over_dsi</span><span class="params">(AFPObj *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* get stuck here until the end */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">/* Blocking read on the network socket */</span></span><br><span class="line">        cmd = dsi_stream_receive(dsi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> DSIFUNC_CLOSE:   <span class="comment">// DSICloseSession</span></span><br><span class="line">            LOG(log_debug, logtype_afpd, <span class="string">&quot;DSI: close session request&quot;</span>);</span><br><span class="line">            afp_dsi_close(obj);</span><br><span class="line">            LOG(log_note, logtype_afpd, <span class="string">&quot;done&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>按照上面的思路，可以修改<code>dtv</code>字段来伪造<code>tls_dtor_list</code>，那么在哪里伪造<code>tls_dtor_list</code>呢？即用什么地址来覆盖<code>dtv</code>字段呢？因此还需要找一块内容可控的地址空间。</p><h4 id="寻找内容可控的地址空间"><a href="#寻找内容可控的地址空间" class="headerlink" title="寻找内容可控的地址空间"></a>寻找内容可控的地址空间</h4><p>这里再次对<code>afp</code>相关代码的处理流程进行分析。前面提到过，在发送<code>DSICommand</code>请求时，如果<code>AFP</code>协议数据包的第一个字段为<code>command</code>，成功解析数据包后会根据该字段来查找对应的处理函数。在正常流程中，会话建立后的第一个请求是<code>AFP FPLogin</code>/<code>AFP FPLoginExt</code>，以<code>AFP FPLogin</code>请求为例，会调用<code>afp_login()</code>来进行处理。</p><p>在<code>afp_login()</code>中，会先获取请求中的<code>version</code>信息并进行校验，校验通过后会获取请求中的<code>uams</code>信息并查找对应的<code>uams</code>模块，查找成功后在<code>(6)</code>处会调用对应的<code>login()</code>方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">afp_login</span><span class="params">(AFPObj *obj, <span class="keyword">char</span> *ibuf, <span class="keyword">size_t</span> ibuflen, <span class="keyword">char</span> *rbuf, <span class="keyword">size_t</span> *rbuflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (ibuflen &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> send_reply(obj, AFPERR_BADVERS );</span><br><span class="line"></span><br><span class="line">    ibuf++;</span><br><span class="line">    len = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) *ibuf++;</span><br><span class="line">    ibuflen -= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    i = get_version(obj, ibuf, ibuflen, len);</span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">        <span class="keyword">return</span> send_reply(obj, i );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ibuflen &lt;= len)</span><br><span class="line">        <span class="keyword">return</span> send_reply(obj, AFPERR_BADUAM);</span><br><span class="line"></span><br><span class="line">    ibuf += len;</span><br><span class="line">    ibuflen -= len;</span><br><span class="line"></span><br><span class="line">    len = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) *ibuf++;</span><br><span class="line">    ibuflen--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!len || len &gt; ibuflen)</span><br><span class="line">        <span class="keyword">return</span> send_reply(obj, AFPERR_BADUAM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == (afp_uam = auth_uamfind(UAM_SERVER_LOGIN, ibuf, len)) )</span><br><span class="line">        <span class="keyword">return</span> send_reply(obj, AFPERR_BADUAM);</span><br><span class="line">    ibuf += len;</span><br><span class="line">    ibuflen -= len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AFP_OK != (i = create_session_key(obj)) )</span><br><span class="line">        <span class="keyword">return</span> send_reply(obj, i);</span><br><span class="line"></span><br><span class="line">    i = afp_uam-&gt;u.uam_login.login(obj, &amp;pwd, ibuf, ibuflen, rbuf, rbuflen);  <span class="comment">// (6)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以<code>&quot;DHX2&quot;</code>为例，会调用<code>uams_dhx2</code>模块中的<code>passwd_login()</code>函数，如下。其中，在<code>(7)</code>处调用<code>uam_afpserver_option()</code>对<code>username</code>和<code>ulen</code>进行初始化，其内部会将<code>obj</code>结构体中的<code>username</code>数组的地址赋值给参数<code>username</code>，<code>username</code>数组的大小赋值给<code>ulen</code>。之后在<code>(8)</code>处调用<code>memcpy()</code>将请求中的数据拷贝到<code>username</code>中。而<code>obj</code>是一个全局未初始化静态变量，故其存在于程序<code>afpd</code>的<code>.bss</code>部分，由于<code>afpd</code>未开启<code>PIE</code>机制，故<code>obj</code>的地址是固定的，<code>username</code>数组的起始地址也是固定的。因此，借助<code>AFP FPLogin</code>/<code>AFP FPLoginExt</code>请求，可以往某个固定地址写入可控内容，即找到了一处内容可控的地址空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">passwd_login</span><span class="params">(<span class="keyword">void</span> *obj, struct passwd **uam_pwd,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">char</span> *ibuf, <span class="keyword">size_t</span> ibuflen,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">char</span> *rbuf, <span class="keyword">size_t</span> *rbuflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *username;</span><br><span class="line">    <span class="keyword">size_t</span> len, ulen;</span><br><span class="line"></span><br><span class="line">    *rbuflen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* grab some of the options */</span></span><br><span class="line">    <span class="keyword">if</span> (uam_afpserver_option(obj, UAM_OPTION_USERNAME, (<span class="keyword">void</span> *) &amp;username, &amp;ulen) &lt; <span class="number">0</span>) &#123;  <span class="comment">// (7)</span></span><br><span class="line">        LOG(log_info, logtype_uams, <span class="string">&quot;DHX2: uam_afpserver_option didn&#x27;t meet uam_option_username  -- %s&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> AFPERR_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) *ibuf++;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">memcpy</span>(username, ibuf, len ); <span class="comment">// (8)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXUSERLEN 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AFPObj</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cmdlineconfigfile;</span><br><span class="line">    <span class="keyword">int</span> cmdlineflags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *signature;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DSI</span> *<span class="title">dsi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">afp_options</span> <span class="title">options</span>;</span></span><br><span class="line">    dictionary *iniconfig;</span><br><span class="line">    <span class="keyword">char</span> username[MAXUSERLEN];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; AFPObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// etc/afpd/main.c</span></span><br><span class="line"><span class="keyword">static</span> AFPObj obj;</span><br></pre></td></tr></table></figure><h4 id="pointer-demangle"><a href="#pointer-demangle" class="headerlink" title="pointer demangle"></a>pointer demangle</h4><p>在实现往某个固定地址写入可控内容后，便可以按照上述思路来伪造<code>tls_dtor_list</code>了。不过，在<code>__call_tls_dtors()</code>中还有一个小问题：在<code>(4)</code>处涉及到<code>pointer demangle</code>，在伪造<code>tls_dtor_list</code>时不能直接使用函数地址如<code>system()</code>来填充<code>func</code>字段，而是需要一个编码后的地址。</p><blockquote><p>和<code>glibc</code>的版本有关，可能在更早的<code>glibc</code>版本中这里不涉及<code>pointer demangle</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __call_tls_dtors (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;  <span class="comment">// (3)</span></span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);  <span class="comment">// (4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);  <span class="comment">// (5)</span></span><br><span class="line">      <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>具体地，看一下宏定义<code>PTR_DEMANGLE</code>和<code>PTR_MANGLE</code>，如下。<code>PTR_MANGLE(var)</code>的作用相当于<code>rol((var ^ pointer_guard), 0x11, 64)</code>，而<code>PTR_DEMANGLE(var)</code>相当于<code>ror(var, 0x11, 64) ^ pointer_guard</code>，而<code>pointer_guard</code>则对应<code>tcbhead_t</code>结构体中的<code>pointer_guard</code>字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysdeps/unix/sysv/linux/x86_64/sysdep.h</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> PTR_MANGLE(var) asm (<span class="meta-string">&quot;xor %%fs:%c2, %0\n&quot;</span>         \</span></span><br><span class="line">             <span class="string">&quot;rol $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0&quot;</span>         \</span><br><span class="line">             : <span class="string">&quot;=r&quot;</span> (var)           \</span><br><span class="line">             : <span class="string">&quot;0&quot;</span> (var),           \</span><br><span class="line">               <span class="string">&quot;i&quot;</span> (offsetof (<span class="keyword">tcbhead_t</span>,        \</span><br><span class="line">                  pointer_guard)))</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> PTR_DEMANGLE(var) asm (<span class="meta-string">&quot;ror $2*&quot;</span> LP_SIZE <span class="meta-string">&quot;+1, %0\n&quot;</span>       \</span></span><br><span class="line">             <span class="string">&quot;xor %%fs:%c2, %0&quot;</span>           \</span><br><span class="line">             : <span class="string">&quot;=r&quot;</span> (var)           \</span><br><span class="line">             : <span class="string">&quot;0&quot;</span> (var),           \</span><br><span class="line">               <span class="string">&quot;i&quot;</span> (offsetof (<span class="keyword">tcbhead_t</span>,        \</span><br><span class="line">                  pointer_guard)))</span><br></pre></td></tr></table></figure><p>因此，为了能够伪造<code>tls_dtor_list</code>中<code>func</code>字段，还需要想办法获取<code>pointer_guard</code>。</p><h4 id="stack-guard-pointer-guard泄露"><a href="#stack-guard-pointer-guard泄露" class="headerlink" title="stack_guard/pointer_guard泄露"></a>stack_guard/pointer_guard泄露</h4><p>想要获取到<code>pointer_guard</code>，一种方式是利用信息泄露来获取，或者通过溢出覆盖的方式将<code>TLS</code>区域中的该字段修改为已知的值，这里先讨论后面一种思路。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysdeps/x86_64/nptl/tls.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;    <span class="comment">/* Pointer to the TCB.  Not necessarily the thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;   <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">int</span> gscope_flag;</span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="keyword">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><p>回顾下<code>tcbhead_t</code>结构体的内容，在<code>pointer_guard</code>字段前存在另一个字段<code>stack_guard</code>，这个字段正是对应<code>stack canary</code>的值。如果通过溢出的方式覆盖<code>pointer_guard</code>字段，肯定也会覆盖<code>stack_guard</code>字段。<code>afpd</code>程序启用了<code>stack canary</code>机制，在调用<code>dsi_stream_read()</code>造成溢出返回后，由于<code>stack canary</code>校验失败，会触发<code>___stack_chk_fail()</code>，程序崩溃。因此需要先想办法获取<code>stack_guard</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:00007FFFF7B7502B loc_7FFFF7B7502B:                       ; CODE XREF: dsi_stream_receive+1EA↓j</span><br><span class="line">.text:00007FFFF7B7502B                 mov     rcx, [rsp+48h+var_30]</span><br><span class="line">.text:00007FFFF7B75030                 xor     rcx, fs:28h  ; &lt;&#x3D;&#x3D;&#x3D; fs:28h, 即对应tcbhead_t结构体中的stack_guard字段</span><br><span class="line">.text:00007FFFF7B75039                 jnz     loc_7FFFF7B75234</span><br><span class="line">.text:00007FFFF7B7503F                 add     rsp, 20h</span><br><span class="line">.text:00007FFFF7B75043                 pop     rbx</span><br><span class="line">.text:00007FFFF7B75044                 pop     rbp</span><br><span class="line">.text:00007FFFF7B75045                 pop     r12</span><br><span class="line">.text:00007FFFF7B75047                 pop     r13</span><br><span class="line">.text:00007FFFF7B75049                 pop     r14</span><br><span class="line">.text:00007FFFF7B7504B                 retn</span><br><span class="line">; ...</span><br><span class="line">.text:00007FFFF7B75234 loc_7FFFF7B75234:                       ; CODE XREF: dsi_stream_receive+49↑j</span><br><span class="line">.text:00007FFFF7B75234                 call    ___stack_chk_fail</span><br></pre></td></tr></table></figure><p>幸运地是，<code>afpd</code>程序处理会话采用了<code>fork</code>机制，利用这一机制可以泄露出<code>stack_guard</code>。具体地，针对每个新的会话，<code>afpd</code>程序会<code>fork</code>出<code>1</code>个子进程，然后交由子进程进行处理。而子进程中的<code>stack_guard</code>和<code>pointer_guard</code>等字段来自于父进程，同时子进程的崩溃对父进程没有影响。因此，可以采用类似<code>Blind Rop</code>的思路，通过逐字节覆盖<code>stack_guard</code>的方式来进行泄露：当覆盖<code>stack_guard</code>中的某个字节时，如果填充的字节与原始值相同，程序会按照正常的流程继续执行，<code>socket</code>连接正常；如果不一致则会造成后续<code>stack canary</code>校验失败，触发<code>___stack_chk_fail()</code>，程序崩溃，<code>socket</code>连接被关闭。基于这一差异，结合<code>afpd</code>的<code>fork</code>机制，可以按字节逐位对<code>stack_guard</code>进行爆破，从而泄露<code>stack_guard</code>。</p><img src="images/cq674350529_stack_guard_bruteforce.png" style="zoom:60%"><p>在获取到<code>stack_guard</code>后，可以采用类似的思路对<code>pointer_guard</code>进行泄露。不过，由于在<code>exit()</code>后续流程中只有<code>func</code>字段那里涉及到<code>pointer demangle</code>，可以通过溢出覆盖的方式直接将其修改为指定的值。</p><blockquote><p>在采用类似思路泄露<code>pointer_guard</code>时会存在一个小问题：正常情况下，<code>PTR_DEMANGLE(var)</code>的结果对应某个函数地址，而在进行爆破的过程中，只能区分出<code>PTR_DEMANGLE(var)</code>的结果为一个有效的指令地址，也就是说结果的低<code>2</code>个字节可以在一定范围内变动，比如上面汇编代码中的<code>0x7FFFF7B7502B</code>和<code>0x7FFFF7B75234</code>均为有效的指令地址。因此，爆破出的<code>pointer_guard</code>的低<code>2</code>个字节可能会存在多种可能(取决于具体的情况)，不过可能的组合数应该不会太多，爆破出来后逐一尝试即可。</p></blockquote><p>到目前为止，所有的问题都解决了，可以采用伪造<code>tls_dtor_list</code>的方式来实现控制流劫持了，如下。其中，由于<code>afpd</code>程序中没有调用<code>system()</code>，而采用函数如<code>popen()</code>、<code>afprun()</code>等时存在其他问题，故通过<code>execl(&quot;/bin/bash&quot;, &quot;bash&quot;, &quot;-c&quot;, &lt;cmd&gt;, 0)</code>来实现命令执行。虽然调用<code>execl()</code>时参数传递相对麻烦，但通过合适的布局，可使其前<code>5</code>个参数均可控。</p><blockquote><p>下图中标注的<code>execl_addr</code>仅为方便描述，实际填充的值应为<code>PTR_MANGLE(execl_addr)</code>。</p></blockquote><img src="images/cq674350529_vuln_exploit_summary.png" style="zoom:75%"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文基于群晖<code>DSM</code> <code>6.1.7-15284</code>版本，对<code>Pwn2Own Tokyo 2020</code>比赛上<code>DEVCORE</code>团队使用的堆溢出漏洞进行了分析。漏洞的触发相对比较简单，漏洞的利用思路则参考了<code>@Angelboy</code>的议题《Your NAS is not your NAS !》，介绍通过伪造<code>tls_dtor_list</code>来实现代码执行的目的，并对其中的一些关键点如寻找内容可控的地址空间、<code>stack_guard</code>泄露、<code>pointer demangle</code>等进行了细致分析。之前对<code>tls_dtor_list</code>这块不太了解，在完成漏洞利用的过程中学到了很多，感兴趣地可以自己动手搭建环境试试。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>根据前面的利用思路，溢出并进行合适的布局后，需要调用<code>exit()</code>来触发。在<code>@Angelboy</code>给出的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Njd3VhcHR4L0NURi9ibG9iL21hc3Rlci8yMDIxLXdyaXRldXAvaGl0Y29uL21ldGF0YWxrLnB5">hitcon metatalk writeup<i class="fa fa-external-link-alt"></i></span>中，利用思路与其议题分享中的类似，但是缺少了爆破<code>stack_guard</code>这一环节。在请教<code>@Angelboy</code>后，其主要是利用了<code>timeout handler</code>机制。在<code>netatalk</code>中，函数<code>alarm_handler()</code>用于<code>SIGALRM</code>信号的处理，当触发<code>alarm_handler()</code>并满足一定条件后，其内部会调用<code>exit()</code>。因此，通过构造数据包使得<code>dsi_doff</code>字段的值大于实际发送的<code>afp payload</code>的长度，造成调用<code>dsi_stream_read()</code>时等待并超时，就有可能在溢出之后自动触发<code>exit()</code>，避免了<code>dsi_stream_receive()</code>返回时存在的<code>___stack_chk_fail()</code>问题。</p><p>在题目<code>metatalk</code>中，对应的<code>sleep time</code>和<code>disconnect time</code>均设置为<code>0</code>，而在<code>Synology NAS DSM 6.1.7-15284</code>中，<code>afp.conf</code>中的部分配置为：<code>timeout = 8, sleep time = 8, disconnect time = 48</code>。<code>alarm_handler</code>相关的代码如下，可知，<code>alarm_handler()</code>大约每<code>30</code>秒触发一次，若想触发<code>afp_dsi_die()</code>，在其他条件均满足时，似乎至少需要触发<code>alarm_handler()</code> <code>8</code>次才行。</p><blockquote><p>针对该方法，暂未在实际设备上进行测试。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in afp_config_parse()</span></span><br><span class="line">options-&gt;tickleval      = atalk_iniparser_getint   (config, INISEC_GLOBAL, <span class="string">&quot;tickleval&quot;</span>,      <span class="number">30</span>);</span><br><span class="line">options-&gt;timeout        = atalk_iniparser_getint   (config, INISEC_GLOBAL, <span class="string">&quot;timeout&quot;</span>,        <span class="number">4</span>);</span><br><span class="line">options-&gt;sleep          = atalk_iniparser_getint   (config, INISEC_GLOBAL, <span class="string">&quot;sleep time&quot;</span>,     <span class="number">10</span>);</span><br><span class="line">options-&gt;disconnected   = atalk_iniparser_getint   (config, INISEC_GLOBAL, <span class="string">&quot;disconnect time&quot;</span>,<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in dsi_getsession()</span></span><br><span class="line"><span class="keyword">case</span> DSIFUNC_OPEN: <span class="comment">/* setup session */</span></span><br><span class="line">    <span class="comment">/* set up the tickle timer */</span></span><br><span class="line">    dsi-&gt;timer.it_interval.tv_sec = dsi-&gt;timer.it_value.tv_sec = tickleval;</span><br><span class="line">    dsi-&gt;timer.it_interval.tv_usec = dsi-&gt;timer.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    dsi_opensession(dsi);</span><br><span class="line">    *childp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in afp_over_dsi_sighandlers()</span></span><br><span class="line">action.sa_handler = alarm_handler;</span><br><span class="line"><span class="keyword">if</span> ((sigaction(SIGALRM, &amp;action, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) ||</span><br><span class="line">        (setitimer(ITIMER_REAL, &amp;dsi-&gt;timer, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">    afp_dsi_die(EXITERR_SYS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alarm_handler</span><span class="params">(<span class="keyword">int</span> sig _U_)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dsi-&gt;tickle++;</span><br><span class="line">    <span class="keyword">if</span> (dsi-&gt;flags &amp; DSI_SLEEPING) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dsi-&gt;tickle &gt; AFPobj-&gt;options.sleep) &#123;</span><br><span class="line">            LOG(log_note, logtype_afpd, <span class="string">&quot;afp_alarm: sleep time ended&quot;</span>);</span><br><span class="line">            afp_dsi_die(EXITERR_CLNT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsi-&gt;flags &amp; DSI_DISCONNECTED) &#123;</span><br><span class="line">    <span class="comment">// check username instead of euid</span></span><br><span class="line">    <span class="keyword">if</span> (!dsi-&gt;AFPobj || !dsi-&gt;AFPobj-&gt;username)</span><br><span class="line">    &#123;</span><br><span class="line">            LOG(log_note, logtype_afpd, <span class="string">&quot;afp_alarm: unauthenticated user, connection problem&quot;</span>);</span><br><span class="line">            afp_dsi_die(EXITERR_CLNT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dsi-&gt;tickle &gt; AFPobj-&gt;options.disconnected) &#123;</span><br><span class="line">            LOG(log_error, logtype_afpd, <span class="string">&quot;afp_alarm: reconnect timer expired, goodbye&quot;</span>);</span><br><span class="line">            afp_dsi_die(EXITERR_CLNT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we&#x27;re in the midst of processing something, don&#x27;t die. */</span>        </span><br><span class="line">    <span class="keyword">if</span> (dsi-&gt;tickle &gt;= AFPobj-&gt;options.timeout) &#123;</span><br><span class="line">        LOG(log_error, logtype_afpd, <span class="string">&quot;afp_alarm: child timed out, entering disconnected state&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (dsi_disconnect(dsi) != <span class="number">0</span>)</span><br><span class="line">            afp_dsi_die(EXITERR_CLNT);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemVyb2RheWluaXRpYXRpdmUuY29tL2Fkdmlzb3JpZXMvWkRJLTIxLTQ5Mi8=">Synology DiskStation Manager Netatalk dsi_doff Heap-based Buffer Overflow Remote Code Execution Vulnerability<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oaXRjb24ub3JnLzIwMjEvYWdlbmRhLzAzZjA2Njc1LTI2MWQtNGM5Ny1iNTI0LTMzZWY5Y2M2Y2NiMi8lRTQlQkQlQTAlRTclOUElODQlMjBOQVMlMjAlRTQlQjglOEQlRTYlOTglQUYlRTQlQkQlQTAlRTclOUElODQlMjBOQVMlMjAhLnBkZg==">HITCON21-你的 NAS 不是你的 NAS !<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZjby5yZS9ibG9nLzIwMjIvMDMvMjgveW91ci1OQVMtaXMtbm90LXlvdXItTkFTLWVuLw==">Blog: Your NAS is not your NAS !<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9raWxlYWsuZ2l0aHViLmlvL2N0Zi8yMDIxL2hpdGNvbjIxLW1ldGF0YWxrLw==">hitcon CTF 2021 - metatalk<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF0YV9TdHJlYW1fSW50ZXJmYWNl">Data Stream Interface<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXJlLnByZXNzLzIwMjAvMTAvMTgvZ2xpYmMtdGxzLw==">Glibc TLS的实现与利用<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2JpbmhvbGljLmJsb2dzcG90LmNvbS8yMDE3LzA1L25vdGVzLW9uLWFidXNpbmctZXhpdC1oYW5kbGVycy5odG1s">Notes on abusing exit handlers, bypassing pointer mangling and glibc ptmalloc hooks<i class="fa fa-external-link-alt"></i></span></li></ul></div><footer class="post-footer"><div class="reward-container"><div>你的支持是我最大的动力</div><button>赞赏</button><div class="post-reward"><div><img src="/uploads/wechatpay.png" alt="cq674350529 微信"> <span>微信</span></div></div></div><div class="post-tags"><a href="/tags/Synology/" rel="tag"># Synology</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2024/04/02/Analyzing-the-MiniDLNA-Http-Chunk-Parsing-Vulnerability-CVE-2023-33476/" rel="prev" title="Analyzing the MiniDLNA Http Chunk Parsing Vulnerability (CVE-2023-33476)"><i class="fa fa-chevron-left"></i> Analyzing the MiniDLNA Http Chunk Parsing Vulnerability (CVE-2023-33476)</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">cq674350529</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-blog-alpha.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"locale":{"placeholder":"欢迎评论, 填上邮箱可以收到回复邮件 :)"},"avatar":"mm","meta":["nick","mail"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2024/09/03/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/Pwn2Own2020-Synology-NAS-Netatalk-Heap-Overflow-Analysis/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});</script></body></html>